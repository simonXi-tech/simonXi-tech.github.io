<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言">
<meta property="og:type" content="article">
<meta property="og:title" content="34-linux-进程">
<meta property="og:url" content="http://yoursite.com/2020/03/29/34-linux-%E8%BF%9B%E7%A8%8B/index.html">
<meta property="og:site_name" content="simonXi的技术博客">
<meta property="og:description" content="前言">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/images/34-linux-%E8%BF%9B%E7%A8%8B/1.%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png">
<meta property="og:image" content="http://yoursite.com/images/34-linux-%E8%BF%9B%E7%A8%8B/3.%E9%87%8D%E5%AE%9A%E5%90%91.png">
<meta property="og:image" content="http://yoursite.com/images/34-linux-%E8%BF%9B%E7%A8%8B/2.%E7%AE%A1%E9%81%93.png">
<meta property="og:image" content="http://yoursite.com/images/34-linux-%E8%BF%9B%E7%A8%8B/4.%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png">
<meta property="og:image" content="http://yoursite.com/images/34-linux-%E8%BF%9B%E7%A8%8B/5.%E4%BF%A1%E5%8F%B7%E9%9B%86.png">
<meta property="article:published_time" content="2020-03-29T09:18:40.000Z">
<meta property="article:modified_time" content="2020-07-04T04:44:14.567Z">
<meta property="article:author" content="simonXi">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/34-linux-%E8%BF%9B%E7%A8%8B/1.%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png">

<link rel="canonical" href="http://yoursite.com/2020/03/29/34-linux-%E8%BF%9B%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>34-linux-进程 | simonXi的技术博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">simonXi的技术博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">13</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">13</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">37</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/simonXi-tech" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/29/34-linux-%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="simonXi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="simonXi的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          34-linux-进程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-29 17:18:40" itemprop="dateCreated datePublished" datetime="2020-03-29T17:18:40+08:00">2020-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-04 12:44:14" itemprop="dateModified" datetime="2020-07-04T12:44:14+08:00">2020-07-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>34k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>31 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>linux中每一个运行的程序就是一个进程。程序是由若干条具有一定功能的指令所组成的解题顺序和步骤(磁盘中)。进程是计算机中程序关于某个数据集合上的一次运行活动(内存中)，是操作系统进行资源分配和调度的基本单元。对于32位的linux操作系统，每一个进程都认为其拥有0~4G的虚拟地址空间。虚拟地址空间可以分为内核空间和用户空间。内核空间地址为3G~4G，用户空间为0~3G。</p>
<p>由上可知，每个进程都认为自己有4G的虚拟地址空间。实际上，内核空间是所有进程共享的，用户空间是各个进程独享的。简单理解，如果两个进程间要进行通信必须要有一个桥梁，而每个进程的用户空间都是独享的，只有通过内核空间才能进行进程间通信。并且对于所有进程必须要进行统一的管理，故内核空间中必然使用类似数组的方式对每个进程的信息进行管理。在内核中，每个进程都有一个进程控制块(PCB, Processing Control Block)来维护进程相关的信息，linux内核的进程控制块是task_struct结构体。<br>博主使用Ubuntu18.04，在/usr/src/linux-headers-5.3.0-53/include/linux/sched.h中可以找到task_struct结构体。</p>
<p><a href="https://www.kernel.org/pub/linux/kernel/v2.6/" target="_blank" rel="noopener">linux 2.6版本</a></p>
<p>进程之间共享的数据：代码段、文件描述符(管道、fifo、套接字)、内存映射区<br>线程之间共享的数据：代码段、堆、全局变量、内存映射区。栈不共享。</p>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p><img src="/images/34-linux-进程/1.进程状态.png" alt="&quot;1.进程状态&quot;"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"><b>图1</b></div>
    <br>
</center>

<p>创建状态：进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态<br>就绪状态：进程已经准备好，已分配到所需资源，只要分配到CPU就能够立即运行<br>执行状态：进程处于就绪状态被调度后，进程进入执行状态<br>阻塞状态：正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用<br>终止状态：进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pid_t fork(void);	&#x2F;&#x2F; 失败返回-1；成功返回：父进程返回子进程的ID(非负)；子进程返回 0 </span><br><span class="line">&#x2F;&#x2F; 注意：fork函数不是返回两个值，而是fork之后就存在两个进程。每个进程有不同的返回值。</span><br><span class="line">&#x2F;&#x2F; 父子进程执行的顺序随机。fork后父子进程从相同的程序位置开始执行。</span><br><span class="line">pid_t getpid(void);	  &#x2F;&#x2F; 获取当前进程ID</span><br><span class="line">pid_t getppid(void);  &#x2F;&#x2F; 获取当前进程的父进程ID</span><br><span class="line">uid_t getuid(void);   &#x2F;&#x2F; 获取当前进程实际用户ID</span><br><span class="line">uid_t geteuid(void);  &#x2F;&#x2F; 获取当前进程有效用户ID</span><br><span class="line">gid_t getgid(void);   &#x2F;&#x2F; 获取当前进程使用用户组ID</span><br><span class="line">gid_t getegid(void);  &#x2F;&#x2F; 获取当前进程有效用户组ID</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1个父进程循环创建n个子进程</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int n &#x3D; 5, i;				    &#x2F;&#x2F;一个父进程默认创建5个子进程</span><br><span class="line">	pid_t pid;</span><br><span class="line"></span><br><span class="line">	if (argc &#x3D;&#x3D; 2) &#123;	</span><br><span class="line">		n &#x3D; atoi(argv[1]);		&#x2F;&#x2F;字符串转整数</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pid &#x3D; fork();			&#x2F;&#x2F;出口1,父进程专用出口</span><br><span class="line">		if (pid &#x3D;&#x3D; 0)</span><br><span class="line">			break;				&#x2F;&#x2F;出口2,子进程出口,i不自增</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (n &#x3D;&#x3D; i) &#123;</span><br><span class="line">		sleep(n);</span><br><span class="line">		printf(&quot;I am parent, pid &#x3D; %d\n&quot;, getpid());</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		sleep(i);</span><br><span class="line">		printf(&quot;I&#39;m %dth child, pid &#x3D; %d\n&quot;, i+1, getpid());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父子进程fork之后，简单来看，子进程复制了父进程0~3G用户空间内容以及父进程的PCB，但是pid不同。故子进程执行的代码位置和父进程执行的代码位置相同。之后，根据对<br>fork()返回值的判断，父子进程可以执行不同的代码。</p>
<p><strong>注意</strong>：</p>
<ol>
<li>父子进程执行顺序不定</li>
<li>根据fork返回值判断父子进程</li>
<li>在实际使用过程父子进程间遵循<strong>读时共享写时复制</strong>的原则，这样可以节省内存开销。<br>同时也说明父子进程之间数据是不关联的(父子进程之间不共享全局变量)。</li>
</ol>
<h3 id="exce函数族"><a href="#exce函数族" class="headerlink" title="exce函数族"></a>exce函数族</h3><p>当进程调用exec函数时，当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程ID不变，换核不换壳。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int execl(const char *path, const char *arg, ...);  &#x2F;&#x2F; 加载一个进程，通过路径+程序名来加载</span><br><span class="line">&#x2F;&#x2F; path:要执行程序的绝对路径</span><br><span class="line">&#x2F;&#x2F; 变参arg:要执行程序需要的参数</span><br><span class="line">&#x2F;&#x2F; 第一个arg:占位</span><br><span class="line">&#x2F;&#x2F; 后边的arg:命令的参数</span><br><span class="line">&#x2F;&#x2F; 哨兵：NULL</span><br><span class="line">int execlp(const char *file, const char *arg, ...); &#x2F;&#x2F; 借助环境变量PATH加载一个进程,该函数用来调用系统程序</span><br><span class="line">&#x2F;&#x2F; file:执行命令的名字</span><br><span class="line">&#x2F;&#x2F; 第一个arg:占位</span><br><span class="line">&#x2F;&#x2F; 后边的arg:命令的参数</span><br><span class="line">&#x2F;&#x2F; 哨兵：NULL</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>execl.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    execl(&quot;&#x2F;bin&#x2F;ls&quot;, &quot;ls&quot;, &quot;-lah&quot;, NULL);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>execlp.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;-aux&quot;, NULL);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="孤儿进程和僵尸进程"><a href="#孤儿进程和僵尸进程" class="headerlink" title="孤儿进程和僵尸进程"></a>孤儿进程和僵尸进程</h3><p>孤儿进程: 父进程先于子进程结束，则子进程成为孤儿进程。子进程的父进程变为init进程，称init进程领养孤儿进程。进程结束之后，能够释放用户空间的资源，而内核空间<br>的PCB必须由父进程释放。<br>僵尸进程: 进程终止，父进程尚未回收子进程残留资源(PCB)，则变成僵尸（Zombie）进程。<br>僵尸进程是不能使用kill命令清除掉的。因为kill命令只是用来终止进程的，而僵尸进程已经终止。此时，如果需要释放僵尸进程的残留资源，就需要结束父进程。父进程结束<br>就会自动回收僵尸进程的资源。</p>
<h3 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h3><p>进程终止时会关闭所有的文件描述符，释放在用户空间分配的内存，但PCB是保留的，内核在其中保留了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。父进程可以调用wait或waitpid得到子进程的退出状态同时彻底清除掉这个进程。</p>
<p>父进程调用wait函数可以回收子进程终止信息。该函数有三个功能：</p>
<ul>
<li>阻塞等待子进程退出 </li>
<li>回收子进程残留资源 </li>
<li>获取子进程结束状态(退出原因)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pid_t wait(int *status); 	&#x2F;&#x2F; 一次只能回收一个子进程</span><br><span class="line">&#x2F;&#x2F; status是wait的传出参数，保存进程的结束状态(正常退出还是异常终止)。借助宏函数可以进一步判断进程终止的具体原因。</span><br><span class="line">&#x2F;&#x2F; 正常退出：return 0； exit(0) 此时WEXITSTATUS(staus)可以获取return或exit的返回参数</span><br><span class="line">&#x2F;&#x2F; 第一组：</span><br><span class="line">WIFEXITED(status)     为非0	→ 进程正常结束</span><br><span class="line">WEXITSTATUS(status)   如上宏为真，使用此宏 → 获取进程退出状态 (exit的参数)</span><br><span class="line">&#x2F;&#x2F; 第二组：</span><br><span class="line">WIFSIGNALED(status)   为非0 → 进程异常终止</span><br><span class="line">WTERMSIG(status)      如上宏为真，使用此宏 → 取得使进程终止的那个信号的编号</span><br><span class="line">&#x2F;&#x2F; 第三组：</span><br><span class="line">WIFSTOPPED(status)    为非0 → 进程处于暂停状态</span><br><span class="line">WSTOPSIG(status)      如上宏为真，使用此宏 → 取得使进程暂停的那个信号的编号</span><br><span class="line">WIFCONTINUED(status)  为真 → 进程暂停后已经继续运行</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回值：&gt;0 回收子进程ID；-1 回收失败(没有可回收的子进程)</span><br></pre></td></tr></table></figure>
<ul>
<li>abnor.c</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  int a &#x3D; 5&#x2F;0;  &#x2F;&#x2F; 除0错误 进程执行时linux发送SIGFPE信号终止进程</span><br><span class="line"></span><br><span class="line">	return 56;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait.c</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid, wpid;</span><br><span class="line">	int status;</span><br><span class="line"></span><br><span class="line">	pid &#x3D; fork();</span><br><span class="line"></span><br><span class="line">	if(pid &#x3D;&#x3D; -1)&#123;</span><br><span class="line">		perror(&quot;fork error&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125; else if(pid &#x3D;&#x3D; 0)&#123;		</span><br><span class="line">		printf(&quot;I&#39;m process child, pid &#x3D; %d\n&quot;, getpid());</span><br><span class="line">#if 0</span><br><span class="line">		execl(&quot;.&#x2F;abnor&quot;, &quot;abnor&quot;, NULL);  &#x2F;&#x2F; 子进程异常终止</span><br><span class="line">		perror(&quot;execl error&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">#endif</span><br><span class="line">		sleep(1);				</span><br><span class="line">		exit(10);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		wpid &#x3D; wait(&amp;status);	    &#x2F;&#x2F; 传出参数</span><br><span class="line"></span><br><span class="line">		if(WIFEXITED(status))&#123;	  &#x2F;&#x2F; 正常退出</span><br><span class="line">			printf(&quot;I&#39;m parent, The child process &quot;</span><br><span class="line">					&quot;%d exit normally\n&quot;, wpid);</span><br><span class="line">			printf(&quot;return value:%d\n&quot;, WEXITSTATUS(status));</span><br><span class="line"></span><br><span class="line">		&#125; else if (WIFSIGNALED(status)) &#123;	&#x2F;&#x2F; 异常退出</span><br><span class="line">			printf(&quot;The child process exit abnormally, &quot;</span><br><span class="line">					&quot;killed by signal %d\n&quot;, WTERMSIG(status));</span><br><span class="line">										&#x2F;&#x2F; 获取信号编号</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			printf(&quot;other...\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父进程调用waitpid可指定pid进程清理,可以不阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pid_t waitpid(pid_t pid, int *status, in options);	&#x2F;&#x2F; 一次只能回收一个子进程</span><br><span class="line">特殊参数和返回情况：</span><br><span class="line">&#x2F;&#x2F; 参数pid： &gt;0:回收指定ID的子进程	&#x3D;0:回收当前进程组任意子进程</span><br><span class="line">&#x2F;&#x2F; -1:回收任意子进程(相当于wait)  &lt;-1:等待其组ID等于pid的绝对值的任一进程</span><br><span class="line">&#x2F;&#x2F; status:子进程的退出状态，与wait相同</span><br><span class="line">&#x2F;&#x2F; options:设置为WNOHANG是函数非阻塞；设置为0时函数阻塞</span><br><span class="line">&#x2F;&#x2F; 返回值：&gt;0 返回回收子进程ID；-1 回收失败(没有可回收的子进程)；&#x3D;0 只有在options为WNOHANG有效，表示子进程正在运行</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid &#x3D; fork();</span><br><span class="line"></span><br><span class="line">    if (pid &lt; 0) &#123;</span><br><span class="line">        perror(&quot;fork failed&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (pid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        int i;</span><br><span class="line">        for (i &#x3D; 3; i &gt; 0; i--) &#123;</span><br><span class="line">            printf(&quot;This is the child\n&quot;);</span><br><span class="line">            sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line">        exit(34);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int stat_val;</span><br><span class="line">        waitpid(pid, &amp;stat_val, 0);     &#x2F;&#x2F; 阻塞</span><br><span class="line"></span><br><span class="line">        if (WIFEXITED(stat_val))</span><br><span class="line">            printf(&quot;Child exited with code %d\n&quot;, WEXITSTATUS(stat_val));</span><br><span class="line">        else if (WIFSIGNALED(stat_val))</span><br><span class="line">            printf(&quot;Child terminated abnormally, signal %d\n&quot;, WTERMSIG(stat_val));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int n &#x3D; 5, i;				</span><br><span class="line">	pid_t p, q;</span><br><span class="line"></span><br><span class="line">	if(argc &#x3D;&#x3D; 2)&#123;	</span><br><span class="line">		n &#x3D; atoi(argv[1]);</span><br><span class="line">	&#125;</span><br><span class="line">    q &#x3D; getpid();</span><br><span class="line"></span><br><span class="line">	for(i&#x3D;0; i&lt;n; i++)	 &#123;</span><br><span class="line">        p &#x3D; fork();</span><br><span class="line">		if(p &#x3D;&#x3D; 0)</span><br><span class="line">			break;			</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	if(n &#x3D;&#x3D; i)&#123;  		&#x2F;&#x2F; 父进程</span><br><span class="line">		sleep(n);</span><br><span class="line">		printf(&quot;I am parent, pid &#x3D; %d\n&quot;, getpid());</span><br><span class="line">        for (i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            p &#x3D; waitpid(0, NULL, WNOHANG);	&#x2F;&#x2F; fork出的进程属于一个进程组</span><br><span class="line">            printf(&quot;wait  pid &#x3D; %d\n&quot;, p);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		sleep(i);</span><br><span class="line">		printf(&quot;I&#39;m %dth child, pid &#x3D; %d\n&quot;, i+1, getpid());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重定向dup和dup2"><a href="#重定向dup和dup2" class="headerlink" title="重定向dup和dup2"></a>重定向dup和dup2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int dup(int oldfd); 	&#x2F;&#x2F; 成功：返回一个新文件描述符；失败：-1设置errno为相应值</span><br><span class="line">int dup2(int oldfd, int newfd); 	&#x2F;&#x2F; 将oldfd复制给newfd</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int fd, save_fd;</span><br><span class="line">	char msg[] &#x3D; &quot;It&#39;s just a test!\n&quot;;</span><br><span class="line"></span><br><span class="line">	fd &#x3D; open(&quot;test.txt&quot;, O_RDWR|O_CREAT|O_TRUNC, 0644);	&#x2F;&#x2F; fd&#x3D;3</span><br><span class="line">	if(fd &lt; 0)&#123;</span><br><span class="line">		perror(&quot;open error&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	save_fd &#x3D; dup(STDOUT_FILENO);			&#x2F;&#x2F; save_fd 指向 STDOUT</span><br><span class="line">	printf(&quot;save_fd &#x3D; %d\n&quot;, save_fd);</span><br><span class="line">	write(save_fd, msg, strlen(msg));		&#x2F;&#x2F; 打印到标准输出</span><br><span class="line">#if 1</span><br><span class="line">	dup2(STDOUT_FILENO, fd);	&#x2F;&#x2F; 把STDOUT_FILENO复制给fd</span><br><span class="line">	write(fd, msg, strlen(msg));</span><br><span class="line">#else</span><br><span class="line">	dup2(fd, STDOUT_FILENO);	&#x2F;&#x2F; 把fd复制给STDOUT_FILENO</span><br><span class="line">	&#x2F;&#x2F;puts(msg);				&#x2F;&#x2F; 向标准输出设备输出字符串换行	&#x2F;&#x2F; 重定向标准输出到fd，输出到test.txt文件							</span><br><span class="line">	write(fd, msg, strlen(msg));	</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	close(fd);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/34-linux-进程/3.重定向.png" alt="&quot;3.重定向&quot;"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重定向就是对文件设置新的文件描述符。旧文件描述符关闭，新文件描述符还是可以访问。</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int fd;</span><br><span class="line">	char *str &#x3D; &quot;hello dup2\n&quot;;</span><br><span class="line"></span><br><span class="line">	fd &#x3D; open(&quot;test.txt&quot;, O_WRONLY|O_TRUNC|O_CREAT, 0644);</span><br><span class="line">	if(fd &lt; 0)&#123;</span><br><span class="line">		perror(&quot;open test1 error&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	dup2(fd, STDOUT_FILENO);</span><br><span class="line"></span><br><span class="line">	close(fd);	&#x2F;&#x2F; 关闭fd依然可以访问对应文件</span><br><span class="line"></span><br><span class="line">	int n &#x3D; write(fd, str, strlen(str));		</span><br><span class="line">	printf(&quot;--------|%d\n&quot;, n);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信(IPC)"></a>进程间通信(IPC)</h1><p>Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。进程和进程之间数据相互独立，要交换数据必须通过内核。在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信(IPC，InterProcess Communication)。</p>
<h2 id="文件方式"><a href="#文件方式" class="headerlink" title="文件方式"></a>文件方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line"></span><br><span class="line">void sys_err(const char *str)</span><br><span class="line">&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int fd &#x3D; open(&quot;testFile.txt&quot;, O_RDWR | O_TRUNC | O_CREAT, 0664);</span><br><span class="line">    if (fd &#x3D;&#x3D; -1)</span><br><span class="line">        sys_err(&quot;open err&quot;);</span><br><span class="line">    int ret;</span><br><span class="line">    char buf[1024];</span><br><span class="line"></span><br><span class="line">    pid_t pid &#x3D; fork();</span><br><span class="line">    if (pid &#x3D;&#x3D; -1)</span><br><span class="line">        sys_err(&quot;fork err&quot;);</span><br><span class="line"></span><br><span class="line">    if (pid &gt; 0) &#123;</span><br><span class="line">        write(fd, &quot;file IPC\n&quot;, strlen(&quot;file IPC\n&quot;));</span><br><span class="line">        printf(&quot;----write finish ----\n&quot;);</span><br><span class="line">        wait(NULL);</span><br><span class="line">    &#125; else if (pid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        lseek(fd, 0, SEEK_SET);</span><br><span class="line">        ret &#x3D; read(fd, buf, sizeof(buf));</span><br><span class="line">        write(STDOUT_FILENO, buf, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="管道方式-进程之间有血缘关系"><a href="#管道方式-进程之间有血缘关系" class="headerlink" title="管道方式(进程之间有血缘关系)"></a>管道方式(进程之间有血缘关系)</h2><p>管道本质上是一个内存缓冲区，可以以文件的方式对齐进行操作。在linux中可以使用<code>ulimit -a</code>命令查看当前系统中创建管道文件所对应的缓冲区的大小。也可以使用<br><code>fpathconf</code>函数来查看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int pipe(int pipefd[2]);		&#x2F;&#x2F; 成功：0；失败：-1，设置errno</span><br><span class="line">&#x2F;&#x2F; pipefd是传出参数，返回r&#x2F;w两个文件描述符。规定：fd[0]对应读端，fd[1]对应写端。如果进程中没有打开其他文件，则fd[0]&#x3D;3，fd[1]&#x3D;4。</span><br></pre></td></tr></table></figure>
<p>管道创建成功后，创建该管道的进程同时掌握着管道的读端和写端。此时，父进程可以fork出子进程，这样子进程也会掌握管道的读端和写端。由图2可知，如果两个进程同时<br>对管道进行读写，必然造成冲突。因此，管道的使用中一方需要关闭读端，而另一方需要关闭写端。即一个管道只能实现半双工通信，如果要实现全双工通信，必须采用两个管道。</p>
<p><img src="/images/34-linux-进程/2.管道.png" alt="&quot;2.管道&quot;"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"><b>图2</b></div>
    <br>
</center>

<p>父子进程通信过程：</p>
<ol>
<li>父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。</li>
<li>父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。</li>
<li>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</li>
</ol>
<p>管道的读写行为：</p>
<ol>
<li>如果所有指向管道写端的文件描述符都关闭了（管道写端引用计数为0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。</li>
<li>如果有指向管道写端的文件描述符没关闭（管道写端引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。</li>
<li>如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端写数据，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然也可以对SIGPIPE信号实施捕捉，不终止进程。</li>
<li>如果有指向管道读端的文件描述符没关闭（管道读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。</li>
</ol>
<ul>
<li>读管道：    </li>
</ul>
<ol>
<li>管道中有数据，read返回实际读到的字节数。</li>
<li>管道中无数据：管道写端被全部关闭，read返回0；写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)</li>
</ol>
<ul>
<li>写管道：    </li>
</ul>
<ol>
<li>管道读端全部被关闭，进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止)，管道破裂。</li>
<li>管道读端没有全部关闭：管道已满，write阻塞；管道未满，write将数据写入，并返回实际写入的字节数。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 父子进程之间通信</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid;</span><br><span class="line">	int fd[2];</span><br><span class="line"></span><br><span class="line">	pipe(fd);</span><br><span class="line">	pid &#x3D; fork();</span><br><span class="line"></span><br><span class="line">	if (pid &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F;child</span><br><span class="line">		close(fd[1]);	                &#x2F;&#x2F;子进程从管道中读数据，关闭写端</span><br><span class="line">		dup2(fd[0], STDIN_FILENO);		&#x2F;&#x2F;让wc从管道中读取数据</span><br><span class="line">		execlp(&quot;wc&quot;, &quot;wc&quot;, &quot;-l&quot;, NULL);	&#x2F;&#x2F;wc命令默认从标准读入取数据</span><br><span class="line"></span><br><span class="line">	&#125; else &#123;</span><br><span class="line"></span><br><span class="line">		close(fd[0]);	&#x2F;&#x2F;父进程向管道中写数据，关闭读端</span><br><span class="line">		dup2(fd[1], STDOUT_FILENO);		&#x2F;&#x2F;将ls的结果写入管道中</span><br><span class="line">		execlp(&quot;ls&quot;, &quot;ls&quot;, NULL);		&#x2F;&#x2F;ls输出结果默认对应屏幕</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 兄弟进程之间通信</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid;</span><br><span class="line">	int fd[2], i;</span><br><span class="line">	</span><br><span class="line">	pipe(fd);</span><br><span class="line"></span><br><span class="line">	for (i &#x3D; 0; i &lt; 2; i++) &#123;</span><br><span class="line">		if((pid &#x3D; fork()) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">			break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	if (i &#x3D;&#x3D; 0) &#123;			&#x2F;&#x2F; 兄</span><br><span class="line">		close(fd[0]);				&#x2F;&#x2F; 写,关闭读端</span><br><span class="line">		dup2(fd[1], STDOUT_FILENO);		</span><br><span class="line">		execlp(&quot;ls&quot;, &quot;ls&quot;, NULL);	</span><br><span class="line">	&#125; else if (i &#x3D;&#x3D; 1) &#123;	&#x2F;&#x2F; 弟</span><br><span class="line">		close(fd[1]);				&#x2F;&#x2F; 读，关闭写端</span><br><span class="line">		dup2(fd[0], STDIN_FILENO);		</span><br><span class="line">		execlp(&quot;wc&quot;, &quot;wc&quot;, &quot;-l&quot;, NULL);		</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">        close(fd[0]);</span><br><span class="line">        close(fd[1]);</span><br><span class="line">		for(i &#x3D; 0; i &lt; 2; i++)		&#x2F;&#x2F;两个儿子wait两次</span><br><span class="line">			wait(NULL);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>管道默认是阻塞的，如果需要设置管道非阻塞。可以使用fcntl函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int flags &#x3D; fcntl(fd[0], F_GETFL);</span><br><span class="line">flag |&#x3D; O_NONBLOCK;</span><br><span class="line">fcntl(fd[0], F_SETFL, flags);</span><br></pre></td></tr></table></figure></p>
<h2 id="fifo方式-进程之间无血缘关系"><a href="#fifo方式-进程之间无血缘关系" class="headerlink" title="fifo方式(进程之间无血缘关系)"></a>fifo方式(进程之间无血缘关系)</h2><p>FIFO被称为有名管道。FIFO是Linux基础文件类型中的一种。但FIFO文件在磁盘上大小永远为0，仅仅用来标识内核中一条管道(缓冲区)。各进程可以打开这个文件进行read/write，实际上是在读写内核通道，这样就实现了进程间通信。</p>
<p>创建方式：</p>
<ol>
<li>命令：mkfifo 管道名    ls命令查看：prw-r—r— 1    p表示管道</li>
<li>库函数：int mkfifo(const char *pathname,  mode_t mode);      // 成功：0； 失败：-1<br>一旦使用mkfifo创建了一个FIFO，就可以使用open打开它，常见的文件I/O函数都可用于fifo。如：close、read、write、unlink等。</li>
</ol>
<ul>
<li>fifo_write.c</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void sys_err(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    exit(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int fd, i;</span><br><span class="line">    char buf[4096];</span><br><span class="line"></span><br><span class="line">    if (argc &lt; 2) &#123;</span><br><span class="line">        printf(&quot;Enter like this: .&#x2F;a.out fifoname\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int ret &#x3D; access(argv[1], F_OK);	&#x2F;&#x2F; 判断文件是否存在</span><br><span class="line">    if (ret !&#x3D; 0) &#123;</span><br><span class="line">        mkfifo(argv[1], 0664);			&#x2F;&#x2F; 如果管道文件不存在，用mkfifo创建管道</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fd &#x3D; open(argv[1], O_WRONLY);		</span><br><span class="line">    if (fd &lt; 0) </span><br><span class="line">        sys_err(&quot;open&quot;);</span><br><span class="line"></span><br><span class="line">    i &#x3D; 0;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        sprintf(buf, &quot;hello world %d\n&quot;, i++);</span><br><span class="line">        write(fd, buf, strlen(buf));</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>fifo_read.c</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void sys_err(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int fd, len;</span><br><span class="line">    char buf[4096];</span><br><span class="line"></span><br><span class="line">    if (argc &lt; 2) &#123;</span><br><span class="line">        printf(&quot;.&#x2F;a.out fifoname\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    fd &#x3D; open(argv[1], O_RDONLY);</span><br><span class="line">    if (fd &lt; 0) </span><br><span class="line">        sys_err(&quot;open&quot;);</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        len &#x3D;read(fd, buf, sizeof(buf));	&#x2F;&#x2F; 管道默认阻塞</span><br><span class="line">        write(STDOUT_FILENO, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>内存映射对于有血缘关系和无血缘关系的进程间都可以通信。内存映射使一个磁盘文件与存储空间中的一个缓冲区相映射。当从缓冲区中取数据，就相当于读文件中的相应字节；将数据存入缓冲区，则相应的字节就自动写入文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void *mmap(void *adrr, size_t length, int prot, int flags, int fd, off_t offset); </span><br><span class="line">参数：	</span><br><span class="line">	addr: 建立映射区的首地址，由Linux内核指定。使用时，直接传递NULL</span><br><span class="line">	length: 欲创建映射区的大小(默认分配4k的整数倍,不能为0)</span><br><span class="line">	prot: 映射区权限PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE </span><br><span class="line">	flags: 标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区)</span><br><span class="line">		MAP_SHARED:  映射区所做的操作同步到磁盘。注意：mmap的映射区权限小于等于open打开时文件的权限</span><br><span class="line">		MAP_PRIVATE: 映射区所做的操作不会同步到磁盘。</span><br><span class="line">	fd: 用来建立映射区的文件描述符(创建映射区后可以关闭文件描述符)</span><br><span class="line">	offset: 映射文件的偏移(4k的整数倍)，否则返回无效参数</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">	成功：返回创建的映射区首地址(不能越界操作)；失败：MAP_FAILED宏</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用munmap释放映射区空间</span><br><span class="line">int munmap(void *addr, size_t length);	</span><br><span class="line"></span><br><span class="line">返回值：成功：0； 失败：-1</span><br></pre></td></tr></table></figure>
<p>如果mmap对应的磁盘文件不存在，使用open函数的O_CREAT创建一个新文件时必须指定文件大小。应该使用lseek或truncate做文件拓展。</p>
<ul>
<li>lseek函数<br>lseek函数可以用来修改文件偏移量。每个打开的文件都记录这当前读写位置，打开文件时读写位置为0，表示文件开头，通常读写多少个字节就会将读写位置往后移多少个字节。<br>如果以O_APPEND方式打开，每次写操作都会在文件末尾追加数据，然后将读写位置移到新的文件末尾。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">off_t lseek(int fd, off_t offset, int whence); </span><br><span class="line">参数：</span><br><span class="line">offset 的含义取决于参数 whence：</span><br><span class="line">    1. 如果 whence 是 SEEK_SET，文件偏移量将被设置为 offset。</span><br><span class="line">    2. 如果 whence 是 SEEK_CUR，文件偏移量将被设置为当前文件偏移量 + offset，offset 可正可负</span><br><span class="line">    3. 如果 whence 是 SEEK_END，文件偏移量将被设置为文件长度 + offset，offset 可正可负</span><br><span class="line"></span><br><span class="line">在Unix文件操作中，文件偏移量可以大于当前文件的长度，在这种情况下对文件的下一次 写 将延长该文件，并在文件中构成一个空洞。位于文件中但没有写过的</span><br><span class="line">字节都设为0。</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">	失败返回-1；成功：返回值是较文件起始位置向后的偏移量。</span><br><span class="line">lseek(fd, 0, SEEK_END);	&#x2F;&#x2F; 获取文件大小	</span><br><span class="line">&#x2F;&#x2F; lseek允许超过文件结尾设置偏移量，文件会因此被拓展。</span><br></pre></td></tr></table></figure>
<ul>
<li>mmap.c</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;mman.h&gt;</span><br><span class="line"></span><br><span class="line">void sys_err(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char *mem;</span><br><span class="line">    int len &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    int fd &#x3D; open(&quot;mmap.txt&quot;, O_RDWR|O_CREAT|O_TRUNC, 0644);	&#x2F;&#x2F; 创建文件，或者将文件指针指向SEEK_SET</span><br><span class="line">    if (fd &lt; 0)</span><br><span class="line">        sys_err(&quot;open error&quot;);</span><br><span class="line"></span><br><span class="line">    len &#x3D; lseek(fd, 3, SEEK_SET);   &#x2F;&#x2F; 将文件指针指向SEEK_SET + 3的位置</span><br><span class="line">    write(fd, &quot;\0&quot;, 1);             &#x2F;&#x2F; 空洞文件文件拓展，必须进行一次写操作</span><br><span class="line">    len &#x3D; lseek(fd, 0, SEEK_END);	&#x2F;&#x2F; SEEK_END指向文件最后一个字符</span><br><span class="line">    </span><br><span class="line">    printf(&quot;The length of file &#x3D; %d\n&quot;, len);	&#x2F;&#x2F; len &#x3D; 4</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; mem &#x3D; mmap(NULL, len, PROT_WRITE, MAP_PRIVATE, fd, 0);	&#x2F;&#x2F; MAP_PRIVATE:对映射空间写入不影响磁盘文件</span><br><span class="line">	mem &#x3D; mmap(NULL, len, PROT_WRITE, MAP_SHARED, fd, 0);		&#x2F;&#x2F; 映射文件长度为4，实际系统分配4K</span><br><span class="line">    if (mem &#x3D;&#x3D; MAP_FAILED)</span><br><span class="line">        sys_err(&quot;mmap err: &quot;);</span><br><span class="line">    close(fd);	&#x2F;&#x2F; 关闭文件描述符对将缓冲区中内容写入文件无影响</span><br><span class="line"></span><br><span class="line">    strcpy(mem, &quot;hello&quot;);</span><br><span class="line">    printf(&quot;%s\n&quot;, mem);	&#x2F;&#x2F; hello MAP_SHARED写入的字符不超过文件大小,文件大小为4,故写入4字节</span><br><span class="line"></span><br><span class="line">    if (munmap(mem,  len) &lt; 0)</span><br><span class="line">        sys_err(&quot;munmap&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mmap父子间通信"><a href="#mmap父子间通信" class="headerlink" title="mmap父子间通信"></a>mmap父子间通信</h3><p><img src="/images/34-linux-进程/4.虚拟文件系统.png" alt="&quot;4.虚拟文件系统&quot;"></p>
<p>Linux允许多个dentry共享一个inode，即共享盘块。mv命令只修改了dentry(dentry包括文件名)，不修改inode。<br>Linux下删除文件是将与inode对应的硬连接数减为0，这样在文件系统中就没有对应的dentry了。磁盘上的文件实际是没有擦除的。如果重新建立了dentry，文件<br>还是可以读取的。类似于windows下格式化磁盘只是把索引去除了，但是磁盘内容还是存在的。要想真的删除磁盘内容，就需要对要删除的空间进行覆盖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 截断文件长度成指定长度，常用来拓展文件大小。</span><br><span class="line">int truncate(const char *path, off_t length);	成功：0；失败：-1设置errno为相应值</span><br><span class="line">int ftruncate(int fd, off_t length);	</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; link函数创建硬连接。硬连接全部删除时才会删除文件，软连接如果文件删除，软连接指向的文件错误。</span><br><span class="line">int link(const char *oldpath,  const char *newpath);	成功：0；失败：-1设置errno为相应值</span><br><span class="line">int unlink(const char *pathname);	成功：0；失败：-1设置errno为相应值</span><br><span class="line">int symlink(const char *oldpath, const char *newpath);	成功：0；失败：-1设置errno为相应值</span><br></pre></td></tr></table></figure>
<p>在进程中使用ulink删除文件只是让文件具备了被释放的条件。只有所有打开该文件的进程关闭该文件，系统才会择机释放该文件。<br>当进程结束运行时，所有该进程打开的文件都会被关闭，申请的内存空间会被释放。系统这一特性成为隐式回收。</p>
<ul>
<li>创建文件进行父子进程通信</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;mman.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line"></span><br><span class="line">int var &#x3D; 100;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int *p;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    int fd;</span><br><span class="line">    fd &#x3D; open(&quot;temp&quot;, O_RDWR|O_CREAT|O_TRUNC, 0644);</span><br><span class="line">    if(fd &lt; 0)&#123;</span><br><span class="line">        perror(&quot;open error&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    unlink(&quot;temp&quot;);				&#x2F;&#x2F; 删除临时文件目录项,使之具备被释放条件</span><br><span class="line">    ftruncate(fd, 4);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;p &#x3D; (int *)mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);		&#x2F;&#x2F; 父子进程共享映射区</span><br><span class="line">    p &#x3D; (int *)mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);	&#x2F;&#x2F; 父子进程各自独占映射区</span><br><span class="line">    if(p &#x3D;&#x3D; MAP_FAILED)&#123;		</span><br><span class="line">        perror(&quot;mmap error&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);					&#x2F;&#x2F; 映射区建立完毕,即可关闭文件</span><br><span class="line"></span><br><span class="line">    pid &#x3D; fork();				&#x2F;&#x2F; 创建子进程</span><br><span class="line">    if(pid &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        *p &#x3D; 2000;</span><br><span class="line">        var &#x3D; 1000;</span><br><span class="line">        printf(&quot;child, *p &#x3D; %d, var &#x3D; %d\n&quot;, *p, var);	&#x2F;&#x2F; 2000 1000</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        printf(&quot;parent, *p &#x3D; %d, var &#x3D; %d\n&quot;, *p, var);	&#x2F;&#x2F; 2000 100</span><br><span class="line">        wait(NULL);</span><br><span class="line"></span><br><span class="line">        int ret &#x3D; munmap(p, 4);				&#x2F;&#x2F; 释放映射区</span><br><span class="line">        if (ret &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            perror(&quot;munmap error&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不创建文件进行父子进程通信(匿名映射)<br>每次创建映射区要依赖一个文件来实现太麻烦，可以直接使用匿名映射(宏：MAP_ANONYMOUS和MAP_ANON)的方式替代。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;mman.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int *p;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    p &#x3D; mmap(NULL, 400, PROT_READ|PROT_WRITE, MAP_SHARED | MAP_ANON, -1, 0);</span><br><span class="line">    if(p &#x3D;&#x3D; MAP_FAILED)&#123;</span><br><span class="line">        perror(&quot;mmap error&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid &#x3D; fork();               &#x2F;&#x2F;创建子进程</span><br><span class="line">    if(pid &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        *p &#x3D; 2000;</span><br><span class="line">        printf(&quot;child, *p &#x3D; %d\n&quot;, *p);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        printf(&quot;parent, *p &#x3D; %d\n&quot;, *p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    munmap(p, 400);             &#x2F;&#x2F;释放映射区</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mmap无血缘关系通信"><a href="#mmap无血缘关系通信" class="headerlink" title="mmap无血缘关系通信"></a>mmap无血缘关系通信</h3><p>无血缘关系的进程之间通信，必须要建立磁盘文件才能创建映射区。</p>
<ul>
<li>读进程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;mman.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">struct Student &#123;</span><br><span class="line">    int id;</span><br><span class="line">    char name[20];</span><br><span class="line">    char sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void sys_err(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    exit(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    struct Student stu;</span><br><span class="line">    struct Student *maddr;</span><br><span class="line"></span><br><span class="line">    if (argc &lt; 2) &#123;</span><br><span class="line">        printf(&quot;.&#x2F;a.out file_shared\n&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd &#x3D; open(argv[1], O_RDONLY);</span><br><span class="line">    if (fd &#x3D;&#x3D; -1)</span><br><span class="line">        sys_err(&quot;open error&quot;);</span><br><span class="line"></span><br><span class="line">    maddr &#x3D; mmap(NULL, sizeof(stu), PROT_READ, MAP_SHARED, fd, 0);</span><br><span class="line">    if (maddr &#x3D;&#x3D; MAP_FAILED)</span><br><span class="line">        sys_err(&quot;mmap error&quot;);</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        printf(&quot;id&#x3D;%d\tname&#x3D;%s\t%c\n&quot;, maddr-&gt;id, maddr-&gt;name, maddr-&gt;sex);</span><br><span class="line">        usleep(10000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    munmap(maddr, sizeof(stu));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>写进程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;mman.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">struct Student &#123;</span><br><span class="line">    int id;</span><br><span class="line">    char name[20];</span><br><span class="line">    char sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void sys_err(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    struct Student stu &#x3D; &#123;10, &quot;xiaoming&quot;, &#39;m&#39;&#125;;</span><br><span class="line">    char *maddr;</span><br><span class="line"></span><br><span class="line">    if (argc &lt; 2) &#123;</span><br><span class="line">        printf(&quot;.&#x2F;a.out file_shared\n&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd &#x3D; open(argv[1], O_RDWR | O_CREAT, 0664);</span><br><span class="line">    ftruncate(fd, sizeof(stu));</span><br><span class="line"></span><br><span class="line">    maddr &#x3D; mmap(NULL, sizeof(stu), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</span><br><span class="line">    if (maddr &#x3D;&#x3D; MAP_FAILED)</span><br><span class="line">        sys_err(&quot;mmap&quot;);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        memcpy(maddr, &amp;stu, sizeof(stu));</span><br><span class="line">        stu.id++;</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    munmap(maddr, sizeof(stu));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>进程A可以向进程B发送信号。进程B收到信号之前执行自己的代码，收到信号后，不管程序执行到什么位置，都要暂停运行去处理信号，处理完毕再继续执行。每个进程收到的所有信号都由内核负责发送。linux中可以使用kill -l命令查看当前系统中可使用的信号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1</span><br><span class="line">11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM</span><br><span class="line">16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP</span><br><span class="line">21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR</span><br><span class="line">31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1	64) SIGRTMAX</span><br></pre></td></tr></table></figure>
<p>可以通过类似<code>man 7 signal</code>的方式查看信号对应的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Signal     Value     Action   Comment</span><br><span class="line">──────────────────────────────────────────────────────────────────────</span><br><span class="line">SIGHUP        1       Term    Hangup detected on controlling terminal   &#x2F;&#x2F; 当用户退出shell时，由该shell启动的所有进程将收到这个信号</span><br><span class="line">                                or death of controlling process         &#x2F;&#x2F; 默认动作终止进程</span><br><span class="line">SIGINT        2       Term    Interrupt from keyboard                   &#x2F;&#x2F; Ctrl+C组合键发出该信号，终止进程</span><br><span class="line">SIGQUIT       3       Core    Quit from keyboard                        &#x2F;&#x2F; Ctrl+\组合键发出该信号，终止进程</span><br><span class="line">SIGILL        4       Core    Illegal Instruction</span><br><span class="line">SIGABRT       6       Core    Abort signal from abort(3)                &#x2F;&#x2F; 调用abort函数发出该信号，终止进程并产生core文件</span><br><span class="line">SIGFPE        8       Core    Floating-point exception                  &#x2F;&#x2F; 非法算术操作</span><br><span class="line">SIGKILL       9       Term    Kill signal                               &#x2F;&#x2F; 无条件终止进程。信号不能被捕捉、阻塞和忽略</span><br><span class="line">SIGSEGV      11       Core    Invalid memory reference                  &#x2F;&#x2F; 无效内存访问，终止进程并生成core文件</span><br><span class="line">SIGPIPE      13       Term    Broken pipe: write to pipe with no        &#x2F;&#x2F; 向一个没有读端的管道写数据，管道破裂</span><br><span class="line">                                readers; see pipe(7)</span><br><span class="line">SIGALRM      14       Term    Timer signal from alarm(2)                &#x2F;&#x2F; 定时器超时</span><br><span class="line">SIGTERM      15       Term    Termination signal</span><br><span class="line">SIGUSR1   30,10,16    Term    User-defined signal 1</span><br><span class="line">SIGUSR2   31,12,17    Term    User-defined signal 2</span><br><span class="line">SIGCHLD   20,17,18    Ign     Child stopped or terminated               &#x2F;&#x2F; 子进程结束，父进程会收到这个信号，默认忽略。</span><br><span class="line">SIGCONT   19,18,25    Cont    Continue if stopped                       &#x2F;&#x2F; 进程暂停使用这个信号通知进程继续执行</span><br><span class="line">SIGSTOP   17,19,23    Stop    Stop process                              &#x2F;&#x2F; 停止进程运行。信号不能被捕捉、阻塞和忽略</span><br><span class="line">SIGTSTP   18,20,24    Stop    Stop typed at terminal                    &#x2F;&#x2F; Ctrl+Z暂停进程</span><br><span class="line">SIGTTIN   21,21,26    Stop    Terminal input for background process</span><br><span class="line">SIGTTOU   22,22,27    Stop    Terminal output for background process</span><br><span class="line"></span><br><span class="line">The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.</span><br></pre></td></tr></table></figure>
<p>SIGKILL和SIGSTOP信号不能被捕捉、阻塞和忽略。<br>默认动作包括：    Term:终止进程   Ign:忽略信号 (默认即时对该种信号忽略操作)<br>        Core:终止进程，生成Core文件。(查验进程死亡原因， 用于gdb调试)<br>        Stop：停止（暂停）进程  Cont：继续运行进程</p>
<p>kill命令产生信号：kill 信号宏名/编号 进程ID</p>
<ul>
<li>kill系统函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int kill(pid_t pid, int sig);</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    pid &gt; 0:  发送信号给指定的进程。</span><br><span class="line">	pid &#x3D; 0:  发送信号给与调用kill函数进程属于同一进程组的所有进程。</span><br><span class="line">	pid &lt; -1: 取|pid|发给对应进程组。</span><br><span class="line">	pid &#x3D; -1：发送给进程有权限发送的系统中所有进程。</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    成功：0；失败：-1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">#define N 5</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 任一子进程发送信号杀死父进程</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;				    &#x2F;&#x2F; 默认创建5个子进程</span><br><span class="line"></span><br><span class="line">	for(i &#x3D; 0; i &lt; N; i++)	</span><br><span class="line">		if(fork() &#x3D;&#x3D; 0)</span><br><span class="line">			break;			</span><br><span class="line"></span><br><span class="line">    if (i &#x3D;&#x3D; 3) &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        printf(&quot;-----------child ---pid &#x3D; %d, ppid &#x3D; %d\n&quot;, getpid(), getppid());</span><br><span class="line">        kill(getppid(), SIGKILL);</span><br><span class="line"></span><br><span class="line">    &#125; else if (i &#x3D;&#x3D; N) &#123;</span><br><span class="line">        printf(&quot;I am parent, pid &#x3D; %d\n&quot;, getpid());</span><br><span class="line">        while(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>abort系统函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        printf(&quot;pid &#x3D; %d\n&quot;, getpid());</span><br><span class="line">        sleep(1);</span><br><span class="line">        abort();    &#x2F;&#x2F; 给当前进程发送指定信号SIGABRT(自己发给自己)</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>raise 函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int raise(int sig); 成功：0，失败非0值</span><br></pre></td></tr></table></figure>
</li>
<li><p>软件条件产生信号</p>
</li>
</ul>
<p>alarm函数设置定时器，在指定seconds后，内核会给当前进程发送SIGALARM信号。进程收到该信号，默认动作终止。每个进程都有且只有唯一的一个定时器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unsigned int alarm(unsigned int seconds); </span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    0或剩余的秒数。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定时1s看能打印多少个数</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	alarm(1);</span><br><span class="line"></span><br><span class="line">	for(i &#x3D; 0; ; i++)</span><br><span class="line">		printf(&quot;%d\n&quot;, i);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);	成功：0；失败：-1，设置errno</span><br><span class="line">参数：which：指定定时方式</span><br><span class="line">    自然定时：ITIMER_REAL → 14）SIGLARM                        计算自然时间</span><br><span class="line">    虚拟空间计时(用户空间)：ITIMER_VIRTUAL → 26）SIGVTALRM      只计算进程占用cpu的时间</span><br><span class="line">    运行时计时(用户+内核)：ITIMER_PROF → 27）SIGPROF            计算占用cpu及执行系统调用的时间</span><br></pre></td></tr></table></figure>
<h3 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h3><p>在进程控制块PCB中，有两个非常重要的信号集：阻塞信号集和未决信号集。执行信号的处理动作成为信号递达，信号从产生到递达之间的状态，成为信号未决。<br>如果不设置阻塞信号集，信号只会短暂的在未决信号集中从0-&gt;1-&gt;0，0-&gt;1表示信号未决，1-&gt;0表示信号递达。</p>
<p><img src="/images/34-linux-进程/5.信号集.png" alt="&quot;5.信号集&quot;"></p>
<p>block集（阻塞集、屏蔽集）：一个进程所要屏蔽的信号，在对应要屏蔽的信号位置1<br>pending集（未决信号集）：如果某个信号在进程的阻塞集中，则也在未决集中对应位置1，表示该信号不能被递达，不会被处理<br>handler（信号处理函数集）：表示每个信号所对应的信号处理函数，当信号不在未决集中时，将被调用</p>
<p>用户可以修改阻塞集，不能修改未决信号集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int sigemptyset(sigset_t *set);			    &#x2F;&#x2F; 将某个信号集清0 成功：0；失败：-1，设置errno</span><br><span class="line">int sigfillset(sigset_t *set);				&#x2F;&#x2F; 将某个信号集置1 成功：0；失败：-1，设置errno</span><br><span class="line">int sigaddset(sigset_t *set, int signum);	&#x2F;&#x2F; 将阻塞信号集中的某个信号置1   成功：0；失败：-1，设置errno</span><br><span class="line">int sigdelset(sigset_t *set, int signum);	&#x2F;&#x2F; 将阻塞信号集中某个信号置0   成功：0；失败：-1，设置errno</span><br><span class="line">int sigismember(const sigset_t *set, int signum);   &#x2F;&#x2F; 判断某个信号是否在信号集中：在：1；不在：0；出错：-1，设置errno</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 屏蔽信号或解除屏蔽</span><br><span class="line">int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);	成功：0；失败：-1，设置errno</span><br><span class="line">参数：</span><br><span class="line">    how参数取值：假设当前的信号屏蔽字为mask</span><br><span class="line">        1.SIG_BLOCK: 当how设置为此值，set表示需要屏蔽的信号。相当于 mask &#x3D; mask|set</span><br><span class="line">        2.SIG_UNBLOCK: 当how设置为此，set表示需要解除屏蔽的信号。相当于 mask &#x3D; mask &amp; ~set</span><br><span class="line">        3.SIG_SETMASK: 当how设置为此，set表示用于替代原始屏蔽及的新屏蔽集。</span><br><span class="line">	set：传入参数，是一个自定义信号集合。由参数how来指示如何修改当前信号屏蔽字。</span><br><span class="line">	oldset：传出参数，保存旧的信号屏蔽字。</span><br><span class="line">		</span><br><span class="line">&#x2F;&#x2F; 读取当前进程的未决信号集</span><br><span class="line">int sigpending(sigset_t *set);	set传出参数。   返回值：成功：0；失败：-1，设置errno</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">void sys_err(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_set(sigset_t* set)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i&#x3D;1; i&lt;32; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(sigismember(set, i))</span><br><span class="line">            putchar(&#39;1&#39;);</span><br><span class="line">        else</span><br><span class="line">            putchar(&#39;0&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打印未决信号集</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    sigset_t set, oldset, pendset;</span><br><span class="line"></span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    sigemptyset(&amp;set);</span><br><span class="line">    sigaddset(&amp;set, SIGQUIT);   &#x2F;&#x2F; 阻塞信号集SIGQUIT信号置1,当有SIGQUIT信号发出时，未决信号集相应位置1</span><br><span class="line"></span><br><span class="line">    ret &#x3D; sigprocmask(SIG_BLOCK, &amp;set, &amp;oldset);</span><br><span class="line">    if(ret &#x3D;&#x3D; -1)</span><br><span class="line">        sys_err(&quot;sigprocmask error&quot;);</span><br><span class="line"></span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        ret &#x3D; sigpending(&amp;pendset);</span><br><span class="line">        if(ret &#x3D;&#x3D; -1)</span><br><span class="line">            sys_err(&quot;sigpending error&quot;);</span><br><span class="line"></span><br><span class="line">        print_set(&amp;pendset);</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信号屏蔽集在进程执行期间都是生效的。</p>
<h3 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一种：signal函数，不推荐使用</span><br><span class="line">typedef void (*sighandler_t)(int);  &#x2F;&#x2F; 注册一个信号捕捉函数</span><br><span class="line">sighandler_t signal(int signum, sighandler_t handler); &#x2F;&#x2F; 成功：返回函数指针；失败：返回SIG_ERR，设置errno</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第二种: sigaction函数，推荐使用</span><br><span class="line">int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);  &#x2F;&#x2F; 成功：0；失败：-1，设置errno</span><br><span class="line">参数：</span><br><span class="line">    act：传入参数，新的处理方式。</span><br><span class="line">	oldact：传出参数，旧的处理方式。	</span><br><span class="line"></span><br><span class="line">struct sigaction &#123;</span><br><span class="line">        void     (*sa_handler)(int);</span><br><span class="line">        void     (*sa_sigaction)(int, siginfo_t *, void *);</span><br><span class="line">        sigset_t   sa_mask;</span><br><span class="line">        int       sa_flags;</span><br><span class="line">        void     (*sa_restorer)(void);</span><br><span class="line">    &#125;;</span><br><span class="line">sa_handler：指定信号捕捉后的处理函数名(即注册函数)。也可赋值为SIG_IGN表忽略或SIG_DFL表执行默认动作</span><br><span class="line">sa_sigaction：很少使用  </span><br><span class="line">sa_mask: 调用信号处理函数时，所要屏蔽的信号集合(信号屏蔽字)。注意：仅在处理函数被调用期间屏蔽生效，是临时性设置。</span><br><span class="line">sa_flags：通常设置为0，表使用默认属性。默认sa_flags为0，表示屏蔽本信号。即比如SIGINT信号对应函数执行期间，屏蔽SIGINT信号。  </span><br><span class="line">sa_restorer：过时弃用</span><br></pre></td></tr></table></figure>
<p>sa_mask只工作于信号处理函数执行期间。PCB中的屏蔽信号集可以决定进程屏蔽哪些信号，执行信号捕捉函数时的屏蔽信号集由sa_mask指定。<br>一个信号执行信号捕捉函数时，该信号被屏蔽。只有等待信号捕捉函数执行完成，被屏蔽的信号才能执行(相当于阻塞)。阻塞的信号不支持排队，多次<br>发出信号只记录一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void sig_handle(int signo)</span><br><span class="line">&#123;</span><br><span class="line">	if(signo &#x3D;&#x3D; SIGQUIT)</span><br><span class="line">		printf(&quot;catch signal %d\n&quot;, signo);</span><br><span class="line"></span><br><span class="line">	sleep(5);			&#x2F;&#x2F; 模拟信号处理函数执行很长时间</span><br><span class="line">	printf(&quot;end of handle\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct sigaction act, oldact;		</span><br><span class="line"></span><br><span class="line">	act.sa_handler &#x3D; sig_handle;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);		</span><br><span class="line">	sigaddset(&amp;act.sa_mask, SIGINT);	</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 将SIGINT加入信号屏蔽集</span><br><span class="line">	&#x2F;&#x2F; 在调用信号处理函数期间:不响应SIGQUIT信号本身,也不响应SIGINT(当信号处理函数执行完才响应)</span><br><span class="line">	act.sa_flags &#x3D; 0;	</span><br><span class="line"></span><br><span class="line">	sigaction(SIGQUIT, &amp;act, &amp;oldact);		&#x2F;&#x2F; 注册信号SIGINT捕捉函数</span><br><span class="line"></span><br><span class="line">	while(1);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="借助SIGCHLD信号回收子进程"><a href="#借助SIGCHLD信号回收子进程" class="headerlink" title="借助SIGCHLD信号回收子进程"></a>借助SIGCHLD信号回收子进程</h3><p>SIGCHLD产生的条件：子进程终止；子进程接收到SIGSTOP信号停止；子进程处于停止态，接收到SIGCONT后唤醒。<br>父进程fork子进程后，如果父进程使用execl函数族，则父进程不能回收子进程。此时，可以使用信号的方式进行回调回收子进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">void sys_err(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void do_sig_child(int signo)</span><br><span class="line">&#123;</span><br><span class="line">    int status;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    if ((pid &#x3D; waitpid(0, &amp;status, WNOHANG)) &gt; 0) &#123; &#x2F;&#x2F; 如果一次有多个进程终止，则由于回调函数一次只能回收一个，且多个进程信号只保留一个</span><br><span class="line">                                                    &#x2F;&#x2F; 这样会有子进程不被父进程回收的情况，造成僵尸进程</span><br><span class="line">    &#x2F;&#x2F;    while ((pid &#x3D; waitpid(0, &amp;status, WNOHANG)) &gt; 0) &#123;    &#x2F;&#x2F; 应该改成循环</span><br><span class="line">        if (WIFEXITED(status))</span><br><span class="line">            printf(&quot;child %d exit %d\n&quot;, pid, WEXITSTATUS(status));</span><br><span class="line">        else if (WIFSIGNALED(status))</span><br><span class="line">            printf(&quot;child %d cancel signal %d\n&quot;, pid, WTERMSIG(status));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    int i;</span><br><span class="line">    &#x2F;&#x2F;阻塞SIGCHLD，防止父进程回调函数还没注册，子进程就终止。</span><br><span class="line">    sigset_t set;</span><br><span class="line">    sigemptyset(&amp;set);</span><br><span class="line">    sigaddset(&amp;set, SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;set, NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for (i&#x3D;0; i&lt;5; i++) &#123;</span><br><span class="line">        if ((pid &#x3D; fork()) &#x3D;&#x3D; 0)</span><br><span class="line">            break;</span><br><span class="line">        else if (pid &lt; 0)</span><br><span class="line">            sys_err(&quot;fork&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	if(5 &#x3D;&#x3D; i)</span><br><span class="line">	&#123;</span><br><span class="line">        &#x2F;&#x2F; 先设置捕捉, 再解除对SIGCHLD的阻塞</span><br><span class="line">        struct sigaction act;</span><br><span class="line"></span><br><span class="line">        act.sa_handler &#x3D; do_sig_child;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags &#x3D; 0;</span><br><span class="line">        sigaction(SIGCHLD, &amp;act, NULL);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 回调函数注册后解除阻塞</span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;set, NULL);</span><br><span class="line">        </span><br><span class="line">        while (1) &#123;</span><br><span class="line">            printf(&quot;Parent ID %d\n&quot;, getpid());</span><br><span class="line">            sleep(1);</span><br><span class="line">        &#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;child ID %d\n&quot;, getpid());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="守护进程-Daemon"><a href="#守护进程-Daemon" class="headerlink" title="守护进程(Daemon)"></a>守护进程(Daemon)</h1><p>守护进程是后台运行，独立于控制终端、不与用户直接交互且周期性执行某种任务或等待处理发生事件的进程。守护进程不受用户登陆和注销影响。<br>进程组是一组相关进程的集合，会话是一组相关进程组的集合，一个进程会有如下ID:PID、PPID、PGID(进程组ID)、SID(会话ID)。<br>当父进程创建子进程的时候，默认子进程与父进程属于同一进程组。进程组ID等于第一个进程ID</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 返回调用者的进程组ID</span><br><span class="line">pid_t getpgrp(void);    </span><br><span class="line">&#x2F;&#x2F; 返回指定进程的进程组ID</span><br><span class="line">pid_t getpgid(pid_t pid);   &#x2F;&#x2F; 成功：0；失败：-1，设置errno</span><br><span class="line">&#x2F;&#x2F; 改变进程默认所属的进程组,将pid对应的进程加入pgid对应的进程组</span><br><span class="line">int setpgid(pid_t pid, pid_t pgid); 	&#x2F;&#x2F; 成功：0；失败：-1，设置errno</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    if ((pid &#x3D; fork())&lt;0) &#123;</span><br><span class="line">        perror(&quot;fork&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125; else if (pid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        printf(&quot;child process PID is %d\n&quot;, getpid());</span><br><span class="line">        printf(&quot;Group ID of child is %d\n&quot;, getpgid(0));</span><br><span class="line">        printf(&quot;Session ID of child is %d\n&quot;, getsid(0));</span><br><span class="line"></span><br><span class="line">        sleep(5);</span><br><span class="line">        setsid();       &#x2F;&#x2F; 子进程非组长进程，故其成为新会话首进程，且成为组长进程。该进程组id即为会话进程</span><br><span class="line"></span><br><span class="line">        printf(&quot;Changed:\n&quot;);</span><br><span class="line">        printf(&quot;child process PID is %d\n&quot;, getpid());</span><br><span class="line">        printf(&quot;Group ID of child is %d\n&quot;, getpgid(0));</span><br><span class="line">        printf(&quot;Session ID of child is %d\n&quot;, getsid(0));</span><br><span class="line">        sleep(5);</span><br><span class="line"></span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在UNIX系统中，用户通过终端登录系统后得到一个Shell进程，这个终端成为Shell进程的控制终端（Controlling Terminal）.进程中，控制终端是保存在PCB中的信息，而fork会复制PCB中的信息，因此由Shell进程启动的其它进程的控制终端也是这个终端。默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。</p>
<ul>
<li>创建会话</li>
</ul>
<ol>
<li>调用进程不能是进程组组长。如果调用进程是进程组组长，则进程组组长会成为新进程组的组长，同时是新会话的会长。但是原进程组的其他成员<br>仍然在老的会话中，就会出现同一个进程组的进程分属于不同会话的情况。这破坏了进程组和会话之间的严格层次关系。</li>
<li>该进程成为一个新进程组的组长进程。</li>
<li>需有root权限(ubuntu不需要)</li>
<li>新会话丢弃原有的控制终端，该会话没有控制终端</li>
<li>建立新会话时，先调用fork, 父进程终止，子进程调用setsid</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取进程所属的会话ID</span><br><span class="line">pid_t getsid(pid_t pid); 成功：返回调用进程的会话ID；失败：-1，设置errno</span><br><span class="line">&#x2F;&#x2F; 创建一个会话，并以自己的ID设置进程组ID，同时也是新会话的ID</span><br><span class="line">pid_t setsid(void);  成功：返回调用进程的会话ID；失败：-1，设置errno</span><br></pre></td></tr></table></figure>
<ul>
<li>创建守护进程过程</li>
</ul>
<ol>
<li>创建子进程，父进程退出，所有工作在子进程中进行形式上脱离了控制终端</li>
<li>在子进程中创建新会话，setsid()函数，使子进程完全独立出来，脱离控制</li>
<li>改变当前目录为根目录，chdir()函数，防止占用可卸载的文件系统，也可以换成其它路径</li>
<li>重设文件权限掩码，umask()函数，防止继承的文件创建屏蔽字拒绝某些权限，增加守护进程灵活性</li>
<li>关闭文件描述符，继承的打开文件不会用到，浪费系统资源，无法卸载</li>
<li>开始执行守护进程核心工作</li>
<li>守护进程退出处理程序模型    </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line"></span><br><span class="line">void daemonize(void)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     *  成为一个新会话的首进程，失去控制终端</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if ((pid &#x3D; fork()) &lt; 0) &#123;</span><br><span class="line">        perror(&quot;fork&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125; else if (pid !&#x3D; 0) &#x2F;* parent *&#x2F;</span><br><span class="line">        exit(0);</span><br><span class="line">    setsid();</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 改变当前工作目录到&#x2F;目录下.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if (chdir(&quot;&#x2F;&quot;) &lt; 0) &#123;</span><br><span class="line">        perror(&quot;chdir&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* 设置umask为0 *&#x2F;</span><br><span class="line">    umask(0);</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 重定向0，1，2文件描述符到 &#x2F;dev&#x2F;null，因为已经失去控制终端，再操作0，1，2没有意义.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    close(0);</span><br><span class="line">    open(&quot;&#x2F;dev&#x2F;null&quot;, O_RDWR);	&#x2F;&#x2F; 保证0，1，2不会在守护进程open的时候被分配</span><br><span class="line">    dup2(0, 1);</span><br><span class="line">    dup2(0, 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    daemonize();</span><br><span class="line">    while(1);       &#x2F;* 在此循环中可以实现守护进程的核心工作 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h1><blockquote>
<p>如果某个系统支持两个或者多个动作（Action）同时存在，那么这个系统就是一个并发系统。如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个并行系统。并发系统与并行系统这两个定义之间的关键差异在于“存在”这个词。在并发程序中可以同时拥有两个或者多个线程。这意味着，如果程序在单核处理器上运行，那么这两个线程将交替地换入或者换出内存。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。我相信你已经能够得出结论——“并行”概念是“并发”概念的一个子集。也就是说，你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码。因此，凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。<br><a href="https://www.zhihu.com/question/33515481/answer/105348019" target="_blank" rel="noopener">作者链接</a></p>
<p>并发：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。<br>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。<br>并行（Parallel），当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。<br><a href="https://www.cnblogs.com/xc-chejj/p/10813692.html" target="_blank" rel="noopener">并行和并发的区别</a></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>并发是在一段时间内宏观上多个程序同时运行(宏观并行，微观串行)；并行是在某一时刻，真正有多个程序在运行。</p>
<p>并行和并发的区别：</p>
<p>并发，指的是多个事情，在同一时间段内同时发生了。<br>并行，指的是多个事情，在同一时间点上同时发生了。</p>
<p>并发的多个任务之间是互相抢占资源的。<br>并行的多个任务之间是不互相抢占资源的、</p>
<p>只有在多CPU或者一个CPU多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。</p>
<h1 id="链接地址"><a href="#链接地址" class="headerlink" title="链接地址"></a>链接地址</h1><p><a href="https://www.cnblogs.com/zengyiwen/p/5755191.html" target="_blank" rel="noopener">linux内核之进程的基本概念(进程，进程组，会话关系)</a><br><a href="https://blog.csdn.net/mijichui2153/article/details/81394387" target="_blank" rel="noopener">创建守护进程的步骤</a></p>

    </div>

    
    
    
        <div class="reward-container">
  <div>打赏，你怕了么(●ˇ∀ˇ●)</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="simonXi 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="simonXi 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/linux/" rel="tag"><i class="fa fa-tag"></i> linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/05/33-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90(%E4%B8%80)/" rel="prev" title="33-stl源码剖析(一)">
      <i class="fa fa-chevron-left"></i> 33-stl源码剖析(一)
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/02/35-linux-%E7%BA%BF%E7%A8%8B/" rel="next" title="35-linux-线程">
      35-linux-线程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80NzY2Ni8yNDE2NA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程"><span class="nav-number">2.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程状态"><span class="nav-number">2.1.</span> <span class="nav-text">进程状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程控制"><span class="nav-number">2.2.</span> <span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exce函数族"><span class="nav-number">2.2.1.</span> <span class="nav-text">exce函数族</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#孤儿进程和僵尸进程"><span class="nav-number">2.2.2.</span> <span class="nav-text">孤儿进程和僵尸进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程回收"><span class="nav-number">2.2.3.</span> <span class="nav-text">进程回收</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重定向dup和dup2"><span class="nav-number">2.3.</span> <span class="nav-text">重定向dup和dup2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程间通信-IPC"><span class="nav-number">3.</span> <span class="nav-text">进程间通信(IPC)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#文件方式"><span class="nav-number">3.1.</span> <span class="nav-text">文件方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管道方式-进程之间有血缘关系"><span class="nav-number">3.2.</span> <span class="nav-text">管道方式(进程之间有血缘关系)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fifo方式-进程之间无血缘关系"><span class="nav-number">3.3.</span> <span class="nav-text">fifo方式(进程之间无血缘关系)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存映射"><span class="nav-number">3.4.</span> <span class="nav-text">内存映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mmap父子间通信"><span class="nav-number">3.4.1.</span> <span class="nav-text">mmap父子间通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mmap无血缘关系通信"><span class="nav-number">3.4.2.</span> <span class="nav-text">mmap无血缘关系通信</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号"><span class="nav-number">3.5.</span> <span class="nav-text">信号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#信号集"><span class="nav-number">3.5.1.</span> <span class="nav-text">信号集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号捕捉"><span class="nav-number">3.5.2.</span> <span class="nav-text">信号捕捉</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#借助SIGCHLD信号回收子进程"><span class="nav-number">3.5.3.</span> <span class="nav-text">借助SIGCHLD信号回收子进程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#守护进程-Daemon"><span class="nav-number">4.</span> <span class="nav-text">守护进程(Daemon)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#并发和并行"><span class="nav-number">5.</span> <span class="nav-text">并发和并行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">5.1.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#链接地址"><span class="nav-number">6.</span> <span class="nav-text">链接地址</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="simonXi"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">simonXi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/simonXi-tech" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;simonXi-tech" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/simonforfuture" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;simonforfuture" rel="noopener" target="_blank">CSDN</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.bilibili.com/" title="https:&#x2F;&#x2F;www.bilibili.com&#x2F;" rel="noopener" target="_blank">Bilibili</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">simonXi</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">262k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:58</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
