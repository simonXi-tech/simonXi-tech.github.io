<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言">
<meta property="og:type" content="article">
<meta property="og:title" content="33-stl源码剖析(一)">
<meta property="og:url" content="http://yoursite.com/2020/03/05/33-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90(%E4%B8%80)/index.html">
<meta property="og:site_name" content="simonXi的技术博客">
<meta property="og:description" content="前言">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-03-05T06:28:11.000Z">
<meta property="article:modified_time" content="2020-07-04T04:22:53.344Z">
<meta property="article:author" content="simonXi">
<meta property="article:tag" content="cpp">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/03/05/33-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90(%E4%B8%80)/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>33-stl源码剖析(一) | simonXi的技术博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">simonXi的技术博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">13</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">13</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">37</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/simonXi-tech" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/05/33-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90(%E4%B8%80)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="simonXi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="simonXi的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          33-stl源码剖析(一)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-05 14:28:11" itemprop="dateCreated datePublished" datetime="2020-03-05T14:28:11+08:00">2020-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-04 12:22:53" itemprop="dateModified" datetime="2020-07-04T12:22:53+08:00">2020-07-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/" itemprop="url" rel="index"><span itemprop="name">cpp</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a>
<h1 id="STL模板"><a href="#STL模板" class="headerlink" title="STL模板"></a>STL模板</h1><p>STL(Standard Template Libray)标准模板库是惠普实验室开发的一系列软件的统称。STL从广义上将分为三类：algorithm(算法)、container(容器)和iterator(迭代器)。容器和算法通过迭代器可以进行无缝衔接。在C++标准中，STL被组织为下面的13个头文件：<algorithm>、<deque>、<functional>、<iterator>、<vector>、<list>、<map>、<memory>、<numeric>、<queue>、<set>、<stack> 和<utility>。</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p><font color="red">容器是用于存放数据的类模板</font>。可变长数组、链表、平衡二叉树等数据结构在STL中都被实现为容器。程序员使用容器时，即将容器类模板实例化为容器类，会指明容器中存放的元素是什么类型。容器中可以存放基本类型，也可以存放对象。对象或基本类型的变量被插入容器中，实际插入的是对象或变量的一个复制品。<br>STL中许多算法(即函数模板)，如排序、查找等算法，在执行过程中会对容器中的元素进行比较。这些算法在比较元素是否相等时通常用运算符进行，比较大小通常用 &lt; 运算符进行。因此，被放入容器的对象所属的类最好重载 == 和 &lt; 运算符，以使得 两个对象用 == 和 &lt; 进行比较是有定义的。</p>
<h3 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h3><p>顺序容器有以下三种：可变长动态数组 vector、双端队列 deque、双向链表 list。</p>
<p>它们之所以被称为顺序容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置（尾部、头部或中间某处）插入，元素就会位于什么位置。</p>
<ul>
<li>teacher.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Teacher   &#x2F;&#x2F; Teacher是类 类型</span><br><span class="line">&#123;</span><br><span class="line">    friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const Teacher&amp; obj);</span><br><span class="line">public:</span><br><span class="line">	Teacher(string name, int age, const char* p &#x3D; NULL);</span><br><span class="line">	Teacher(const Teacher&amp; obj);</span><br><span class="line">	Teacher&amp; operator&#x3D;(Teacher&amp; obj);</span><br><span class="line">	~Teacher();</span><br><span class="line"></span><br><span class="line">	char* getContent();</span><br><span class="line">	void setContent(const char* p);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	int age;</span><br><span class="line">	string name;</span><br><span class="line">	char* pContent;</span><br><span class="line">	int clen;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>teacher.cpp</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;teacher.h&quot;</span><br><span class="line"></span><br><span class="line">Teacher::Teacher()</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;name &#x3D; &quot;&quot;;</span><br><span class="line">    this-&gt;age &#x3D; -1;</span><br><span class="line">    this-&gt;pContent &#x3D; NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义中不设置默认参数</span><br><span class="line">Teacher::Teacher(string name, int age, const char* p)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;name &#x3D; name;</span><br><span class="line">	this-&gt;age &#x3D; age;</span><br><span class="line"></span><br><span class="line">    if (p &#x3D;&#x3D; NULL)</span><br><span class="line">		this-&gt;pContent &#x3D; NULL;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		clen &#x3D; strlen(p);</span><br><span class="line">		&#x2F;&#x2F; 堆中申请空间</span><br><span class="line">		this-&gt;pContent &#x3D; new char[clen + 1];</span><br><span class="line">		strcpy(this-&gt;pContent, p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Teacher::Teacher(const Teacher&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;name &#x3D; obj.name;</span><br><span class="line">	this-&gt;age &#x3D; obj.age;</span><br><span class="line"></span><br><span class="line">	if (obj.pContent &#x3D;&#x3D; NULL)</span><br><span class="line">		this-&gt;pContent &#x3D; NULL;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		clen &#x3D; strlen(obj.pContent);</span><br><span class="line">		&#x2F;&#x2F; 堆中申请空间</span><br><span class="line">		this-&gt;pContent &#x3D; new char[clen + 1];</span><br><span class="line">		strcpy(this-&gt;pContent, obj.pContent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;	cout &lt;&lt; &quot;Teacher:&quot; &lt;&lt; this-&gt;name &lt;&lt; &quot;的Teacher(const Teacher&amp; obj)拷贝构造函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Teacher&amp; Teacher::operator&#x3D;(Teacher&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;name &#x3D; obj.name;</span><br><span class="line">	this-&gt;age &#x3D; obj.age;</span><br><span class="line"></span><br><span class="line">    if (obj.pContent &#x3D;&#x3D; NULL)</span><br><span class="line">		this-&gt;pContent &#x3D; NULL;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		clen &#x3D; strlen(obj.pContent);</span><br><span class="line">		&#x2F;&#x2F; 堆中申请空间</span><br><span class="line">		this-&gt;pContent &#x3D; new char[clen + 1];</span><br><span class="line">		strcpy(this-&gt;pContent, obj.pContent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Teacher::~Teacher()</span><br><span class="line">&#123;</span><br><span class="line">    if(this-&gt;pContent !&#x3D; NULL)</span><br><span class="line">        delete[] this-&gt;pContent;    &#x2F;&#x2F; 析构动态分配的内存空间</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char* Teacher::getContent()</span><br><span class="line">&#123;</span><br><span class="line">    return this-&gt;pContent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Teacher::setContent(const char* p)</span><br><span class="line">&#123;</span><br><span class="line">    if (p &#x3D;&#x3D; NULL)</span><br><span class="line">		this-&gt;pContent &#x3D; NULL;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		clen &#x3D; strlen(p);</span><br><span class="line">		&#x2F;&#x2F; 堆中申请空间</span><br><span class="line">		this-&gt;pContent &#x3D; new char[clen + 1];</span><br><span class="line">		strcpy(this-&gt;pContent, p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; out, const Teacher&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; &quot;name&#x3D;&quot; &lt;&lt; obj.name &lt;&lt; &quot;,age&#x3D;&quot; &lt;&lt; obj.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>myVector.hpp</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;teacher.h&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 容器模板</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class MyVector</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    MyVector(int len&#x3D;2)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;len &#x3D; len;    &#x2F;&#x2F; 开辟默认空间</span><br><span class="line">        this-&gt;pSpace &#x3D; new T[len];</span><br><span class="line">        count &#x3D; -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyVector(const MyVector&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;len &#x3D; obj.len;</span><br><span class="line">        this-&gt;pSpace &#x3D; new T[this-&gt;len];</span><br><span class="line">        this-&gt;count &#x3D; obj.count;</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0; i&lt;obj.count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            this-&gt;pSpace[i] &#x3D; obj.pSpace[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void pushBack(T t)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        if(count &lt; this-&gt;len-1)</span><br><span class="line">        &#123;</span><br><span class="line">            pSpace[count] &#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            this-&gt;len +&#x3D; 10;</span><br><span class="line">            T* tmp &#x3D; new T[this-&gt;len];</span><br><span class="line"></span><br><span class="line">            for(int i&#x3D;0; i&lt;&#x3D;count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[i] &#x3D; pSpace[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            delete[] pSpace;</span><br><span class="line">            pSpace &#x3D; tmp;</span><br><span class="line"></span><br><span class="line">            pSpace[count] &#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~MyVector()</span><br><span class="line">    &#123;</span><br><span class="line">        if(pSpace !&#x3D; NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            delete[] pSpace;</span><br><span class="line">            pSpace &#x3D; NULL;</span><br><span class="line">            len &#x3D; 0;</span><br><span class="line">            count &#x3D; -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; operator[](int index)</span><br><span class="line">    &#123;</span><br><span class="line">        return pSpace[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyVector&amp; operator&#x3D;(const MyVector&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pSpace !&#x3D; NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            delete[] pSpace;</span><br><span class="line">            pSpace &#x3D; NULL;</span><br><span class="line">            len &#x3D; 0;</span><br><span class="line">            count &#x3D; -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        len &#x3D; obj.len;</span><br><span class="line">        pSpace &#x3D; new T[len];</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0; i&lt;len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pSpace[i] &#x3D; obj[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int size()</span><br><span class="line">    &#123;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int print()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;&#x3D;count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; pSpace[i] &lt;&lt; endl;  &#x2F;&#x2F; 类对象需要重载&lt;&lt;运算符</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T* pSpace;</span><br><span class="line">    int len;</span><br><span class="line">    int count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 容器类</span><br><span class="line">    MyVector&lt;int&gt; intVector;</span><br><span class="line">    intVector.pushBack(0);</span><br><span class="line">    intVector.pushBack(1);</span><br><span class="line">    intVector.pushBack(2);</span><br><span class="line">    intVector.pushBack(3);</span><br><span class="line"></span><br><span class="line">    intVector.print();</span><br><span class="line"></span><br><span class="line">    MyVector&lt;Teacher&gt; classVector;</span><br><span class="line">    Teacher t1(&quot;lucy&quot;, 25);</span><br><span class="line">    Teacher t2(&quot;bob&quot;, 26);</span><br><span class="line">    Teacher t3(&quot;selena&quot;, 27);</span><br><span class="line">    Teacher t4(&quot;tomas&quot;, 28);</span><br><span class="line"></span><br><span class="line">    classVector.pushBack(t1);</span><br><span class="line">    classVector.pushBack(t2);</span><br><span class="line">    classVector.pushBack(t3);</span><br><span class="line">    classVector.pushBack(t4);</span><br><span class="line">    classVector.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h3><p>关联容器有以下四种：set、multiset、map、multimap。关联容器内的元素是排序的。插入元素时，容器会按一定的排序规则将元素放到适当的位置上，因此插入元素时不能指定位置。</p>
<p>默认情况下，关联容器中的元素是从小到大排序（或按关键字从小到大排序）的，而且用&lt;运算符比较元素或关键字大小。因为是排好序的，所以关联容器在查找时具有非常好的性能。</p>
<p>除了以上两类容器外，STL 还在两类容器的基础上屏蔽一部分功能，突出或增加另一部分功能，实现了三种容器适配器：栈 stack、队列 queue、优先级队列 priority_queue。</p>
<p>容器都是类模板。它们实例化后就成为容器类。用容器类定义的对象称为容器对象。</p>
<p>所有容器都有以下两个成员函数：</p>
<ul>
<li>int size()：返回容器对象中元素的个数。</li>
<li>bool empty()：判断容器对象是否为空。</li>
</ul>
<p>顺序容器和关联容器还有以下成员函数：</p>
<ul>
<li>begin()：返回指向容器中第一个元素的迭代器。</li>
<li>end()：返回指向容器中最后一个元素后面的位置的迭代器。</li>
<li>rbegin()：返回容器中倒数第一个元素的反向迭代器。</li>
<li>rend()：返回容器中倒数最后一个元素之后的反向迭代器。</li>
<li>erase(…)：从容器中删除一个或几个元素。该函数参数较复杂，此处省略。</li>
<li>clear()：从容器中删除所有元素。</li>
</ul>
<p>如果一个容器是空的，则 begin() 和 end() 的返回值相等，rbegin() 和 rend() 的返回值也相等。</p>
<p>顺序容器还有以下常用成员函数：</p>
<ul>
<li>front()：返回容器中第一个元素的引用。</li>
<li>back()：返回容器中最后一个元素的引用。</li>
<li>push_back()：在容器末尾增加新元素。</li>
<li>pop_back()：删除容器末尾的元素。</li>
<li>insert(…)：插入一个或多个元素。该函数参数较复杂，此处省略。</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器在STL中用来将算法和容器联系起来，几乎STL提供的所有算法都是通过迭代器存取元素序列进行工作的，<strong>每一个容器都定义了其本身所专有的迭代器</strong>，用以存取容器中的元素。</p>
<h1 id="容器模板"><a href="#容器模板" class="headerlink" title="容器模板"></a>容器模板</h1><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>C语言：字符串的结尾带有’\0’，strlen(s)的结果不包括’\0’，sizeof(s)的结果包括’\0’<br>C++：string，s.size()的结果不包括’\s’。sizeof(s)是string类型的默认分配的内存空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"># 默认构造函数：</span><br><span class="line">string();	   </span><br><span class="line"># 拷贝构造函数：</span><br><span class="line">string(const string &amp;str);	&#x2F;&#x2F; 构造一个与str一样的string</span><br><span class="line"># 带参数的构造函数</span><br><span class="line">string(const char *s);      &#x2F;&#x2F; 用字符串s初始化</span><br><span class="line">string(int n,char c);       &#x2F;&#x2F; 用n个字符c初始化</span><br><span class="line"></span><br><span class="line">const char &amp;operator[] (int n) const;</span><br><span class="line">const char &amp;at(int n) const;</span><br><span class="line">char &amp;operator[] (int n);</span><br><span class="line">char &amp;at(int n);</span><br><span class="line"></span><br><span class="line">const char *c_str() const;   &#x2F;&#x2F; 返回一个以&#39;\0&#39;结尾的字符串的首地址</span><br><span class="line">int copy(char *s, int n, int pos&#x3D;0) const;     &#x2F;&#x2F; 把当前串中以pos开始的n个字符拷贝到以s为起始的字符数组中，返回实际的拷贝的数目</span><br><span class="line">int length() const;     &#x2F;&#x2F; 返回当前字符串的长度。长度不包括字符串结尾的&#39;\0&#39;。</span><br><span class="line">bool empty() const;     &#x2F;&#x2F; 当前字符串是否为空</span><br><span class="line"></span><br><span class="line">string &amp;operator&#x3D;(const string &amp;s); &#x2F;&#x2F; 把字符串s赋给当前的字符串</span><br><span class="line">string &amp;assign(const char *s);      &#x2F;&#x2F; 把字符串s赋给当前的字符串</span><br><span class="line">string &amp;assign(const char *s, int n); &#x2F;&#x2F; 把字符串s的前n个字符赋给当前的字符串</span><br><span class="line">string &amp;assign(const string &amp;s);    &#x2F;&#x2F; 把字符串s赋给当前字符串</span><br><span class="line">string &amp;assign(int n, char c);       &#x2F;&#x2F; 用n个字符c赋给当前字符串</span><br><span class="line">string &amp;assign(const string &amp;s,int start, int n);  &#x2F;&#x2F; 把字符串s中从start开始的n个字符赋给当前字符串</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string &amp;operator+&#x3D;(const string &amp;s);    &#x2F;&#x2F; 把字符串s连接到当前字符串结尾</span><br><span class="line">string &amp;operator+&#x3D;(const char *s);      &#x2F;&#x2F; 把字符串s连接到当前字符串结尾</span><br><span class="line">string &amp;append(const char *s);          &#x2F;&#x2F; 把字符串s连接到当前字符串结尾</span><br><span class="line">string &amp;append(const char *s,int n);    &#x2F;&#x2F; 把字符串s的前n个字符连接到当前字符串结尾</span><br><span class="line">string &amp;append(const string &amp;s);        &#x2F;&#x2F; 同operator+&#x3D;()</span><br><span class="line">string &amp;append(const string &amp;s,int pos, int n); &#x2F;&#x2F; 把字符串s中从pos开始的n个字符连接到当前字符串结尾</span><br><span class="line">string &amp;append(int n, char c);          &#x2F;&#x2F; 在当前字符串结尾添加n个字符c</span><br><span class="line">string substr(int pos&#x3D;0, int n&#x3D;npos) const;    &#x2F;&#x2F; 返回由pos开始的n个字符组成的子字符串</span><br><span class="line"></span><br><span class="line">int compare(const string &amp;s) const;     &#x2F;&#x2F; 与字符串s比较</span><br><span class="line">int compare(const char *s) const;       &#x2F;&#x2F; 与字符串s比较</span><br><span class="line">&#x2F;&#x2F; compare函数在&gt;时返回 1，&lt;时返回 -1，&#x3D;&#x3D;时返回 0。比较区分大小写，比较时参考字典序，排越前面的越小。大写的A比小写的a小。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int find(char c, int pos&#x3D;0) const;              &#x2F;&#x2F; 从pos开始查找字符c在当前字符串的位置 </span><br><span class="line">int find(const char *s, int pos&#x3D;0) const;       &#x2F;&#x2F; 从pos开始查找字符串s在当前字符串的位置</span><br><span class="line">int find(const string &amp;s, int pos&#x3D;0) const;     &#x2F;&#x2F; 从pos开始查找字符串s在当前字符串中的位置 </span><br><span class="line">&#x2F;&#x2F; find函数如果查找不到，就返回-1</span><br><span class="line">int rfind(char c, int pos&#x3D;npos) const;          &#x2F;&#x2F; 从pos开始从后向前查找字符c在当前字符串中的位置 </span><br><span class="line">int rfind(const char *s, int pos&#x3D;npos) const;</span><br><span class="line">int rfind(const string &amp;s, int pos&#x3D;npos) const;</span><br><span class="line">&#x2F;&#x2F;rfind是反向查找的意思，如果查找不到， 返回-1</span><br><span class="line"></span><br><span class="line"># 替换</span><br><span class="line">string &amp;replace(int pos, int n, const char *s); &#x2F;&#x2F; 删除从pos开始的n个字符，然后在pos处插入串s</span><br><span class="line">string &amp;replace(int pos, int n, const string &amp;s);  &#x2F;&#x2F; 删除从pos开始的n个字符，然后在pos处插入串s</span><br><span class="line">void swap(string &amp;s2);                          &#x2F;&#x2F; 交换当前字符串与s2的值</span><br><span class="line"></span><br><span class="line">string &amp;insert(int pos, const char *s);</span><br><span class="line">string &amp;insert(int pos, const string &amp;s);</span><br><span class="line">&#x2F;&#x2F; 前两个函数在pos位置插入字符串s</span><br><span class="line">string &amp;insert(int pos, int n, char c);     &#x2F;&#x2F; 在pos位置 插入n个字符c</span><br><span class="line">string &amp;erase(int pos&#x3D;0, int n&#x3D;npos);       &#x2F;&#x2F; 删除pos开始的n个字符，返回修改后的字符串</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string to_string (int val);</span><br><span class="line">string to_string (long val);</span><br><span class="line">string to_string (long long val);</span><br><span class="line">string to_string (unsigned val);</span><br><span class="line">string to_string (unsigned long val);</span><br><span class="line">string to_string (unsigned long long val);</span><br><span class="line">string to_string (float val);</span><br><span class="line">string to_string (double val);</span><br><span class="line">string to_string (long double val);</span><br></pre></td></tr></table></figure>
<h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><p>头文件：<code>#include &lt;vector&gt;</code>。vector是可变长的动态数组，支持随机访问迭代器。vector容器中，用一个动态分配的数组来存放元素。动态分配的存储空间一般都大于存放元素所需的空间。例如，哪怕容器中只有一个元素，也会分配 32 个元素的存储空间。这样做的好处是，在尾部添加一个新元素时不必重新分配空间，直接将新元素写入适当位置即可。在这种情况下，添加新元素的时间也是常数。</p>
<p>但是，如果不断添加新元素，多出来的空间就会用完，此时再添加新元素，就不得不重新分配内存空间，把原有内容复制过去后再添加新的元素。碰到这种情况，添加新元素所花的时间就不是常数，而是和数组中的元素个数成正比。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">vector();       &#x2F;&#x2F; 容器初始化为空</span><br><span class="line">vector(int n);  &#x2F;&#x2F; 将容器初始化为有n个元素，初始值为0</span><br><span class="line">vector(int n, const T&amp; val);   &#x2F;&#x2F; 假定元素的类型是T,此构造函数将容器初始化为有n个元素，每个元素的值都是val</span><br><span class="line">vector(iterator begin, iterator end);   &#x2F;&#x2F; begin和end是其他容器的迭代器(或指针)。将本vector容器的内容变成与其他容器上的区间[begin, end)一致。</span><br><span class="line">vector(const vector&amp; obj);  &#x2F;&#x2F; 拷贝构造</span><br><span class="line"></span><br><span class="line">int size();   &#x2F;&#x2F; 返回容器中元素个数</span><br><span class="line">bool empty();     &#x2F;&#x2F; 判断容器是否为空</span><br><span class="line">void push_back(const T&amp; val); &#x2F;&#x2F; 将val添加到容器末尾</span><br><span class="line">void pop_back();  &#x2F;&#x2F; 删除容器末尾的元素</span><br><span class="line">T&amp; front();     &#x2F;&#x2F; 返回容器中第一个元素的引用</span><br><span class="line">T&amp; back();      &#x2F;&#x2F; 返回容器中最后一个元素的引用</span><br><span class="line"></span><br><span class="line">T&amp; at(index);   &#x2F;&#x2F; 返回索引index所指的数据 越界抛异常</span><br><span class="line">vector[index];      &#x2F;&#x2F; 返回索引index所指的数据 越界报错</span><br><span class="line"></span><br><span class="line">assign(begin, end); &#x2F;&#x2F; 将[begin, end)区间的数据拷贝赋值给本身</span><br><span class="line">assign(n, elem);    &#x2F;&#x2F; 将n个elem拷贝赋值给本身</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; vector转string</span><br><span class="line">vector&lt;int&gt; vec &#x3D; &#123;1, 2, 3, 4&#125;;</span><br><span class="line">string str;</span><br><span class="line">str.assign(vec.begin(), vec.end());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; string 转vector</span><br><span class="line">string str &#x3D; &quot;1234&quot;;</span><br><span class="line">vector vec(str.begin(), str.end());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void swap( vector &lt;T&gt; &amp; v); 	&#x2F;&#x2F; 将容器自身的内容和另一个同类型的容器 v 互换</span><br><span class="line">resize(num);        &#x2F;&#x2F; 重新指定容器的长度为num。若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line">resize(num, elem);  &#x2F;&#x2F; 重新指定容器的长度为num。若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line"></span><br><span class="line">iterator insert(iterator i, const T &amp; val); 	&#x2F;&#x2F; 将 val 插入迭代器 i 指向的位置，返回 i</span><br><span class="line">iterator insert( iterator i, iterator first, iterator last); 	&#x2F;&#x2F; 将其他容器上的区间 [first, last) 中的元素插入迭代器 i 指向的位置</span><br><span class="line">iterator erase(iterator i) ;	&#x2F;&#x2F; 删除迭代器 i 指向的元素，返回值是被删元素后面的元素的迭代器</span><br><span class="line">iterator erase(iterator first, iterator last); 	&#x2F;&#x2F; 删除容器中的区间 [first, last)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 正向遍历</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void printVector(const vector&lt;T&gt;&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">    typename vector&lt;T&gt;::const_iterator it;</span><br><span class="line">    for(it&#x3D;v.begin(); it!&#x3D;v.end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 反向遍历</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void printReverseVector(const vector&lt;T&gt;&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">    typename vector&lt;T&gt;::const_reverse_iterator it;</span><br><span class="line">    for(it&#x3D;v.rbegin(); it!&#x3D;v.rend(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    int a[5] &#x3D; &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">    vector&lt;int&gt; vec1(a, a+5); &#x2F;&#x2F; vector(iterator first, iterator last);</span><br><span class="line">    printVector&lt;int&gt;(vec1);   &#x2F;&#x2F; 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; vec2(10, -1);   &#x2F;&#x2F; -1 -1 -1 -1 -1 -1 -1 -1 -1 -1</span><br><span class="line">    printVector(vec2);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将vec1 [begin, end)区间中的数据拷贝赋值给本身</span><br><span class="line">    vec2.assign(vec1.begin(), vec1.begin()+3);  &#x2F;&#x2F; 1  2 3</span><br><span class="line">    printVector(vec2);</span><br><span class="line"></span><br><span class="line">    vec2.assign(8, 3);  &#x2F;&#x2F; 3 3 3 3 3 3 3 3</span><br><span class="line">    printVector(vec2);</span><br><span class="line"></span><br><span class="line">    vec2.swap(vec1);    &#x2F;&#x2F; 1 2 3 4 5</span><br><span class="line">    printVector(vec2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; vec2.front() &lt;&lt; endl;   &#x2F;&#x2F; 1</span><br><span class="line">    cout &lt;&lt; vec2.back() &lt;&lt; endl;    &#x2F;&#x2F; 5</span><br><span class="line"></span><br><span class="line">    vec2.front() &#x3D; -1;</span><br><span class="line">    vec2.back() &#x3D; -1;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取头部元素</span><br><span class="line">    cout &lt;&lt; vec2.front() &lt;&lt; endl;   &#x2F;&#x2F; -1</span><br><span class="line">    &#x2F;&#x2F; 获取尾部元素</span><br><span class="line">    cout &lt;&lt; vec2.back() &lt;&lt; endl;    &#x2F;&#x2F; -1</span><br><span class="line"></span><br><span class="line">    vec2.pop_back();</span><br><span class="line">    printVector(vec2);              &#x2F;&#x2F; -1 2 3 4</span><br><span class="line">    printReverseVector(vec2);       &#x2F;&#x2F; 4 3 2 -1</span><br><span class="line"></span><br><span class="line">    vec2.push_back(20);</span><br><span class="line">    printVector(vec2);              &#x2F;&#x2F; -1 2 3 4 20</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 在vec2.begin()+1处插入元素33</span><br><span class="line">    vec2.insert(vec2.begin()+1, 33);</span><br><span class="line">    printVector(vec2);              &#x2F;&#x2F; -1 33 2 3 4 20</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 删除[begin, end)的元素</span><br><span class="line">    vec2.erase(vec2.begin(), vec2.begin()+1);</span><br><span class="line">    printVector(vec2);              &#x2F;&#x2F; 33 2 3 4 20</span><br><span class="line">    cout &lt;&lt; vec2.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 33 2 3 4 20 0 0 0 0 0</span><br><span class="line">    vec2.resize(10);         &#x2F;&#x2F; 超出部分填充0</span><br><span class="line">    printVector(vec2);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 33 2 3 4 20 0 0 0</span><br><span class="line">    vec2.resize(8);          &#x2F;&#x2F; 容器变短,删除元素</span><br><span class="line">    printVector(vec2);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 33 2 3 4 20 0 -1 -1 -1 -1</span><br><span class="line">    vec2.resize(10, -1);    &#x2F;&#x2F; 超出部分填充-1</span><br><span class="line">    printVector(vec2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h2><p>头文件：<code>#include &lt;stack&gt;</code>。栈容器，栈是一种后进先出的元素序列，访问和删除都只能对栈顶元素进行，并且元素也只能被添加到栈顶。栈内元素不能访问。如果一定要访问栈内元素，只能将其上方的元素全部从栈中删除，使之变成栈顶元素才可以。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stack.push(element);  &#x2F;&#x2F; 压栈</span><br><span class="line">stack.pop();          &#x2F;&#x2F; 出栈</span><br><span class="line">stack.top();          &#x2F;&#x2F; 获取栈顶元素</span><br><span class="line">stack.empty();        &#x2F;&#x2F; 判断堆栈是否为空</span><br><span class="line">stack.size();         &#x2F;&#x2F; 返回堆栈大小</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">	stack&lt;int&gt; s;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 入栈</span><br><span class="line">	for (int i&#x3D;0; i&lt;10; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		s.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;size&#x3D;&quot; &lt;&lt; s.size() &lt;&lt; endl;    &#x2F;&#x2F; 返回栈的大小</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 出栈</span><br><span class="line">	while ( !s.empty() )    &#x2F;&#x2F; 判断栈是否为空</span><br><span class="line">	&#123;</span><br><span class="line">		int tmp &#x3D; s.top();  &#x2F;&#x2F; 获取栈顶元素</span><br><span class="line">		cout &lt;&lt;  tmp &lt;&lt; &quot; &quot;;</span><br><span class="line">		s.pop();            &#x2F;&#x2F; 弹出栈顶元素</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Deque容器"><a href="#Deque容器" class="headerlink" title="Deque容器"></a>Deque容器</h2><p>deque是双端数组，可以随机存取元素。deque头部和尾部添加或移除元素都非常快速。但是在中部安插元素或移除元素比较费时。<code>#include &lt;deque&gt;</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">deque.push_back(elem);	&#x2F;&#x2F; 在容器尾部添加一个数据</span><br><span class="line">deque.push_front(elem);	&#x2F;&#x2F; 在容器头部插入一个数据</span><br><span class="line">deque.pop_back();    	&#x2F;&#x2F; 删除容器最后一个数据</span><br><span class="line">deque.pop_front();		&#x2F;&#x2F; 删除容器第一个数据</span><br><span class="line"></span><br><span class="line">deque.at(idx);      &#x2F;&#x2F; 返回索引idx所指的数据，如果idx越界，抛出out_of_range</span><br><span class="line">deque[idx];         &#x2F;&#x2F; 返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错</span><br><span class="line">deque.front();      &#x2F;&#x2F; 返回第一个数据</span><br><span class="line">deque.back();       &#x2F;&#x2F; 返回最后一个数据</span><br><span class="line"></span><br><span class="line">deque.begin();      &#x2F;&#x2F; 返回容器中第一个元素的迭代器。</span><br><span class="line">deque.end();        &#x2F;&#x2F; 返回容器中最后一个元素之后的迭代器。</span><br><span class="line">deque.rbegin();     &#x2F;&#x2F; 返回容器中倒数第一个元素的迭代器。</span><br><span class="line">deque.rend();       &#x2F;&#x2F; 返回容器中倒数最后一个元素之后的迭代器。</span><br><span class="line"></span><br><span class="line">deque(begin, end);      &#x2F;&#x2F; 构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间</span><br><span class="line">deque(n,elem);          &#x2F;&#x2F; 构造函数将n个elem拷贝给本身。</span><br><span class="line">deque(const deque &amp;deq);  &#x2F;&#x2F; 拷贝构造函数。</span><br><span class="line"></span><br><span class="line">deque.assign(beg,end);  &#x2F;&#x2F; 将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</span><br><span class="line">deque.assign(n,elem);   &#x2F;&#x2F; 将n个elem拷贝赋值给本身。</span><br><span class="line">deque&amp; operator&#x3D;(const deque &amp;deq);	    &#x2F;&#x2F; 重载等号操作符 </span><br><span class="line">deque.swap(deq);        &#x2F;&#x2F; 将vec与本身的元素互换</span><br><span class="line"></span><br><span class="line">deque.size();	        &#x2F;&#x2F; 返回容器中元素的个数</span><br><span class="line">deque.empty();	        &#x2F;&#x2F; 判断容器是否为空</span><br><span class="line">deque.resize(num);      &#x2F;&#x2F; 重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line">deque.resize(num, elem);  &#x2F;&#x2F; 重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line"></span><br><span class="line">deque.insert(pos,elem);     &#x2F;&#x2F; 在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span><br><span class="line">deque.insert(pos,n,elem);   &#x2F;&#x2F; 在pos位置插入n个elem数据，无返回值。</span><br><span class="line">deque.insert(pos,begin,end);  &#x2F;&#x2F; 在pos位置插入[begin,end)区间的数据，无返回值。</span><br><span class="line"></span><br><span class="line">deque.clear();	            &#x2F;&#x2F; 移除容器的所有数据</span><br><span class="line">deque.erase(beg,end);       &#x2F;&#x2F; 删除[beg,end)区间的数据，返回下一个数据的位置</span><br><span class="line">deque.erase(pos);           &#x2F;&#x2F; 删除pos位置的数据，返回下一个数据的位置</span><br></pre></td></tr></table></figure>
<h2 id="Queue容器"><a href="#Queue容器" class="headerlink" title="Queue容器"></a>Queue容器</h2><h1 id="include-。Queue是一种先进先出的队列容器"><a href="#include-。Queue是一种先进先出的队列容器" class="headerlink" title="include 。Queue是一种先进先出的队列容器"></a>include <queue>。Queue是一种先进先出的队列容器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">queue.push(element);  &#x2F;&#x2F; 入队</span><br><span class="line">queue.pop();          &#x2F;&#x2F; 出队</span><br><span class="line">queue.empty();        &#x2F;&#x2F; 判断队列是否为空</span><br><span class="line">queue.size();         &#x2F;&#x2F; 返回队列大小</span><br><span class="line">queue.front();        &#x2F;&#x2F; 返回队首元素</span><br><span class="line">queue.back();         &#x2F;&#x2F; 返回队尾元素</span><br><span class="line"></span><br><span class="line">queue(const queue &amp;que);		        &#x2F;&#x2F; 拷贝构造函数</span><br><span class="line">queue&amp; operator&#x3D;(const queue &amp;que);	    &#x2F;&#x2F; 重载等号操作符</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 入栈</span><br><span class="line">	for (int i&#x3D;0; i&lt;10; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		q.push(i);  &#x2F;&#x2F; 向队尾添加元素</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;size&#x3D;&quot; &lt;&lt; q.size() &lt;&lt; endl;    &#x2F;&#x2F; 返回队列的大小</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 出栈</span><br><span class="line">	while ( !q.empty() )    &#x2F;&#x2F; 判断队列是否为空</span><br><span class="line">	&#123;</span><br><span class="line">		int first &#x3D; q.front();  &#x2F;&#x2F; 返回第一个元素</span><br><span class="line">		cout &lt;&lt;  first &lt;&lt; &quot; &quot;;</span><br><span class="line">		q.pop();                &#x2F;&#x2F; 弹出队头元素</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p>priority_queue是优先级队列，默认是最大值优先级队列。#include <queue></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">priority_queue.empty()</span><br><span class="line">priority_queue.size()</span><br><span class="line">priority_queue.top()</span><br><span class="line">priority_queue.pop()</span><br><span class="line">priority_queue.push(item)</span><br><span class="line"></span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; p1;    &#x2F;&#x2F; 最大值优先级队列</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; p2;  &#x2F;&#x2F; 最小值优先级队列</span><br></pre></td></tr></table></figure>
<h2 id="set容器"><a href="#set容器" class="headerlink" title="set容器"></a>set容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">set.insert(elem);       &#x2F;&#x2F; 在容器中插入元素。</span><br><span class="line">set.begin();            &#x2F;&#x2F; 返回容器中第一个数据的迭代器。</span><br><span class="line">set.end();              &#x2F;&#x2F; 返回容器中最后一个数据之后的迭代器。</span><br><span class="line">set.rbegin();           &#x2F;&#x2F; 返回容器中倒数第一个元素的迭代器。</span><br><span class="line">set.rend();             &#x2F;&#x2F; 返回容器中倒数最后一个元素的后面的迭代器。</span><br><span class="line"></span><br><span class="line">set&lt; int, less&lt;int&gt; &gt;  setIntA;      &#x2F;&#x2F; 该容器是按升序方式排列元素 et&lt;int&gt; 相当于 set&lt;int,less&lt;int&gt;&gt;。</span><br><span class="line">set&lt; int, greater&lt;int&gt; &gt; setIntB;    &#x2F;&#x2F; 该容器是按降序方式排列元素</span><br><span class="line"></span><br><span class="line">set&lt;T&gt; s &#x3D; &#123;&#125;;</span><br><span class="line">set(begin, end);                    &#x2F;&#x2F; 构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间</span><br><span class="line">set(const set &amp;st);		            &#x2F;&#x2F; 拷贝构造函数</span><br><span class="line">set&amp; operator&#x3D;(const set &amp;st);	    &#x2F;&#x2F; 重载等号操作符</span><br><span class="line">set.swap(st);				        &#x2F;&#x2F; 交换两个集合容器</span><br><span class="line"></span><br><span class="line">set.size();	                        &#x2F;&#x2F; 返回容器中元素的数目</span><br><span class="line">set.empty();                        &#x2F;&#x2F; 判断容器是否为空</span><br><span class="line"></span><br><span class="line">set.clear();		                &#x2F;&#x2F; 清除所有元素</span><br><span class="line">set.erase(pos);	                    &#x2F;&#x2F; 删除pos迭代器所指的元素，返回下一个元素的迭代器。</span><br><span class="line">set.erase(beg,end);	                &#x2F;&#x2F; 删除区间[beg,end)的所有元素，返回下一个元素的迭代器。</span><br><span class="line">set.erase(elem);                    &#x2F;&#x2F; 删除容器中值为elem的元素。</span><br><span class="line"></span><br><span class="line">set.find(elem);                     &#x2F;&#x2F; 查找elem元素，返回指向elem元素的迭代器</span><br><span class="line">set.count(elem);                    &#x2F;&#x2F; 返回容器中值为elem的元素个数。对set来说，要么是0，要么是1。对multiset来说，值可能大于1</span><br><span class="line">set.lower_bound(elem);              &#x2F;&#x2F; 返回第一个&gt;&#x3D;elem元素的迭代器</span><br><span class="line">set.upper_bound(elem);	            &#x2F;&#x2F; 返回第一个&gt;elem元素的迭代器</span><br><span class="line">set.equal_range(elem);		        &#x2F;&#x2F; 返回容器中与elem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)</span><br><span class="line"></span><br><span class="line">pair&lt;T1,T2&gt;存放的两个值的类型，可以不一样，如T1为int，T2为float。T1,T2也可以是自定义类型。</span><br><span class="line">pair.first是pair里面的第一个值，是T1类型。</span><br><span class="line">pair.second是pair里面的第二个值，是T2类型。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lower_bound(begin, end， val);        &#x2F;&#x2F; 返回第一个&gt;&#x3D;elem元素的迭代器</span><br><span class="line">upper_bound(begin, end, val);         &#x2F;&#x2F; 返回第一个&gt;elem元素的迭代器</span><br><span class="line">auto bounds &#x3D; equal_range(begin, end, val); &#x2F;&#x2F; 返回容器中与elem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)</span><br></pre></td></tr></table></figure>
<h2 id="map容器"><a href="#map容器" class="headerlink" title="map容器"></a>map容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">map.insert(...);    &#x2F;&#x2F; 往容器插入元素，返回pair&lt;iterator,bool&gt;</span><br><span class="line"># 在map中插入元素的三种方式，假设map&lt;int, string&gt; mapStu;</span><br><span class="line"># 1. 通过pair的方式插入对象</span><br><span class="line">mapStu.insert( pair&lt;int,string&gt;(3,&quot;lana&quot;) );</span><br><span class="line"># 2. 通过pair的方式插入对象</span><br><span class="line">mapStu.insert( make_pair(3, “lana”) );</span><br><span class="line"># 3. 通过value_type的方式插入对象</span><br><span class="line">mapStu.insert(  map&lt;int,string&gt;::value_type( 3,&quot;lana&quot;)  );</span><br><span class="line"># 4. 通过数组的方式插入值</span><br><span class="line">mapStu[3] &#x3D; “lana&quot;;</span><br><span class="line"></span><br><span class="line"># 前三种方法，采用的是insert()方法，该方法返回值为pair&lt;iterator,bool&gt; </span><br><span class="line"># 第四种方法非常直观，但存在一个性能的问题。插入3时，先在mapStu中查找主键为3的项，若没发现，则将一个键为3，值为初始化值的对组插入到mapStu中，然后再将值修改成“小刘”。若发现已存在3这个键，则修改这个键对应的value。</span><br><span class="line"></span><br><span class="line">string strName &#x3D; mapStu[2];   &#x2F;&#x2F; 取操作或插入操作只有当mapStu存在2这个键时才是正确的取操作，否则会自动插入一个实例，键为2，值为初始化值(0)。</span><br><span class="line"></span><br><span class="line">for (map&lt;int,string&gt;::iterator it&#x3D;mapA.begin(); it!&#x3D;mapA.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">    pair&lt;int, string&gt; pr &#x3D; *it;</span><br><span class="line">    int iKey &#x3D; pr.first;</span><br><span class="line">    string strValue &#x3D; pr.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map&lt; T1, T2, less&lt;T1&gt; &gt;  mapA;      &#x2F;&#x2F; 该容器是按键的升序方式排列元素。未指定函数对象，默认采用less&lt;T1&gt;函数对象。</span><br><span class="line">map&lt; T1, T2, greater&lt;T1&gt; &gt; mapB;    &#x2F;&#x2F; 该容器是按键的降序方式排列元素。</span><br><span class="line"># less&lt;T1&gt;与greater&lt;T1&gt;  可以替换成其它的函数对象functor。</span><br><span class="line"># 可编写自定义函数对象以进行自定义类型的比较，使用方法与set构造时所用的函数对象一样。</span><br><span class="line">map.begin();        &#x2F;&#x2F; 返回容器中第一个数据的迭代器。</span><br><span class="line">map.end();          &#x2F;&#x2F; 返回容器中最后一个数据之后的迭代器。</span><br><span class="line">map.rbegin();       &#x2F;&#x2F; 返回容器中倒数第一个元素的迭代器。</span><br><span class="line">map.rend();         &#x2F;&#x2F; 返回容器中倒数最后一个元素的后面的迭代器。</span><br><span class="line"></span><br><span class="line">map(const map &amp;mp);		        &#x2F;&#x2F; 拷贝构造函数</span><br><span class="line">map&amp; operator&#x3D;(const map &amp;mp);	&#x2F;&#x2F; 重载等号操作符</span><br><span class="line">map.swap(mp);				    &#x2F;&#x2F; 交换两个集合容器</span><br><span class="line"></span><br><span class="line">map.size();	        &#x2F;&#x2F; 返回容器中元素的数目</span><br><span class="line">map.empty();        &#x2F;&#x2F; 判断容器是否为空</span><br><span class="line"></span><br><span class="line">map.clear();		&#x2F;&#x2F; 删除所有元素</span><br><span class="line">map.erase(pos);	    &#x2F;&#x2F; 删除pos迭代器所指的元素，返回下一个元素的迭代器</span><br><span class="line">map.erase(beg,end);	&#x2F;&#x2F; 删除区间[beg,end)的所有元素，返回下一个元素的迭代器    mapA.erase(mapA.begin());</span><br><span class="line">map.erase(keyElem); &#x2F;&#x2F; 删除容器中key为keyElem的对组 mapA.erase(5);  </span><br><span class="line"></span><br><span class="line">map.find(key);      &#x2F;&#x2F; 查找键key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回map.end();</span><br><span class="line">map.count(keyElem); &#x2F;&#x2F; 返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</span><br><span class="line">map.lower_bound(keyElem);       &#x2F;&#x2F; 返回第一个key&gt;&#x3D;keyElem元素的迭代器。</span><br><span class="line">map.upper_bound(keyElem);	    &#x2F;&#x2F; 返回第一个key&gt;keyElem元素的迭代器。</span><br><span class="line"></span><br><span class="line">map.equal_range(keyElem);		&#x2F;&#x2F; 返回容器中key与keyElem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[begin,end)。</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="http://c.biancheng.net/view/331.html" target="_blank" rel="noopener">C++容器（STL容器）</a></p>

    </div>

    
    
    
        <div class="reward-container">
  <div>打赏，你怕了么(●ˇ∀ˇ●)</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="simonXi 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="simonXi 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/cpp/" rel="tag"><i class="fa fa-tag"></i> cpp</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/03/32-linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="prev" title="32-linux-网络编程">
      <i class="fa fa-chevron-left"></i> 32-linux-网络编程
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/29/34-linux-%E8%BF%9B%E7%A8%8B/" rel="next" title="34-linux-进程">
      34-linux-进程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80NzY2Ni8yNDE2NA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STL模板"><span class="nav-number">2.</span> <span class="nav-text">STL模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#容器"><span class="nav-number">2.1.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序容器"><span class="nav-number">2.1.1.</span> <span class="nav-text">顺序容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关联式容器"><span class="nav-number">2.1.2.</span> <span class="nav-text">关联式容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器"><span class="nav-number">2.2.</span> <span class="nav-text">迭代器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#容器模板"><span class="nav-number">3.</span> <span class="nav-text">容器模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#string"><span class="nav-number">3.1.</span> <span class="nav-text">string</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector容器"><span class="nav-number">3.2.</span> <span class="nav-text">vector容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stack容器"><span class="nav-number">3.3.</span> <span class="nav-text">stack容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Deque容器"><span class="nav-number">3.4.</span> <span class="nav-text">Deque容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Queue容器"><span class="nav-number">3.5.</span> <span class="nav-text">Queue容器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#include-。Queue是一种先进先出的队列容器"><span class="nav-number">4.</span> <span class="nav-text">include 。Queue是一种先进先出的队列容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#priority-queue"><span class="nav-number">4.1.</span> <span class="nav-text">priority_queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set容器"><span class="nav-number">4.2.</span> <span class="nav-text">set容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map容器"><span class="nav-number">4.3.</span> <span class="nav-text">map容器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="simonXi"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">simonXi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/simonXi-tech" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;simonXi-tech" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/simonforfuture" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;simonforfuture" rel="noopener" target="_blank">CSDN</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.bilibili.com/" title="https:&#x2F;&#x2F;www.bilibili.com&#x2F;" rel="noopener" target="_blank">Bilibili</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">simonXi</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">262k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:58</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
