<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>00-Hexo个人博客搭建指南</title>
    <url>/2019/11/20/00-Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一直想要做个人博客！博主有过一年的工作经历，那段时间在csdn上写了很多博客，但越来越有一种受制于人的感觉。2019考研博主侥幸某985上岸，算是人生的一个分界点。2019.11.20，博主心血来潮，在b站上搜索如何搭建个人博客的视频，找到如下内容：<a href="https://www.bilibili.com/video/av62400697" target="_blank" rel="noopener">一步一步教你如何在Windows10上完成hexo博客搭建和yilia主题使用</a>。于是有了此博客的诞生，衷心感谢无私奉献的大神们！今后将利用这个博客，分享自己的所学所感，请大家不吝赐教！<a id="more"></a></p>
<h1 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h1><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="下载和安装git"><a href="#下载和安装git" class="headerlink" title="下载和安装git"></a>下载和安装git</h3><ol>
<li><a href="https://git-scm.com/" target="_blank" rel="noopener">git下载地址</a>，git的安装一路next即可。</li>
<li>安装完成后，桌面鼠标右键，此时会有Git GUI Here和Git Bash Here两个程序。  </li>
<li>在cmd.exe中输入<code>git --version</code>检查是否安装成功。博主的输出为：git version 2.24.0.windows.2<br><img src="/images/00-Hexo个人博客搭建指南/00_git下载.jpg" alt="“00_git下载”"><br><img src="/images/00-Hexo个人博客搭建指南/01_git安装完成.jpg" alt="&quot;01_git安装完成&quot;">  </li>
</ol>
<h3 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h3><ol>
<li>注册github账号。</li>
<li>鼠标右击点击Git Bash Here<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 配置用户名 username使用自己注册的用户名</span><br><span class="line">git config --global user.name &quot;username&quot; </span><br><span class="line"># 配置邮箱 username@email.com使用自己注册的邮箱</span><br><span class="line">git config --global user.email &quot;username@email.com&quot;</span><br></pre></td></tr></table></figure></li>
<li>配置ssh<br>在视频中，对ssh进行了配置。博主发现，不配置也可以，所以就偷了懒。</li>
</ol>
<h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><h3 id="下载和安装Node-js"><a href="#下载和安装Node-js" class="headerlink" title="下载和安装Node.js"></a>下载和安装Node.js</h3><ol>
<li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs下载地址</a>，nodejs的安装一路next即可。</li>
<li>nodejs安装完成后，可以在Git Bash中输入<code>node -v</code>查看是否安装成功。<br><img src="/images/00-Hexo个人博客搭建指南/02_nodejs下载.jpg" alt="“02_nodejs下载”"><br><img src="/images/00-Hexo个人博客搭建指南/03_检查nodejs是否安装成功.jpg" alt="“03_检查nodejs是否安装成功”"></li>
<li>npm介绍<br>npm是随同nodejs一起安装的包管理工具，能解决nodejs代码部署上的很多问题，常见的使用场景有以下几种：<ul>
<li>允许用户从npm服务器下载别人编写的第三方包到本地使用。</li>
<li>允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。<br>由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入<code>npm -v</code>来测试是否成功安装。<a href="https://www.runoob.com/nodejs/nodejs-npm.html" target="_blank" rel="noopener">npm使用介绍</a></li>
</ul>
</li>
</ol>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="静态博客"><a href="#静态博客" class="headerlink" title="静态博客"></a>静态博客</h3><p>Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo 文档</a>  </p>
<p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。<br>为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件</p>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 检查npm版本，确定npm是否安装成功</span><br><span class="line">npm -v</span><br><span class="line">2. 安装cnpm,通过淘宝镜像源</span><br><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">3. 检查cnpm是否安装成功</span><br><span class="line">cnpm -v</span><br><span class="line">4. 安装hexo</span><br><span class="line">cnpm install -g hexo-cli</span><br><span class="line">5. 检查hexo是否安装成功</span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<p><img src="/images/00-Hexo个人博客搭建指南/04_检查npm版本.jpg" alt="“04_检查npm版本”"><br><img src="/images/00-Hexo个人博客搭建指南/05_检查cnpm版本.jpg" alt="“05_检查cnpm版本”"><br><img src="/images/00-Hexo个人博客搭建指南/06_检查hexo版本.jpg" alt="“06_检查hexo版本”"></p>
<h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><ol>
<li>在本地建立 站点 文件夹</li>
<li>在Git Bash中使用linux命令操作<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入d盘</span><br><span class="line">cd d:</span><br><span class="line"># 建立站点文件夹</span><br><span class="line">mkdir Blog</span><br><span class="line">cd Blog&#x2F;</span><br><span class="line"># 初始化hexo</span><br><span class="line">hexo init</span><br><span class="line"># 显示Blog文件夹下内容</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure></li>
<li>启动hexo，通过<code>http://localhost:4000</code>可以访问默认为<code>landscape</code>主题的博客<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 清除缓存文件 (db.json) 和已生成的静态文件 (public)。</span><br><span class="line">hexo clean</span><br><span class="line"># 生成静态文件</span><br><span class="line">hexo g</span><br><span class="line"># 文章的 Slug，作为新文章的文件名和发布后的 URL 默认端口4000</span><br><span class="line">hexo s</span><br><span class="line"># -p 重设端口</span><br><span class="line">hexo s -p 5000</span><br></pre></td></tr></table></figure>
<img src="/images/00-Hexo个人博客搭建指南/07_启动hexo本地预览.jpg" alt="“07_启动hexo本地预览”"></li>
</ol>
<h2 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h2><p>Visual Studio Code是一个跨平台源代码编辑器。<a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener">Visual Studio Code下载地址</a>。下载完成后默认安装即可。<br><img src="/images/00-Hexo个人博客搭建指南/08_vscode下载.jpg" alt="“08_vscode下载”"><br><a href="https://jingyan.baidu.com/article/6d704a136d72ae28db51ca27.html" target="_blank" rel="noopener">Visual Studio code下载、安装、汉化教程</a>  </p>
<h1 id="将网站部署到Github上"><a href="#将网站部署到Github上" class="headerlink" title="将网站部署到Github上"></a>将网站部署到Github上</h1><ol>
<li>注册github账号</li>
<li>在Git Bash中，进入Blog目录下安装 hexo 部署插件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure></li>
<li>在github中按照<strong>自己的昵称+.github.io</strong>方式建立一个repository<br><img src="/images/00-Hexo个人博客搭建指南/09_新建github.io仓库.jpg" alt="“09_新建github.io仓库”"><br>创建完成后，会生成一个链接，复制该链接。<br><img src="/images/00-Hexo个人博客搭建指南/10_复制链接.jpg" alt="“10_复制链接”"></li>
<li>使用VSCode打开<code>Blog/_config.yml</code>文件，修改如下：<br><img src="/images/00-Hexo个人博客搭建指南/11_修改根目录_config.yml.jpg" alt="“11_修改根目录_config.yml”"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">## repo：将项目部署到https:&#x2F;&#x2F;github.com&#x2F;simonXi-tech&#x2F;simonXi-tech.github.io.git</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;simonXi-tech&#x2F;simonXi-tech.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li>
<li>使用<code>hexo d</code>进行部署，即可将本地博客推送到github上</li>
<li>欢迎访问我的博客<a href="https://simonxi-tech.github.io/" target="_blank" rel="noopener">https://simonxi-tech.github.io/</a></li>
</ol>
<h1 id="更换博客主题"><a href="#更换博客主题" class="headerlink" title="更换博客主题"></a>更换博客主题</h1><p>博主没有采用<a href="https://www.bilibili.com/video/av62400697" target="_blank" rel="noopener">一步一步教你如何在Windows10上完成hexo博客搭建和yilia主题使用</a>中的 yilia 主题，而是选择 NexT 主题。<br><a href="https://hexothe.me/" target="_blank" rel="noopener">排名前 10 的 Hexo 主题</a></p>
<h2 id="Next主题"><a href="#Next主题" class="headerlink" title="Next主题"></a>Next主题</h2><h3 id="下载Next主题"><a href="#下载Next主题" class="headerlink" title="下载Next主题"></a>下载Next主题</h3><ol>
<li>从 github 上克隆 next 主题<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># themes&#x2F;next表示克隆next后的本地位置 Blog&#x2F;themes&#x2F;next</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next.git themes&#x2F;next</span><br></pre></td></tr></table></figure></li>
<li><p>打开 站点配置文件 文件，修改主题<br><img src="/images/00-Hexo个人博客搭建指南/12_修改主题.jpg" alt="“12_修改主题”"></p>
</li>
<li><p>重新加载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 清除缓存文件 (db.json) 和已生成的静态文件 (public)。</span><br><span class="line"># 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</span><br><span class="line">hexo clean  </span><br><span class="line"># 生成静态文件 默认在站点目录下新建 public&#x2F;，最终这些内容可以通过浏览器访问</span><br><span class="line">hexo g    </span><br><span class="line"># 文件生成后立即部署网站          </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="使用-MarkDown-编写博客"><a href="#使用-MarkDown-编写博客" class="headerlink" title="使用 MarkDown 编写博客"></a>使用 MarkDown 编写博客</h1><p>编写 MarkDown 使用 Visual Studio Code。MarkDown 的语法参考<a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">Markdown 教程</a></p>
<h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>新建一篇文章。如果没有设置<code>layout</code>的话，默认使用<code>_config.yml</code>中的<code>default_layout</code>参数代替。如果标题包含空格的话，请使用引号括起来。<br>比如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;post title with whitespace&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="插入本地图片"><a href="#插入本地图片" class="headerlink" title="插入本地图片"></a>插入本地图片</h2><p>由于初步使用hexo，所以博主选择最简单最笨的方法插入本地图片。  </p>
<ol>
<li>在<code>source</code>目录下新建<code>images</code>文件夹，在写博客之前，先到<code>source/image/</code>目录下新建对应该博客的文件夹。比如新建<strong>00_Hexo个人博客搭建指南</strong>文件夹</li>
<li>将本地的图片复制到<strong>00_Hexo个人博客搭建指南</strong>文件夹</li>
<li>使用<code>![“图片描述”](/source/00-Hexo个人博客搭建指南/xx.jpg)</code>导入图片</li>
<li>注意:这样导入本地图片，在ViSual Studio Code中是不显示的。通过<code>http://localhost:4000</code>访问可以查看效果</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>花费了一天时间，认真梳理了hexo博客搭建的过程。虽然写博客耗时，但是有一种满足感。不重复造轮子！</p>
]]></content>
      <categories>
        <category>博客搭建</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>01-Next主题优化一</title>
    <url>/2019/11/21/01-Next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E4%B8%80/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://theme-next.org/docs/getting-started/" target="_blank" rel="noopener">NexT入门英文原站</a><br><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT入门中文网站</a> </p>
<p> 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p>
<p>为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。<a id="more"></a></p>
<h1 id="主题设定"><a href="#主题设定" class="headerlink" title="主题设定"></a>主题设定</h1><p>scheme 是 NexT 支持的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以在 Scheme 之间共用。目前NexT支持四种 Scheme ，他们是：</p>
<ul>
<li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li>
<li>Mist - Muse的紧凑版本，整洁有序的单栏外观</li>
<li>Pisces - 双栏 Scheme，小家碧玉似的清新</li>
<li>Gemini - 类似 Pisces，栏块相间，浮动梦幻般的享受</li>
</ul>
<p>Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有四行 scheme 的配置，将你需用启用的 scheme 前面注释#去除即可。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Scheme Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure></p>
<h1 id="选择语言"><a href="#选择语言" class="headerlink" title="选择语言"></a>选择语言</h1><p>编辑 站点配置文件， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 配置为中文</span><br><span class="line">language: zh-CN</span><br><span class="line"># 配置为英文</span><br><span class="line">language: en</span><br></pre></td></tr></table></figure></p>
<h1 id="配置菜单项"><a href="#配置菜单项" class="headerlink" title="配置菜单项"></a>配置菜单项</h1><p>菜单配置包括三个部分，格式：<code>Key: /link/ || icon</code>。Key 是菜单项的名字(比如：主页，归档等)；link 是指向站点内部相对url的目标链接；icon 是 Font Awesome 图标。<br>NexT默认提供 主页 和 归档两个菜单项。要自定义菜单项，请在 主题配置文件 中编辑以下内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Menu Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Usage: &#96;Key: &#x2F;link&#x2F; || icon&#96;</span><br><span class="line"># Key 是菜单项的名字。如果该项的翻译版本可得，则使用翻译版本；否则使用原名。Key 区分大小写。</span><br><span class="line"># 在&#96;||&#96;定界符之前的值是目标链接，在&#96;||&#96;定界符之后的是Font Awesome图标</span><br><span class="line"># 当在子目录中运行站点时(例如yoursite.com&#x2F;blog)，从链接值中删除前边的斜杠 (&#x2F;archives -&gt; archives).</span><br><span class="line"># 外链需要使用 http:&#x2F;&#x2F; 或者 https:&#x2F;&#x2F;</span><br><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  #about: &#x2F;about&#x2F; || user</span><br><span class="line">  tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || heartbeat</span><br></pre></td></tr></table></figure></p>
<p>NexT还支持层次结构的动态子菜单。在 主题配置文件 的菜单部分添加子菜单项，如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">  Docs:</span><br><span class="line">    default: &#x2F;docs&#x2F; || book</span><br><span class="line">    Third Party Services:</span><br><span class="line">      default: &#x2F;third-party-services&#x2F; || plug</span><br><span class="line">      Algolia Search: &#x2F;algolia-search&#x2F; || adn</span><br></pre></td></tr></table></figure><br>默认情况下，NexT显示不带badges的菜单项icons。badges的作用就是统计菜单项下的元素个数。比如有多少个tags，有多少个archives。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Enable &#x2F; Disable menu icons &#x2F; item badges.</span><br><span class="line">menu_settings:</span><br><span class="line">  icons: true</span><br><span class="line">  badges: true</span><br></pre></td></tr></table></figure><br><img src="/images/01-Next主题优化一/00_icons&amp;badges.jpg" alt="&quot;00_icons&amp;badges&quot;"></p>
<h1 id="配置Favicons"><a href="#配置Favicons" class="headerlink" title="配置Favicons"></a>配置Favicons</h1><p>在默认情况下，Hexo 站点使用 hexo-site/themes/next/source/images/ 目录中NexT favicons。对应不同的设备favicons有不同的大小。你可以用你自己favicons来代替它们。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Site Information Settings</span><br><span class="line"># See: https:&#x2F;&#x2F;theme-next.org&#x2F;docs&#x2F;getting-started&#x2F;</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">favicon:</span><br><span class="line">  small: &#x2F;images&#x2F;favicon-16x16-next.png</span><br><span class="line">  medium: &#x2F;images&#x2F;favicon-32x32-next.png</span><br><span class="line">  apple_touch_icon: &#x2F;images&#x2F;apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: &#x2F;images&#x2F;logo.svg</span><br><span class="line">  #android_manifest: &#x2F;images&#x2F;manifest.json</span><br><span class="line">  #ms_browserconfig: &#x2F;images&#x2F;browserconfig.xml</span><br></pre></td></tr></table></figure>
<p>favicons的意思如下图：<br><img src="/images/01-Next主题优化一/01_favicons.jpg" alt="&quot;01_favicons&quot;"><br>我们可以找自己喜欢的icons，然后覆盖 hexo-site/themes/next/source/images/ 目录下的 apple-touch-icon-next.png 即可修改为自己的favicon。</p>
<h1 id="配置Avatar-头像"><a href="#配置Avatar-头像" class="headerlink" title="配置Avatar(头像)"></a>配置Avatar(头像)</h1><p>在默认情况下，NexT不在侧栏显示头像。你可以通过 主题配置文件下 avatar 字段进行配置。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # 将自己的头像复制到hexo-site&#x2F;themes&#x2F;next&#x2F;source&#x2F;images&#x2F;</span><br><span class="line">  # 可以设置为动图</span><br><span class="line">  url: &#x2F;images&#x2F;avatar.png</span><br><span class="line">  # true:头像为圆形 false:头像为方形</span><br><span class="line">  rounded: true</span><br><span class="line">  # true:鼠标悬停在头像上时，头像旋转   false:头像不旋转</span><br><span class="line">  rotated: false</span><br></pre></td></tr></table></figure></p>
<h1 id="配置作者和描述"><a href="#配置作者和描述" class="headerlink" title="配置作者和描述"></a>配置作者和描述</h1><p>编辑 站点配置文件， 设置 author 为你的昵称；设置 description 字段为你的站点描述。站点描述可以是你喜欢的一句签名:) </p>
<pre><code># Site
title: simonXi-tech的博客
subtitle: &#39;&#39;
description: &#39;&#39;
keywords:
author: simonXi
language: zh-CN
timezone: &#39;&#39;
</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看着自己的博客一点一点建起来，真的超开心！</p>
]]></content>
      <categories>
        <category>博客搭建</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>02-Next主题优化二</title>
    <url>/2019/11/22/02-Next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客主要参考NexT官网的教程，百度的时候找到很多关于Next主题的博客。但是很多内容都是过时的，原站虽然是英文的，但是耐心看还是很容易理解的。<br><a id="more"></a></p>
<h1 id="配置分类和标签"><a href="#配置分类和标签" class="headerlink" title="配置分类和标签"></a>配置分类和标签</h1><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo文档</a><br>NexT在<a href="https://theme-next.org/docs/theme-settings/custom-pages" target="_blank" rel="noopener">Custom Pages</a>中详细解释了定制化页面的操作。</p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>您可以执行下列命令来创建一篇新文章或者新的页面。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><br>您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。<br>Hexo 有三种默认布局：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径。</p>
<ul>
<li>默认post布局保存在 source/_posts 目录下；</li>
<li>page布局保存在 source目录下；</li>
<li>draft布局保存在 source/drafts目录下。</li>
</ul>
<h3 id="创建标签和分类页面"><a href="#创建标签和分类页面" class="headerlink" title="创建标签和分类页面"></a>创建标签和分类页面</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建 categories 页面；创建路径 source</span><br><span class="line">hexo new page categories</span><br><span class="line"># 创建 tags 页面；创建路径 source</span><br><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p><img src="/images/02-Next主题优化二/00_创建标签页和分类页.jpg" alt="&quot;00_创建标签页和分类页&quot;"></p>
<ul>
<li>编辑 /source/categories/index.md<br><img src="/images/02-Next主题优化二/01_修改categories的index.md.jpg" alt="&quot;01_修改categories的index.md&quot;"></li>
<li>编辑 /source/tags/index.md<br><img src="/images/02-Next主题优化二/02_修改tags的index.md.jpg" alt="&quot;02_修改tags的index.md&quot;"></li>
</ul>
<h2 id="Fron-matter"><a href="#Fron-matter" class="headerlink" title="Fron-matter"></a><a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener">Fron-matter</a></h2><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，常用的参数如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line">date: 建立日期</span><br><span class="line">tags: 标签</span><br><span class="line">categories：分类</span><br><span class="line">comments：开启文章的评论功能</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<h3 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h3><p>只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 02-Next主题优化二</span><br><span class="line">date: 2019-11-22 11:54:04</span><br><span class="line">tags: </span><br><span class="line">  - hexo</span><br><span class="line">categories: </span><br><span class="line">  - 博客搭建</span><br><span class="line">  - hexo</span><br><span class="line">comments:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>在每篇文章中，我们通过 tags 和 categories 指定对应的 标签 和 分类 即可。<br><img src="/images/02-Next主题优化二/03_设置标签和分类.jpg" alt="&quot;03_设置标签和分类&quot;"><br>Hexo 不支持指定多个同级分类。如上所示，标题为 02-Next主题优化二 的文章属于父分类 博客搭建 下子分类 hexo 中的文章。<br>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure></p>
<p>此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类。</p>
<h1 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h1><p><a href="https://theme-next.org/docs/theme-settings/" target="_blank" rel="noopener">Next主题配置英文原文</a><br><a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">NexT主题配置中文翻译</a> </p>
<h2 id="Theme-Settings"><a href="#Theme-Settings" class="headerlink" title="Theme Settings"></a><a href="https://theme-next.org/docs/theme-settings/" target="_blank" rel="noopener">Theme Settings</a></h2><h3 id="代码块高亮"><a href="#代码块高亮" class="headerlink" title="代码块高亮"></a>代码块高亮</h3><p>NexT 目前提供8种代码高亮主题。打开 主题配置文件，找到 codeblock。codeblock.copy_button使用设置复制代码快捷键。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  # Code Highlight theme</span><br><span class="line">  # Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span><br><span class="line">  # See: https:&#x2F;&#x2F;github.com&#x2F;chriskempson&#x2F;tomorrow-theme</span><br><span class="line">  highlight_theme: solarized</span><br><span class="line">  # Add copy button on codeblock</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    # Show text copy result.</span><br><span class="line">    show_result: true</span><br><span class="line">    # Available values: default | flat | mac</span><br><span class="line">    style:</span><br></pre></td></tr></table></figure></p>
<h3 id="阅读进度"><a href="#阅读进度" class="headerlink" title="阅读进度"></a>阅读进度</h3><p>NexT支持页面滚动阅读进度指示器，默认开启。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Reading progress bar</span><br><span class="line">reading_progress:</span><br><span class="line">  enable: true</span><br><span class="line">  # Available values: top | bottom</span><br><span class="line">  position: top</span><br><span class="line">  color: &quot;#37c6c0&quot;</span><br><span class="line">  height: 3px</span><br></pre></td></tr></table></figure></p>
<h3 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h3><p>书签是一个插件，允许用户保存他们的阅读进度。用户可以单击书签图标(如🔖)来保存滚动的位置。当他们下次访问你的博客时，他们可以自动恢复每个页面的最后滚动位置。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bookmark:</span><br><span class="line">  enable: true</span><br><span class="line">  # Customize the color of the bookmark.</span><br><span class="line">  color: &quot;#222&quot;</span><br><span class="line">  # If auto, save the reading progress when closing the page or clicking the bookmark-icon.</span><br><span class="line">  # If manual, only save it by clicking the bookmark-icon.</span><br><span class="line">  save: auto</span><br></pre></td></tr></table></figure></p>
<h3 id="Github-Banner"><a href="#Github-Banner" class="headerlink" title="Github Banner"></a>Github Banner</h3><p>NexT提供在右上角提供 <code>Follow me on GitHub</code> banner。打开 主题配置文件，找到 github_banner：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># permalink是全路径的github链接</span><br><span class="line"># &#96;Follow me on GitHub&#96; banner in the top-right corner.</span><br><span class="line">github_banner:</span><br><span class="line">  enable: true</span><br><span class="line">  permalink: https:&#x2F;&#x2F;github.com&#x2F;simonXi-tech</span><br><span class="line">  title: Follow me on GitHub</span><br></pre></td></tr></table></figure></p>
<h2 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a><a href="https://theme-next.org/docs/theme-settings/footer" target="_blank" rel="noopener">Footer</a></h2><h3 id="站点起始时间"><a href="#站点起始时间" class="headerlink" title="站点起始时间"></a>站点起始时间</h3><p>默认情况下，NexT在页脚显示当前年份，比如<code>©2018</code>。您可以通过编辑 主题配置文件 中的<code>since</code>部分中的值，将其配置为显示时间间隔，如<code>©2015 - 2018</code>。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  since: 2015</span><br></pre></td></tr></table></figure></p>
<h3 id="站点Footer图标"><a href="#站点Footer图标" class="headerlink" title="站点Footer图标"></a>站点Footer图标</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  icon:</span><br><span class="line">    # Icon name in Font Awesome. See: https:&#x2F;&#x2F;fontawesome.com&#x2F;v4.7.0&#x2F;icons&#x2F;</span><br><span class="line">    # &#96;heart&#96; is recommended with animation in red (#ff0000).</span><br><span class="line">    name: user</span><br><span class="line">    # If you want to animate the icon, set it to true.</span><br><span class="line">    animated: false</span><br><span class="line">    # Change the color of icon, using Hex Code.</span><br><span class="line">    color: &quot;#808080&quot;</span><br></pre></td></tr></table></figure>
<h3 id="站点版权名称"><a href="#站点版权名称" class="headerlink" title="站点版权名称"></a>站点版权名称</h3><p>默认情况下，NexT显示 站点配置文件 中的作者名称。您可以通过编辑 主题配置文件 中的版权部分中的值来配置它。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  # If not defined, &#96;author&#96; from Hexo &#96;_config.yml&#96; will be used.</span><br><span class="line">  copyright:</span><br></pre></td></tr></table></figure></p>
<h3 id="站点平台信息"><a href="#站点平台信息" class="headerlink" title="站点平台信息"></a>站点平台信息</h3><p>默认情况下，NexT 显示 Hexo 和 Theme &amp; scheme 信息，比如 <code>Powered by Hexo v4.0.0 | Theme – NexT.Gemini v7.5.0</code>。您可以通过在 主题配置文件 中的 <code>powered</code> 和 <code>theme</code> 部分编辑值来配置它。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  powered:</span><br><span class="line">    # Hexo link (Powered by Hexo).</span><br><span class="line">    enable: false</span><br><span class="line">    # Version info of Hexo after Hexo link (vX.X.X).</span><br><span class="line">    version: false</span><br><span class="line"></span><br><span class="line">  theme:</span><br><span class="line">    # Theme &amp; scheme info link (Theme - NexT.scheme).</span><br><span class="line">    enable: false</span><br><span class="line">    # Version info of NexT after scheme info (vX.X.X).</span><br><span class="line">    version: false</span><br></pre></td></tr></table></figure></p>
<h3 id="站点备案信息"><a href="#站点备案信息" class="headerlink" title="站点备案信息"></a>站点备案信息</h3><p>中国用户建立自己的站点需要备案信息。默认这些信息是不显示的。您可以通过在 主题配置文件 中的 <code>beian</code> 部分编辑值来配置它。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  # Beian ICP and gongan information for Chinese users. See: http:&#x2F;&#x2F;www.beian.miit.gov.cn, http:&#x2F;&#x2F;www.beian.gov.cn</span><br><span class="line">  beian:</span><br><span class="line">    enable: false</span><br><span class="line">    icp:</span><br><span class="line">    # The digit in the num of gongan beian.</span><br><span class="line">    gongan_id:</span><br><span class="line">    # The full num of gongan beian.</span><br><span class="line">    gongan_num:</span><br><span class="line">    # The icon for gongan beian. See: http:&#x2F;&#x2F;www.beian.gov.cn&#x2F;portal&#x2F;download</span><br><span class="line">    gongan_icon_url:</span><br></pre></td></tr></table></figure></p>
<h2 id="Sidebar"><a href="#Sidebar" class="headerlink" title="Sidebar"></a><a href="https://theme-next.org/docs/theme-settings/sidebar" target="_blank" rel="noopener">Sidebar</a></h2><h3 id="侧边栏风格"><a href="#侧边栏风格" class="headerlink" title="侧边栏风格"></a>侧边栏风格</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">  # 侧边栏位置</span><br><span class="line">  position: left</span><br><span class="line">  #position: right</span><br></pre></td></tr></table></figure>
<h3 id="侧边栏社交链接"><a href="#侧边栏社交链接" class="headerlink" title="侧边栏社交链接"></a>侧边栏社交链接</h3><p>打开 主题配置文件，找到 social。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># icons_only只显示图标</span><br><span class="line">social_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  icons_only: false</span><br><span class="line">  transition: false</span><br><span class="line"></span><br><span class="line"># Social Links</span><br><span class="line"># Usage: &#96;Key: permalink || icon&#96;</span><br><span class="line"># Key is the link label showing to end users.</span><br><span class="line"># Value before &#96;||&#96; delimiter is the target permalink, value after &#96;||&#96; delimiter is the name of Font Awesome icon.</span><br><span class="line">social:</span><br><span class="line">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;simonXi-tech || github</span><br><span class="line">  #E-Mail: mailto:yourname@gmail.com || envelope</span><br><span class="line">  #Weibo: https:&#x2F;&#x2F;weibo.com&#x2F;yourname || weibo</span><br><span class="line">  #Google: https:&#x2F;&#x2F;plus.google.com&#x2F;yourname || google</span><br><span class="line">  #Twitter: https:&#x2F;&#x2F;twitter.com&#x2F;yourname || twitter</span><br><span class="line">  #FB Page: https:&#x2F;&#x2F;www.facebook.com&#x2F;yourname || facebook</span><br><span class="line">  #VK Group: https:&#x2F;&#x2F;vk.com&#x2F;yourname || vk</span><br><span class="line">  #StackOverflow: https:&#x2F;&#x2F;stackoverflow.com&#x2F;yourname || stack-overflow</span><br><span class="line">  #YouTube: https:&#x2F;&#x2F;youtube.com&#x2F;yourname || youtube</span><br><span class="line">  #Instagram: https:&#x2F;&#x2F;instagram.com&#x2F;yourname || instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || skype</span><br></pre></td></tr></table></figure></p>
<h3 id="侧边栏友情链接"><a href="#侧边栏友情链接" class="headerlink" title="侧边栏友情链接"></a>侧边栏友情链接</h3><p>打开 主题配置文件，找到 links。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Blog rolls</span><br><span class="line">links_settings:</span><br><span class="line">  icon: link</span><br><span class="line">  title: 友情链接</span><br><span class="line">  # Available values: block | inline</span><br><span class="line">  layout: inline</span><br><span class="line"></span><br><span class="line">links:</span><br><span class="line">  CSDN: https:&#x2F;&#x2F;blog.csdn.net&#x2F;simonforfuture</span><br><span class="line">  Bilibili: https:&#x2F;&#x2F;www.bilibili.com&#x2F;</span><br></pre></td></tr></table></figure></p>
<h3 id="侧边栏TOC"><a href="#侧边栏TOC" class="headerlink" title="侧边栏TOC"></a>侧边栏TOC</h3><p>默认情况下，NexT显示侧边栏中的目录(Table Of Contents)。您可以在主题配置文件设置<code>toc.enable</code>为false取消。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toc:</span><br><span class="line">  enable: true</span><br><span class="line">  # Automatically add list number to toc.</span><br><span class="line">  number: true</span><br><span class="line">  # If true, all words will placed on next lines if header width longer then sidebar width.</span><br><span class="line">  wrap: false</span><br><span class="line">  # If true, all level of TOC in a post will be displayed, rather than the activated part of it.</span><br><span class="line">  expand_all: false</span><br><span class="line">  # Maximum heading depth of generated toc.</span><br><span class="line">  max_depth: 6</span><br></pre></td></tr></table></figure></p>
<h3 id="回到顶部"><a href="#回到顶部" class="headerlink" title="回到顶部"></a>回到顶部</h3><p>显示文章浏览的百分比，回到顶部。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # Back to top in sidebar.</span><br><span class="line">  sidebar: true</span><br><span class="line">  # Scroll percent label in b2t button.</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure></p>
<h2 id="Posts"><a href="#Posts" class="headerlink" title="Posts"></a><a href="https://theme-next.org/docs/theme-settings/posts" target="_blank" rel="noopener">Posts</a></h2><h3 id="序言文本"><a href="#序言文本" class="headerlink" title="序言文本"></a>序言文本</h3><p>通常需要在主页中显示文章的某些部分，然后提供完整文章的链接。接下来给出3种方法来控制文章在主页中显示的方式。换句话说，您可以使用以下方法来显示文章摘要和Read More按钮。</p>
<p>Hexo推荐使用<code>&lt;!-- more --&gt;</code>手动设置显示文章的某些部分。</p>
<h2 id="文章计数"><a href="#文章计数" class="headerlink" title="文章计数"></a>文章计数</h2><p>NexT 的字数统计和阅读时长功能需要使用第三方插件 <a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">hexo-symbols-count-time</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time</span><br><span class="line"># 站点配置文件添加</span><br><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">  total_symbols: true</span><br><span class="line">  total_time: true  </span><br><span class="line"># 主题配置文件修改</span><br><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-symbols-count-time</span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  item_text_post: true</span><br><span class="line">  item_text_total: false</span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure></p>
<h3 id="标签图标"><a href="#标签图标" class="headerlink" title="标签图标"></a>标签图标</h3><p>默认情况下，文章底部标签有 #。打开 主题配置文件，找到tag_icon。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tag_icon: true</span><br></pre></td></tr></table></figure></p>
<h3 id="开启打赏"><a href="#开启打赏" class="headerlink" title="开启打赏"></a>开启打赏</h3><p>越来越多的平台（微信公众平台，微博，简书，百度打赏等）支持打赏功能，付费阅读时代越来越近，特此增加了打赏功能，支持微信打赏、支付宝打赏和比特币。</p>
<ol>
<li>获取您的微信支付/支付宝/比特币付款码，并将其放入 next 主题目录下的 source/images 中，或将其上传到图像云中，获取HTTP地址</li>
<li>在 主题配置文件 中填入 微信 和 支付宝 收款二维码图片地址 即可开启该功能。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Reward (Donate)</span><br><span class="line"># Front-matter variable (unsupport animation).</span><br><span class="line">reward_settings:</span><br><span class="line">  # If true, reward will be displayed in every article by default.</span><br><span class="line">  enable: true</span><br><span class="line">  animation: true</span><br><span class="line">  comment: 打赏，你怕了么(●ˇ∀ˇ●)</span><br><span class="line"></span><br><span class="line">reward:</span><br><span class="line">  wechatpay: &#x2F;images&#x2F;wechatpay.jpg</span><br><span class="line">  alipay: &#x2F;images&#x2F;alipay.jpg</span><br><span class="line">  #bitcoin: &#x2F;images&#x2F;bitcoin.png</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Advanced-Settings"><a href="#Advanced-Settings" class="headerlink" title="Advanced Settings"></a><a href="https://theme-next.org/docs/advanced-settings" target="_blank" rel="noopener">Advanced Settings</a></h1><h2 id="背景动画"><a href="#背景动画" class="headerlink" title="背景动画"></a>背景动画</h2><p>NexT 目前提供三种背景动画方式：three，canvas-nest，canavas-ribbon。在使用这些背景动画之前，我们需要下载这些JavaScript 3D 库。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd themes&#x2F;next</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-three.git source&#x2F;lib&#x2F;three</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-canvas-nest.git source&#x2F;lib&#x2F;canvas-nest</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-canvas-ribbon.git source&#x2F;lib&#x2F;canvas-ribbon</span><br></pre></td></tr></table></figure><br>然后可以按照自己的喜好，打开 主题配置文件，找到 canvas 相关内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># JavaScript 3D library.</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-three</span><br><span class="line">three:</span><br><span class="line">  enable: false</span><br><span class="line">  three_waves: false</span><br><span class="line">  canvas_lines: false</span><br><span class="line">  canvas_sphere: false</span><br><span class="line"></span><br><span class="line"># Canvas-nest</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-canvas-nest</span><br><span class="line"># For more information: https:&#x2F;&#x2F;github.com&#x2F;hustcc&#x2F;canvas-nest.js</span><br><span class="line">canvas_nest:</span><br><span class="line">  enable: true</span><br><span class="line">  onmobile: true # Display on mobile or not</span><br><span class="line">  color: &quot;0,0,255&quot; # RGB values, use &#96;,&#96; to separate</span><br><span class="line">  opacity: 0.5 # The opacity of line: 0~1</span><br><span class="line">  zIndex: -1 # z-index property of the background</span><br><span class="line">  count: 99 # The number of lines</span><br><span class="line"></span><br><span class="line"># Canvas-ribbon</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-canvas-ribbon</span><br><span class="line"># For more information: https:&#x2F;&#x2F;github.com&#x2F;zproo&#x2F;canvas-ribbon</span><br><span class="line">canvas_ribbon:</span><br><span class="line">  enable: true</span><br><span class="line">  size: 300 # The width of the ribbon</span><br><span class="line">  alpha: 0.6 # The transparency of the ribbon</span><br><span class="line">  zIndex: -1 # The display level of the ribbon</span><br></pre></td></tr></table></figure><br>更多NexT背景动画，可以去github上搜索<a href="https://github.com/theme-next" target="_blank" rel="noopener">NexT</a>查找。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>配置完感觉高大上不少，哈哈哈！</p>
]]></content>
      <categories>
        <category>博客搭建</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>03-Next主题优化三</title>
    <url>/2019/11/22/03-Next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E4%B8%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>静态网站在一些功能上是有限制的，NexT可以使用第三方服务来扩展网站。<a id="more"></a></p>
<h1 id="Third-party-Services"><a href="#Third-party-Services" class="headerlink" title="Third-party Services"></a><a href="https://theme-next.org/docs/third-party-services/" target="_blank" rel="noopener">Third-party Services</a></h1><h2 id="数学方程"><a href="#数学方程" class="headerlink" title="数学方程"></a><a href="https://theme-next.org/docs/third-party-services/math-equations" target="_blank" rel="noopener">数学方程</a></h2><p>NexT提供两个渲染引擎来显示数学方程。<a href="https://www.mathjax.org/" target="_blank" rel="noopener">MathJax</a>和<a href="https://katex.org/" target="_blank" rel="noopener">KaTeX</a><br>安装MathJax来渲染数学公式，可以使用两种渲染器：<br><a href="https://github.com/sun11/hexo-renderer-kramed" target="_blank" rel="noopener">hexo-renderer-kramed</a><br><a href="https://github.com/wzpan/hexo-renderer-pandoc" target="_blank" rel="noopener">hexo-renderer-pandoc</a></p>
<h3 id="安装MathJax"><a href="#安装MathJax" class="headerlink" title="安装MathJax"></a>安装MathJax</h3><ol>
<li>需要卸载原来的渲染器 hexo-renderer-marded 和安装上述渲染器之一<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked</span><br><span class="line">npm i hexo-renderer-kramed # or hexo-renderer-pandoc</span><br></pre></td></tr></table></figure></li>
<li><p>在 主题配置文件 中，选择 mathjax 为渲染器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Math Formulas Render Support</span><br><span class="line">math:</span><br><span class="line">  # Default (true) will load mathjax &#x2F; katex script on demand.</span><br><span class="line">  # That is it only render those page which has &#96;mathjax: true&#96; in Front-matter.</span><br><span class="line">  # If you set it to false, it will load mathjax &#x2F; katex srcipt EVERY PAGE.</span><br><span class="line">  per_page: true</span><br><span class="line"></span><br><span class="line">  # hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span><br><span class="line">  mathjax:</span><br><span class="line">    enable: true</span><br><span class="line">    # See: https:&#x2F;&#x2F;mhchem.github.io&#x2F;MathJax-mhchem&#x2F;</span><br><span class="line">    # 专门用于配置化学方程式</span><br><span class="line">    mhchem: false</span><br><span class="line"></span><br><span class="line">  # hexo-renderer-markdown-it-plus (or hexo-renderer-markdown-it with markdown-it-katex plugin) required for full Katex support.</span><br><span class="line">  katex:</span><br><span class="line">    enable: false</span><br><span class="line">    # See: https:&#x2F;&#x2F;github.com&#x2F;KaTeX&#x2F;KaTeX&#x2F;tree&#x2F;master&#x2F;contrib&#x2F;copy-tex</span><br><span class="line">    copy_tex: false</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行标准Hexo生成、部署流程或启动服务器:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g -d</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Front Matter中打开 MathJax开关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 03-Next主题优化三</span><br><span class="line">date: 2019-11-22 17:57:33</span><br><span class="line">tags: </span><br><span class="line">  - hexo</span><br><span class="line">categories: </span><br><span class="line">  - 博客搭建</span><br><span class="line">  - hexo</span><br><span class="line">mathjax: true</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在某些情况下，Markdown和TeX的语法会发生冲突。例如，下划线(<em>)在Markdown中可以解释为斜体文本的开头，在TeX中可以解释为下标标记。为了避免语法错误，请使用转义字符(\</em>)。</p>
<h3 id="在MathJax中编号和引用方程"><a href="#在MathJax中编号和引用方程" class="headerlink" title="在MathJax中编号和引用方程"></a>在MathJax中编号和引用方程</h3><p>在NexT的新版本中，我们增加了自动方程编号的功能，使得在后续文章中可以提及这个方程。我们将在下面简要描述如何使用这个特性。</p>
<p>通常，要使自动方程编号工作，您必须将LaTeX方程包装在 <code>equation</code> 环境中。<br>使用简单的旧式风格(例如:用两边各有两个美元符号来包装等式)是行不通的。如何引用一个方程?必须给出一个 <code>\label{}</code> 标记，然后在后面的文本中，使用 <code>\ref{}</code> 或 <code>\eqref{}</code> 引用它。<br>最好使用 <code>\eqref{}</code>，因为如果使用 <code>\ref{}</code>，则方程号周围没有括号。下面是一些常见的方程编号场景。</p>
<h4 id="简单方程"><a href="#简单方程" class="headerlink" title="简单方程"></a>简单方程</h4><p>对于简单的方程，使用下面的形式给出一个标记，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;equation&#125;</span><br><span class="line">e&#x3D;mc^2</span><br><span class="line">\end&#123;equation&#125;\label&#123;eq1&#125;$$</span><br></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">\begin{equation}
e=mc^2
\end{equation}\label{eq1}</script><p>然后，你可以在你的文本中很容易地引用这个方程，使用类似这样的东西:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The famous matter-energy equation $\eqref&#123;eq1&#125;$ proposed by Einstein...</span><br></pre></td></tr></table></figure></p>
<p>渲染后结果：The famous matter-energy equation (1) proposed by Einstein…</p>
<h4 id="多行方程"><a href="#多行方程" class="headerlink" title="多行方程"></a>多行方程</h4><p>对于占多行的方程，在 <code>equation</code> 环境中，你可以使用 <code>aligned</code> 环境把它分成多行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;equation&#125;</span><br><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">a &amp;&#x3D; b + c \\</span><br><span class="line">  &amp;&#x3D; d + e + f + g \\</span><br><span class="line">  &amp;&#x3D; h + i</span><br><span class="line">\end&#123;aligned&#125;</span><br><span class="line">\end&#123;equation&#125;\label&#123;eq2&#125;$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">\begin{equation}
\begin{aligned}
a &= b + c \\
  &= d + e + f + g \\
  &= h + i
\end{aligned}
\end{equation}\label{eq2}</script><p>然后，你可以在你的文本中很容易地引用这个方程，使用类似这样的东西:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Equation $\eqref&#123;eq2&#125;$ is a multi-line equation.</span><br></pre></td></tr></table></figure>
<p>渲染为：Equation (2) is a multi-line equation.</p>
<h4 id="多个方程对齐"><a href="#多个方程对齐" class="headerlink" title="多个方程对齐"></a>多个方程对齐</h4><p>我们可以使用 <code>align</code> 环境来对齐多个方程。每个方程都有自己的编号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;align&#125;</span><br><span class="line">a &amp;&#x3D; b + c \label&#123;eq3&#125; \\</span><br><span class="line">x &amp;&#x3D; yz \label&#123;eq4&#125;\\</span><br><span class="line">l &amp;&#x3D; m - n \label&#123;eq5&#125;</span><br><span class="line">\end&#123;align&#125;$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">\begin{align}
a &= b + c \label{eq3} \\
x &= yz \label{eq4}\\
l &= m - n \label{eq5}
\end{align}</script><p>然后，你可以在你的文本中很容易地引用这个方程，使用类似这样的东西:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">There are three aligned equations: equation $\eqref&#123;eq3&#125;$, equation $\eqref&#123;eq4&#125;$ and equation $\eqref&#123;eq5&#125;$.</span><br></pre></td></tr></table></figure>
<p>渲染为：There are three aligned equations: equation (3), equation (4) and equation (5).<br><code>align</code>是一个完整的方程环境，所以不需要<code>equation</code>环境包装。</p>
<h4 id="方程不编号"><a href="#方程不编号" class="headerlink" title="方程不编号"></a>方程不编号</h4><p>在<code>align</code>环境中，如果您不想对某个方程进行编号，只需要在这些方程后面加上<code>\nonumber</code>。如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;align&#125;</span><br><span class="line">-4 + 5x &amp;&#x3D; 2+y \nonumber  \\</span><br><span class="line"> w+2 &amp;&#x3D; -1+w \\</span><br><span class="line"> ab &amp;&#x3D; cb</span><br><span class="line">\end&#123;align&#125;$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">\begin{align}
-4 + 5x &= 2+y \nonumber  \\
 w+2 &= -1+w \\
 ab &= cb
\end{align}</script><h4 id="使用-tag标记方程"><a href="#使用-tag标记方程" class="headerlink" title="使用 \tag标记方程"></a>使用 <code>\tag</code>标记方程</h4><p>有时，您希望使用更多奇特的样式来引用您的方程。您可以使用<code>\tag{}</code>来实现这一点。例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$x+1\over\sqrt&#123;1-x^2&#125; \tag&#123;i&#125;\label&#123;eq_tag&#125;$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">x+1\over\sqrt{1-x^2} \tag{i}\label{eq_tag}</script><p>然后，你可以在你的文本中很容易地引用这个方程，使用类似这样的东西:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Equation $\eqref&#123;eq_tag&#125;$ use &#96;\tag&#123;&#125;&#96; instead of automatic numbering.</span><br></pre></td></tr></table></figure>
<p>Equation (i) use <code>\tag{}</code> instead of automatic numbering.</p>
<h2 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a><a href="https://theme-next.org/docs/third-party-services/comments" target="_blank" rel="noopener">评论系统</a></h2><p>LiveRe是一个基于社交网站评论的内容平台，帮助用户自由交流。</p>
<ol>
<li><a href="https://www.livere.com/" target="_blank" rel="noopener">在LiveRe</a>创建一个账号，点击 安装 按钮，选择 City 版本，点击 现在安装 按钮。</li>
<li>复制安装代码中的data-uid字段以获得LiveRe UID。</li>
<li>打开 主题配置文件，找到livere_uid，将获得的LiveRe UID添加上。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Support for LiveRe comments system.</span><br><span class="line"># You can get your uid from https:&#x2F;&#x2F;livere.com&#x2F;insight&#x2F;myCode (General web site)</span><br><span class="line">livere_uid: your_uid</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="不蒜子统计"><a href="#不蒜子统计" class="headerlink" title="不蒜子统计"></a><a href="https://theme-next.org/docs/third-party-services/statistics-and-analytics" target="_blank" rel="noopener">不蒜子统计</a></h2><p>打开 主题配置文件，找到 busuanzi_count。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Show Views &#x2F; Visitors of the website &#x2F; page with busuanzi.</span><br><span class="line"># Get more information on http:&#x2F;&#x2F;ibruce.info&#x2F;2015&#x2F;04&#x2F;04&#x2F;busuanzi</span><br><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: true</span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure></p>
<h2 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a><a href="https://theme-next.org/docs/third-party-services/search-services" target="_blank" rel="noopener">本地搜索</a></h2><p>本地搜索不需要任何外部第三方服务，可以被搜索引擎额外索引。大多数用户推荐的搜索方法。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在站点根目录下安装hexo-generator-searchdb</span><br><span class="line">npm install hexo-generator-searchdb</span><br><span class="line"># 站点配置文件添加</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br><span class="line"># 主题配置文件编辑</span><br><span class="line"># Local search</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-generator-searchdb</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # If auto, trigger search by changing input.</span><br><span class="line">  # If manual, trigger search by pressing enter key or search button.</span><br><span class="line">  trigger: auto</span><br><span class="line">  # Show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # Unescape html strings to the readable one.</span><br><span class="line">  unescape: false</span><br><span class="line">  # Preload the search data when the page loads.</span><br><span class="line">  preload: false</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>基于hexo和NexT主题的搭建基本完成！</p>
]]></content>
      <categories>
        <category>博客搭建</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>04-Next主题优化四</title>
    <url>/2019/11/23/04-Next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E5%9B%9B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍如何修改<code>hexo s</code>默认端口，模板，草稿等问题。<a id="more"></a></p>
<h1 id="hexo-s默认端口"><a href="#hexo-s默认端口" class="headerlink" title="hexo s默认端口"></a><code>hexo s</code>默认端口</h1><p>我们知道<code>hexo s</code>会打开的默认端口是4000。但是博主在运行本地博客的时候，访问4000端口有时候可以有时候不可以。所以决定修改掉这个端口。网络上大多推荐使用：<code>hexo s -p 5000</code>这种方式，但是每次都要换端口太麻烦了。永久的方法如下：</p>
<ul>
<li>打开 站点目录下的<code>node_modules/hexo-server/index.js</code>，修改端口为5000即可。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo.config.server &#x3D; Object.assign(&#123;</span><br><span class="line">  port: 5000,</span><br><span class="line">  log: false,</span><br><span class="line">  &#x2F;&#x2F; &#96;undefined&#96; uses Node&#39;s default (try &#96;::&#96; with fallback to &#96;0.0.0.0&#96;)</span><br><span class="line">  ip: undefined,</span><br><span class="line">  compress: false,</span><br><span class="line">  header: true</span><br><span class="line">&#125;, hexo.config.server);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="hexo-写作"><a href="#hexo-写作" class="headerlink" title="hexo 写作"></a><a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">hexo 写作</a></h1><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>在Hexo 中，您可以执行下列命令来创建一篇新文章或者新的页面。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><br>您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。<br>Hexo 有三种默认布局：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径。</p>
<ul>
<li>默认post布局保存在 source/_posts 目录下；</li>
<li>page布局保存在 source目录下；</li>
<li>draft布局保存在 source/drafts目录下。</li>
</ul>
<h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><p>刚刚提到了 Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source/_drafts 文件夹，您可通过 <code>publish</code> 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 <code>new</code> 十分类似，您也可在命令中指定 layout 来指定布局。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><br>草稿默认不会显示在页面中，您可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 true 来预览草稿。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建test草稿</span><br><span class="line">hexo new draft test</span><br><span class="line"># 将test草稿放置到 source&#x2F;_posts 文件夹</span><br><span class="line">hexo publish test</span><br><span class="line"># 显示草稿</span><br><span class="line">hexo s --draft</span><br></pre></td></tr></table></figure></p>
<h3 id="模板-Scaffold"><a href="#模板-Scaffold" class="headerlink" title="模板(Scaffold)"></a>模板(Scaffold)</h3><p>在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new photo &quot;My Gallery&quot;</span><br></pre></td></tr></table></figure><br>在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章。比如，关于 hexo 的博客可以新建 hexo.md 模板，内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">  - hexo</span><br><span class="line">categories:</span><br><span class="line">  - 博客搭建</span><br><span class="line">  - hexo</span><br></pre></td></tr></table></figure><br>然后，使用<code>hexo new hexo &quot;test&quot;</code>即可新建自己的模板。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文是对hexo的一些小功能的总结！博主的hexo博客搭建就此告一段落！</p>
]]></content>
      <categories>
        <category>博客搭建</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>05-学习强国科普一</title>
    <url>/2019/11/24/05-%E5%AD%A6%E4%B9%A0%E5%BC%BA%E5%9B%BD%E7%A7%91%E6%99%AE%E4%B8%80/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本科真的是两耳不闻窗外事，研究生有入党的想法！虽然不一定成功，但是记录一些常识还是有必要的！<br><a id="more"></a></p>
<h1 id="中央机构"><a href="#中央机构" class="headerlink" title="中央机构"></a><a href="https://baike.baidu.com/item/%E4%B8%AD%E5%A4%AE%E6%9C%BA%E6%9E%84/5148517?fr=aladdin" target="_blank" rel="noopener">中央机构</a></h1><p>“中央机构”就是主要包括国家机构、中央政府组成部门、中共中央，以及辅助机构、部门机构、直属事业单位。  </p>
<p>国家机构：  </p>
<ul>
<li>全国人民代表大会及其常务委员会</li>
<li><strong>中华人民共和国主席</strong></li>
<li>中华人民共和国国务院</li>
<li>中华人民共和国国家监察委员会</li>
<li>中华人民共和国最高人民法院</li>
<li>中华人民共和国最高人民检察院</li>
<li>中华人民共和国中央军事委员会</li>
</ul>
<p>中央政府组成部门：</p>
<ul>
<li>中华人民共和国外交部</li>
<li>中华人民共和国国家发展和改革委员会</li>
<li>中华人民共和国国防部</li>
<li>中华人民共和国教育部</li>
<li>中华人民共和国工业和信息化部</li>
<li>中华人民共和国公安部</li>
<li>中华人民共和国财政部</li>
<li>中华人民共和国商务部</li>
<li>中华人民共和国国家卫生健康委员会等</li>
</ul>
<p>中共中央：</p>
<ul>
<li>中国共产党全国代表大会</li>
<li>中国共产党中央委员会</li>
<li>中国共产党中央政治局及其常务委员会、</li>
<li>中国共产党中央书记处</li>
<li>中国共产党中央纪律检查委员会</li>
<li>中国共产党中央军事委员会</li>
</ul>
<p>国家中央军事委员会与中共中央军事委员会是同一机构。</p>
<h1 id="国家机构"><a href="#国家机构" class="headerlink" title="国家机构"></a>国家机构</h1><h2 id="全国人民代表大会"><a href="#全国人民代表大会" class="headerlink" title="全国人民代表大会"></a><a href="https://baike.baidu.com/item/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%85%A8%E5%9B%BD%E4%BA%BA%E6%B0%91%E4%BB%A3%E8%A1%A8%E5%A4%A7%E4%BC%9A" target="_blank" rel="noopener">全国人民代表大会</a></h2><p>中华人民共和国全国人民代表大会是<strong>最高国家权力机关</strong>。它的常设机关是<a href="https://baike.baidu.com/item/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%85%A8%E5%9B%BD%E4%BA%BA%E6%B0%91%E4%BB%A3%E8%A1%A8%E5%A4%A7%E4%BC%9A%E5%B8%B8%E5%8A%A1%E5%A7%94%E5%91%98%E4%BC%9A/5694500?fromtitle=%E5%85%A8%E5%9B%BD%E4%BA%BA%E6%B0%91%E4%BB%A3%E8%A1%A8%E5%A4%A7%E4%BC%9A%E5%B8%B8%E5%8A%A1%E5%A7%94%E5%91%98%E4%BC%9A&amp;fromid=689890&amp;fr=aladdin" target="_blank" rel="noopener">全国人民代表大会常务委员会</a>。<strong>全国人民代表大会和全国人民代表大会常务委员会行使国家立法权</strong>。全国人民代表大会由省、自治区、直辖市、特别行政区和军队选出的代表组成。各少数民族都应当有适当名额的代表。</p>
<p>全国人民代表大会每届任期五年，<strong>每年举行一次会议</strong>。如果全国人民代表大会常务委员会认为必要，或者有五分之一以上的全国人民代表大会代表提议，可以临时召集全国人民代表大会会议。</p>
<p>全国人民代表大会会议于每年第一季度举行，由全国人民代表大会常务委员会召集。全国人民代表大会举行会议时，选举主席团主持会议。</p>
<p>常务委员会的组成人员由全国人民代表大会从全国人民代表大会的代表中选举产生。委员长主持全国人民代表大会常务委员会的工作，召集全国人民代表大会常务委员会会议。副委员长、秘书长协助委员长工作。  </p>
<p>全国人民代表大会常务委员会会议一般每两个月举行一次；有特殊需要的时候，可以临时召集会议。</p>
<p><strong>根据中华人民共和国宪法和相关规定，中华人民共和国第十三届全国人民代表大会任期自2018年3月起，至2023年3月止。</strong></p>
<p>第十三届全国人民代表大会常务委员会委员长：栗战书</p>
<p>中国人民政治协商会议第十三届全国委员会任期自2018年3月起，至2023年3月止。</p>
<p><img src="/images/05-学习强国科普一/01-人大组织结构.jpg" alt="&quot;01-人大组织结构.jpg&quot;"></p>
<h3 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h3><p>全国人民代表大会行使下列职权：</p>
<ol>
<li>修改宪法；</li>
<li>选举中华人民共和国主席、副主席；</li>
<li>根据中华人民共和国主席的提名，决定中华人民共和国国务院总理的人选；根据国务院总理的提名，决定国务院副总理、国务委员、各部部长、各委员会主任、审计长、秘书长的人选；</li>
<li>选举中央军事委员会主席；根据中央军事委员会主席的提名，决定中央军事委员会其他组成人员的人选；</li>
<li>批准省、自治区和直辖市的建置；</li>
<li>决定特别行政区的设立及其制度；</li>
<li>决定战争和和平的问题<strong>等</strong></li>
</ol>
<p>全国人民代表大会有权罢免下列人员：</p>
<ol>
<li>中华人民共和国主席、副主席；</li>
<li>国务院总理、副总理、国务委员、各部部长、各委员会主任、审计长、秘书长；</li>
<li>中央军事委员会主席和中央军事委员会其他组成人员；</li>
<li>批准省、自治区、直辖市的建置；决定特别行政区的设立及其制度；决定战争和和平的问题<strong>等</strong></li>
</ol>
<h2 id="中华人民共和国国务院"><a href="#中华人民共和国国务院" class="headerlink" title="中华人民共和国国务院"></a><a href="http://www.gov.cn/guowuyuan/zuzhi.htm" target="_blank" rel="noopener">中华人民共和国国务院</a></h2><p>中华人民共和国国务院，即<strong>中央人民政府</strong>，<strong>是最高国家权力机关的执行机关，是最高国家行政机关</strong>，由总理、副总理、国务委员、各部部长、各委员会主任、审计长、秘书长组成。国务院实行总理负责制。(立法、行政、司法)</p>
<p>国务院组成部门即中央政府组成部门。</p>
<h1 id="中共中央组织结构"><a href="#中共中央组织结构" class="headerlink" title="中共中央组织结构"></a>中共中央组织结构</h1><p><a href="http://www.chinanews.com/gn/z/shijiuda/19thcpccc.shtml" target="_blank" rel="noopener">中国共产党第十九届中央领导机构成员</a></p>
<h2 id="中国共产党全国代表大会"><a href="#中国共产党全国代表大会" class="headerlink" title="中国共产党全国代表大会"></a>中国共产党全国代表大会</h2><p><strong>中国共产党全国代表大会和它所产生的中国共产党中央委员会</strong>为中国共产党<a href="http://www.ccdi.gov.cn/tjts/ytdd/201712/t20171222_157490.html" target="_blank" rel="noopener">最高领导机关</a>。<br>中国共产党全国代表大会每五年举行一次，由中央委员会召集。中央委员会认为有必要，或者有三分之一以上的省一级组织提出要求，全国代表大会可以提前举行；如无非常情况，不得延期举行。全国代表大会代表的名额和选举办法，由中央委员会决定。由<a href="http://www.81.cn/zggcdsjd/2017-10/18/content_7790061.htm" target="_blank" rel="noopener">十九大代表都有哪些人？如何选举产生？</a>可知，十九大选举产生了2287名出席党的十九大代表。  </p>
<p>2017年10月18日，十九大：中国共产党第十九次全国代表大会。由此产生中国共产党第十九届中央委员会。  </p>
<p><img src="/images/05-学习强国科普一/02-中共中央组织结构.jpg" alt="&quot;02-中共中央组织结构.jpg&quot;"></p>
<h3 id="职权"><a href="#职权" class="headerlink" title="职权"></a>职权</h3><ul>
<li>听取和审查中央委员会的报告；</li>
<li>听取和审查中央纪律检查委员会的报告；</li>
<li>讨论并决定党的重大问题；</li>
<li><strong>修改党的章程</strong>；</li>
<li><strong>选举中央委员会</strong>；</li>
<li><strong>选举中央纪律检查委员会</strong>。</li>
</ul>
<h2 id="中国共产党中央委员会"><a href="#中国共产党中央委员会" class="headerlink" title="中国共产党中央委员会"></a>中国共产党中央委员会</h2><p>中国共产党中央委员会，是中国共产党全国代表大会产生的中国共产党核心权力机构，简称中共中央。<br>中共中央的领导人现称中国共产党中央委员会总书记，简称中共中央总书记。<br>中国共产党中央委员会每届任期五年。全国代表大会如提前或延期举行，它的任期相应地改变。中央委员会委员和候补委员必须有五年以上的党龄。中央委员会委员和候补委员的名额，由全国代表大会决定。中央委员会委员出缺，由中央委员会候补委员按照得票多少依次递补。  </p>
<h2 id="职能"><a href="#职能" class="headerlink" title="职能"></a>职能</h2><ul>
<li>召开中国共产党全国代表大会</li>
<li>领导党的全部工作<br>在全国代表大会闭会期间，中央委员会执行全国代表大会的决议，领导党的全部工作，对外代表中国共产党。</li>
</ul>
<h3 id="几届几中"><a href="#几届几中" class="headerlink" title="几届几中"></a>几届几中</h3><p>中央委员会全体会议由中央政治局召集，每年至少举行一次。中央政治局向中央委员会全体会议报告工作，接受监督。</p>
<p>2019年10月28日至31日，中国共产党第十九届中央委员会第四次全体会议在北京召开。简称十九届四中全会。</p>
<h2 id="中国共产党中央政治局及其常务委员会"><a href="#中国共产党中央政治局及其常务委员会" class="headerlink" title="中国共产党中央政治局及其常务委员会"></a>中国共产党中央政治局及其常务委员会</h2><h3 id="中国共产党中央政治局"><a href="#中国共产党中央政治局" class="headerlink" title="中国共产党中央政治局"></a><a href="https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E5%85%B1%E4%BA%A7%E5%85%9A%E4%B8%AD%E5%A4%AE%E6%94%BF%E6%B2%BB%E5%B1%80/4965426?fromtitle=%E4%B8%AD%E5%A4%AE%E6%94%BF%E6%B2%BB%E5%B1%80&amp;fromid=176901" target="_blank" rel="noopener">中国共产党中央政治局</a></h3><p>中国共产党中央政治局，简称中共中央政治局或中央政治局，是中国共产党的中央领导机构之一。<br>党的中央政治局、中央政治局常务委员会和中央委员会总书记，由中央委员会全体会议选举。<strong>中央委员会总书记</strong>必须从<strong>中央政治局常务委员会委员</strong>中产生。<br>中央政治局和它的常务委员会在中央委员会全体会议闭会期间，行使中央委员会的职权。  </p>
<p>第19届中央政治局委员25名：丁薛祥、习近平、王晨、王沪宁、刘鹤、许其亮、孙春兰（女）、李希、李强、李克强、李鸿忠、杨洁篪、杨晓渡、汪洋、张又侠、陈希、陈全国、陈敏尔、赵乐际、胡春华、栗战书、郭声琨、黄坤明、韩正、蔡奇</p>
<h3 id="中国共产党中央政治局常务委员会"><a href="#中国共产党中央政治局常务委员会" class="headerlink" title="中国共产党中央政治局常务委员会"></a><a href="https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E5%85%B1%E4%BA%A7%E5%85%9A%E4%B8%AD%E5%A4%AE%E6%94%BF%E6%B2%BB%E5%B1%80%E5%B8%B8%E5%8A%A1%E5%A7%94%E5%91%98%E4%BC%9A/5269848#2_15" target="_blank" rel="noopener">中国共产党中央政治局常务委员会</a></h3><p>中国共产党中央政治局常务委员会，简称“中共中央政治局常委会”，由中国共产党中央委员会全体会议选举产生，任期与中国共产党中央委员会一致。其成员（委员）简称“中共中央政治局常委”，是中国共产党中央领导集体的重要成员，也是中华人民共和国和中国共产党的重要领导人。</p>
<p>第19届中央政治局常委：习近平、李克强、栗战书、汪洋、王沪宁、赵乐际、韩正</p>
<h2 id="中国共产党中央书记处"><a href="#中国共产党中央书记处" class="headerlink" title="中国共产党中央书记处"></a><a href="https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E5%85%B1%E4%BA%A7%E5%85%9A%E4%B8%AD%E5%A4%AE%E4%B9%A6%E8%AE%B0%E5%A4%84/893913" target="_blank" rel="noopener">中国共产党中央书记处</a></h2><p>中央书记处是中央政治局和它的常务委员会的办事机构；成员由中央政治局常务委员会提名，中央委员会全体会议通过。<br>中央委员会总书记负责召集中央政治局会议和中央政治局常务委员会会议，并主持中央书记处的工作。</p>
<p>第19届中央书记处书记：王沪宁、丁薛祥、杨晓渡、陈希、郭声琨、黄坤明、尤权</p>
<h2 id="中国共产党中央纪律检查委员会"><a href="#中国共产党中央纪律检查委员会" class="headerlink" title="中国共产党中央纪律检查委员会"></a><a href="https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E5%85%B1%E4%BA%A7%E5%85%9A%E4%B8%AD%E5%A4%AE%E7%BA%AA%E5%BE%8B%E6%A3%80%E6%9F%A5%E5%A7%94%E5%91%98%E4%BC%9A/5655314" target="_blank" rel="noopener">中国共产党中央纪律检查委员会</a></h2><p>中国共产党中央纪律检查委员会（简称中共中央纪委、中央纪委或中纪委）为中国共产党中央委员会的检查监督机关，担负维护党的章程和其他党内法规，检查党的路线、方针、政策和决议的执行情况，协助党的委员会加强党风建设和组织协调反腐败工作的主要任务，实行<strong>书记</strong>负责制。  </p>
<p>党的中央纪律检查委员会在党的中央委员会领导下进行工作。党的地方各级纪律检查委员会和基层纪律检查委员会在同级党的委员会和上级纪律检查委员会双重领导下进行工作。上级党的纪律检查委员会加强对下级纪律检查委员会的领导。</p>
<h2 id="中国共产党中央军事委员会"><a href="#中国共产党中央军事委员会" class="headerlink" title="中国共产党中央军事委员会"></a><a href="https://baike.baidu.com/item/%E4%B8%AD%E5%A4%AE%E5%86%9B%E4%BA%8B%E5%A7%94%E5%91%98%E4%BC%9A" target="_blank" rel="noopener">中国共产党中央军事委员会</a></h2><p>中央军事委员会简称“中央军委”。中国共产党和中华人民共和国领导全国武装力量的最高军事机构。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>两会：中华人民共和国全国人民代表大会和中国人民政治协商会议<br>党代会：如中国共产党全国代表大会<br>人代会：如全国人民代表大会</p>
]]></content>
      <categories>
        <category>学习强国</category>
      </categories>
      <tags>
        <tag>学习强国</tag>
      </tags>
  </entry>
  <entry>
    <title>06-leetcode-数组一</title>
    <url>/2019/11/27/06-leetcode-%E6%95%B0%E7%BB%84%E4%B8%80/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2019.11.27始！</p>
<a id="more"></a>
<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">两数之和</a></h1><p>从题目可知，我们需要找到数组中的两个数，这两个数之和为target。然后，返回这两个数的<strong>数组下标</strong>。</p>
<ul>
<li><p>错误解法<br>没有注意到返回的是数组的下标，所以先进行了排序。这里是不能进行排序的。</p>
</li>
<li><p>暴力解法<br>指定两个指针，一个指针指向一个固定元素，另一个指针遍历固定元素之后其他所有元素。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 时间复杂度 O(n^2) 空间复杂度 O(1)</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">  vector&lt;int&gt; twoSum(vector&lt;int&gt; nums, int target)&#123;</span><br><span class="line">    for(int i&#x3D;0; i&lt;nums.size()-1; i++)</span><br><span class="line">      for(int j&#x3D;i+1; j&lt;nums.size(); j++)</span><br><span class="line">        if((nums.at(i)+nums.at(j)) &#x3D;&#x3D; target)</span><br><span class="line">          return &#123;i, j&#125;;</span><br><span class="line">    </span><br><span class="line">    throw invalid_argument(&quot;the input has no solution&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;    &#x2F;&#x2F; 注意分号</span><br></pre></td></tr></table></figure>
<h1 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water" target="_blank" rel="noopener">盛最多水的容器</a></h1><ul>
<li>暴力解法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 时间复杂度 O(n^2) 空间复杂度 O(1)</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cassert&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int maxArea(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">    assert(height.size() &gt;&#x3D; 2);</span><br><span class="line"></span><br><span class="line">		int maxArea &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; height.size() - 1; i++) &#123;</span><br><span class="line">			for (int j &#x3D; i + 1; j &lt; height.size(); j++) &#123;</span><br><span class="line">				int area &#x3D; (j - i)*(height[i] &gt; height[j] ? height[j] : height[i]);</span><br><span class="line">				if (area &gt; maxArea)</span><br><span class="line">					maxArea &#x3D; area;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return maxArea;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>双指针解法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 时间复杂度 O(n) 空间复杂度 O(1)</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cassert&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int maxArea(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line"></span><br><span class="line">		assert(height.size() &gt;&#x3D; 2);</span><br><span class="line"></span><br><span class="line">		int leftp &#x3D; 0, rightp &#x3D; height.size() - 1;</span><br><span class="line">		int maxArea &#x3D; 0;</span><br><span class="line">		int area &#x3D; 0;</span><br><span class="line"></span><br><span class="line">		while (leftp &lt; rightp) &#123;</span><br><span class="line">			area &#x3D; max(area, (rightp - leftp)*min(height[leftp], height[rightp]));</span><br><span class="line">		</span><br><span class="line">			&#x2F;&#x2F; 必须移动边较小的指针</span><br><span class="line">			&#x2F;&#x2F; 移动边较大的指针，面积一定小于或等于当前的面积</span><br><span class="line">			&#x2F;&#x2F; 移动边较小的指针，面积有可能比当前面积大</span><br><span class="line">			if (height[leftp] &gt; height[rightp])</span><br><span class="line">				rightp--;</span><br><span class="line">			else</span><br><span class="line">				leftp++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return area;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">三数之和</a></h1><ul>
<li>暴力解法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 时间复杂度 O(n^3) 空间复杂度 O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">		if (nums.size() &lt; 3) return&#123;&#125;;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">		set&lt;vector&lt;int&gt;&gt; vset;  &#x2F;&#x2F; set去重</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt; nums.size() - 2; i++) &#123;</span><br><span class="line">			for (int j &#x3D; i + 1; j &lt; nums.size() - 1; j++) &#123;</span><br><span class="line">				for (int k &#x3D; j + 1; k &lt; nums.size(); k++) &#123;</span><br><span class="line">					if ((nums[i] + nums[j] + nums[k]) &#x3D;&#x3D; 0) &#123;</span><br><span class="line"></span><br><span class="line">						vector&lt;int&gt; temp;</span><br><span class="line">						int a &#x3D; min(min(nums[i], nums[j]), nums[k]);</span><br><span class="line">						int b &#x3D; max(max(nums[i], nums[j]), nums[k]);</span><br><span class="line">						int c &#x3D; 0 - a - b;</span><br><span class="line"></span><br><span class="line">						temp &#x3D; &#123;a, b, c&#125;;</span><br><span class="line">						vset.insert(temp);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for (auto it : vset) &#123;</span><br><span class="line">			res.push_back(it);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>双指针法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 时间复杂度 O(n^2)+O(nlogn) 空间复杂度 O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">		int bindex, cindex;</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">		sort(nums.begin(), nums.end());</span><br><span class="line"></span><br><span class="line">		int index &#x3D; 0;</span><br><span class="line">		while (index &lt; nums.size()) &#123;</span><br><span class="line">			if (nums[index] &gt; 0)</span><br><span class="line">				break;</span><br><span class="line"></span><br><span class="line">			bindex &#x3D; index + 1;</span><br><span class="line">			cindex &#x3D; nums.size() - 1;</span><br><span class="line"></span><br><span class="line">			while (bindex &lt; cindex) &#123;</span><br><span class="line">				if (nums[index] + nums[bindex] + nums[cindex] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">					res.push_back(&#123; nums[index], nums[bindex], nums[cindex] &#125;);</span><br><span class="line">					bindex &#x3D; next_nums_index(nums, bindex);</span><br><span class="line">					cindex &#x3D; prev_nums_index(nums, cindex);</span><br><span class="line">					&#x2F;&#x2F;break;	&#x2F;&#x2F; 固定一数，可以有不同的其他两数与之相加，和为0</span><br><span class="line">				&#125;</span><br><span class="line">				else if (nums[index] + nums[bindex] + nums[cindex] &lt; 0) &#123;</span><br><span class="line">					bindex &#x3D; next_nums_index(nums, bindex);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					cindex &#x3D; prev_nums_index(nums, cindex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">      &#x2F;&#x2F; 需要在函数内部对index操作，不能使用for循环</span><br><span class="line">			index &#x3D; next_nums_index(nums, index);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	int next_nums_index(vector&lt;int&gt;&amp; nums, int cur) &#123;</span><br><span class="line">		for (int i &#x3D; cur + 1; i &lt; nums.size(); i++) &#123;</span><br><span class="line">			if (nums[i] !&#x3D; nums[cur])</span><br><span class="line">				return i;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return nums.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int prev_nums_index(vector&lt;int&gt;&amp; nums, int cur) &#123;</span><br><span class="line">		for (int i &#x3D; cur - 1; i &lt; nums.size(); i--) &#123;</span><br><span class="line">			if (nums[i] !&#x3D; nums[cur])</span><br><span class="line">				return i;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">最接近的三数之和</a></h1><ul>
<li>双指针法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 时间复杂度 O(n^2)+O(nlogn) 空间复杂度 O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">		sort(nums.begin(), nums.end());</span><br><span class="line"></span><br><span class="line">		int minsum &#x3D; nums[0] + nums[1] + nums[2], sum;</span><br><span class="line">		for (int index &#x3D; 0; index &lt; nums.size() - 2; index++) &#123;</span><br><span class="line">			int start &#x3D; index + 1, end &#x3D; nums.size() - 1;</span><br><span class="line"></span><br><span class="line">			while (start &lt; end) &#123;</span><br><span class="line">				sum &#x3D; nums[index] + nums[start] + nums[end];</span><br><span class="line">				if (abs(sum - target) &lt; abs(minsum - target))</span><br><span class="line">					minsum &#x3D; sum;</span><br><span class="line">				else if (sum &gt; target)</span><br><span class="line">					end--;</span><br><span class="line">				else</span><br><span class="line">					start++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return minsum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">四数之和</a></h1><ul>
<li>双指针法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">&#x2F;&#x2F; 时间复杂度 O(n^3) 空间复杂度 O(1)</span><br><span class="line">public:</span><br><span class="line">	vector&lt; vector&lt;int&gt; &gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">		vector&lt; vector&lt;int&gt; &gt; res;</span><br><span class="line">		int i&#x3D;0, j&#x3D;0, start&#x3D;0, end&#x3D;0, sum&#x3D;0, size &#x3D; nums.size();</span><br><span class="line">		if (size &lt; 4)</span><br><span class="line">			return res;</span><br><span class="line"></span><br><span class="line">		sort(nums.begin(), nums.end());</span><br><span class="line"></span><br><span class="line">		for (i &#x3D; 0; i &lt; size - 3; i &#x3D; next_nums_index(nums, i)) &#123;</span><br><span class="line">			for (j &#x3D; i + 1; j &lt; size - 2; j &#x3D; next_nums_index(nums, j)) &#123;</span><br><span class="line"></span><br><span class="line">				int sum_min &#x3D; nums[i] + nums[j] + nums[j + 1] + nums[j + 2];</span><br><span class="line">				int sum_max &#x3D; nums[i] + nums[j] + nums[size - 1] + nums[size - 2];</span><br><span class="line"></span><br><span class="line">				if (sum_min &gt; target)</span><br><span class="line">					break;</span><br><span class="line">				if (sum_max &lt; target)</span><br><span class="line">					continue;</span><br><span class="line"></span><br><span class="line">				start &#x3D; j + 1, end &#x3D; size - 1;</span><br><span class="line">				while (start &lt; end) &#123;</span><br><span class="line">					sum &#x3D; nums[i] + nums[j] + nums[start] + nums[end];</span><br><span class="line">					if (sum &#x3D;&#x3D; target) &#123;</span><br><span class="line">						res.push_back(&#123; nums[i], nums[j], nums[start], nums[end] &#125;);</span><br><span class="line"></span><br><span class="line">						end &#x3D; prev_nums_index(nums, end);</span><br><span class="line">						start &#x3D; next_nums_index(nums, start);</span><br><span class="line">					&#125;</span><br><span class="line">					else if (sum &gt; target) </span><br><span class="line">						end &#x3D; prev_nums_index(nums, end);</span><br><span class="line">					else</span><br><span class="line">						start &#x3D; next_nums_index(nums, start);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	int next_nums_index(const vector&lt;int&gt;&amp; nums, int index) &#123;</span><br><span class="line">		for (int i &#x3D; index + 1; i &lt; nums.size(); i++) &#123;</span><br><span class="line">			if (nums[i] !&#x3D; nums[index])</span><br><span class="line">				return i;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return nums.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int prev_nums_index(const vector&lt;int&gt;&amp; nums, int index) &#123;</span><br><span class="line">		&#x2F;&#x2F;for (int i &#x3D; index - 1; index &gt;&#x3D; 0; i--) &#123;	&#x2F;&#x2F; error index&gt;&#x3D;0 for循环恒成立</span><br><span class="line">		for (int i &#x3D; index - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			if (nums[i] !&#x3D; nums[index])</span><br><span class="line">				return i;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">删除排序数组中的重复项</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 时间复杂度 O(n)，空间复杂度 O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size() &lt;&#x3D; 0) return 0;</span><br><span class="line"></span><br><span class="line">        int index &#x3D; 0;	&#x2F;&#x2F; [0, index]的为正确的数组元素</span><br><span class="line">        for(int i&#x3D;1; i&lt;nums.size(); i++)	</span><br><span class="line">            if(nums[index] !&#x3D; nums[i])</span><br><span class="line">                nums[++index] &#x3D; nums[i];</span><br><span class="line"></span><br><span class="line">        return index+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="删除排序数组中的重复项-II"><a href="#删除排序数组中的重复项-II" class="headerlink" title="删除排序数组中的重复项 II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/" target="_blank" rel="noopener">删除排序数组中的重复项 II</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size() &lt;&#x3D; 0) return 0;</span><br><span class="line">        int index &#x3D; 0;      &#x2F;&#x2F; &#x2F;&#x2F; [0, index]的为正确的数组元素</span><br><span class="line">        int k &#x3D; 1;</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;1; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            if(nums[index] !&#x3D; nums[i])&#123;</span><br><span class="line">                nums[++index] &#x3D; nums[i];</span><br><span class="line">                k &#x3D; 1;</span><br><span class="line">            &#125;else if(nums[index] &#x3D;&#x3D; nums[i] &amp;&amp; k &lt; 2)&#123;</span><br><span class="line">                nums[++index] &#x3D; nums[i];</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return index+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a><a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">移除元素</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 时间复杂度 O(n)，空间复杂度 O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">		if (nums.size() &lt;&#x3D; 0) return 0;</span><br><span class="line">    	&#x2F;&#x2F;不需要进行排序</span><br><span class="line">		&#x2F;&#x2F;sort(nums.begin(), nums.end());</span><br><span class="line"></span><br><span class="line">		int i &#x3D; 0, k &#x3D; 0;</span><br><span class="line">		while (k &lt; nums.size()) &#123;</span><br><span class="line">			if (nums[k] !&#x3D; val) &#123;</span><br><span class="line">				nums[i++] &#x3D; nums[k++];</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">				k++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">下一个排列</a></h1><ul>
<li>字典序<br>在字典序中，降序排列是最大的排列；升序排列是最小的排列。比如 cba &gt; abc，就相当于 321 &gt; 123。</li>
<li>下一个排列</li>
</ul>
<ol>
<li>从排列的右侧开始，找到满足条件的最长降序排列。 比如 1 5 4 7 6 3 1。右侧向左最长降序排列 7 6 3 1。在这个最大降序子序列上找下一个序列。</li>
<li>实现中，nums[i] &lt; nums[i+1] 时就已经是最长降序排列。然后将 nums[i] 与 最长降序排列中 nums[j] 进行交换。 满足的条件为：nums[j] &gt; nums[i]。即替换出大的数才有大的排列。</li>
<li>交换之后，交换后的最长降序排列比交换前的最长降序排列要大。但是不是下一个排列。交换后的仍是最长降序排列，是交换后 nums[i] 下的的最大排列。</li>
<li>将最长排序排列 翻转成 最长升序排列，此时是交换后 nums[i] 下的最长升序排列。但是一定大于交换前 nums[i] 的最长降序排列。</li>
<li>字典序，位置越靠前，权重越大。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 时间复杂度 O(n), 空间复杂度 O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	void nextPermutation(vector&lt;int&gt;&amp; nums) &#123;zui</span><br><span class="line">		if (nums.size() &lt;&#x3D; 1) return;</span><br><span class="line">		int i &#x3D; nums.size() - 2, j &#x3D; nums.size() - 1;</span><br><span class="line">		while (i &gt;&#x3D; 0) &#123;</span><br><span class="line">			if (nums[i] &gt;&#x3D; nums[i+1])</span><br><span class="line">				i--;</span><br><span class="line">			else &#123;</span><br><span class="line">				if (nums[i] &gt;&#x3D; nums[j])</span><br><span class="line">					j--;</span><br><span class="line">				else</span><br><span class="line">				&#123;</span><br><span class="line">					swap(nums[i], nums[j]);</span><br><span class="line">					break;</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		reverse(nums, i+1, nums.size()-1);</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	void reverse(vector&lt;int&gt;&amp; nums, int i, int j) &#123;</span><br><span class="line">		while (i &lt; j) &#123;</span><br><span class="line">			swap(nums[i++], nums[j--]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>c++库函数解法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 调用C++ 库函数next_permutation</span><br><span class="line">&#x2F;&#x2F; 时间复杂度 O(n), 空间复杂度 O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	void nextPermutation(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">		next_permutation(nums.begin(), nums.end());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">在排序数组中查找元素的第一个和最后一个位置</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">		if (nums.size() &lt;&#x3D; 0|| nums[0] &gt; target || nums[nums.size() - 1] &lt; target) return &#123;-1, -1&#125;;</span><br><span class="line"></span><br><span class="line">		int lstart &#x3D; 0, lend &#x3D; nums.size() - 1, lmid,  rstart &#x3D; 0, rend &#x3D; nums.size() - 1, rmid;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; while循环结束必有：lstart &#x3D; lend + 1; rstart &#x3D; rend + 1;</span><br><span class="line">		while (lstart &lt;&#x3D; lend || rstart &lt;&#x3D; rend) &#123;</span><br><span class="line">			lmid &#x3D; (lstart + lend) &#x2F; 2;</span><br><span class="line">			rmid &#x3D; (rstart + rend) &#x2F; 2;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 跳出循环时：nums[lend] &lt; nums[lstart] </span><br><span class="line">			if (nums[lmid] &gt;&#x3D; target)</span><br><span class="line">				lend &#x3D; lmid - 1;</span><br><span class="line">			else</span><br><span class="line">				lstart &#x3D; lmid + 1;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 跳出循环时：nums[rend] &lt; nums[rstart] </span><br><span class="line">			if (nums[rmid] &lt;&#x3D; target)</span><br><span class="line">				rstart &#x3D; rmid + 1;</span><br><span class="line">			else</span><br><span class="line">				rend &#x3D; rmid - 1;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (lstart &lt;&#x3D; rend)</span><br><span class="line">			return &#123; lstart, rend &#125;;</span><br><span class="line">		else</span><br><span class="line">			return &#123; -1, -1&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>按照leetcode的标签进行刷题记录，每篇博客十道题！</p>
]]></content>
      <categories>
        <category>刷题</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>07-datastructure-插入排序</title>
    <url>/2019/11/27/07-datastructure-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据结构中，排序可以分为内部排序和外部排序。内部排序可以划分为插入排序、交换排序、选择排序、归并排序等。本文主要记录插入排序算法，包括<br>直接插入排序、折半插入排序以及希尔排序。<br><a id="more"></a></p>
<h1 id="插入排序算法"><a href="#插入排序算法" class="headerlink" title="插入排序算法"></a>插入排序算法</h1><p>排序默认从小到大排序。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序类似于洗牌的过程。第一张牌是不需要进行插入排序的，随后的牌都需要与之前的所有元素进行比较，然后插入合适的位置。<br>插入排序思想：当前元素与前一个元素比较，当前元素 小于 前一个元素，交换；否则此趟排序结束。<br>插入排序的优化：两个元素交换需要进行三次赋值，可以优化。将当前元素保存在一个变量中，然后当前元素 小于 前一个元素时，<br>当前元素的位置 赋值为 前一个元素，然后比较前一个元素。最后不满足小于条件的时候，将保存在变量中的值 赋值给当前位置。<br>时间复杂度：O(n)~O(n^2)，插入排序是稳定的排序<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void insertSort(vector&lt;T&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line">    int start &#x3D; 0, end &#x3D; nums.size();</span><br><span class="line">    for (int i&#x3D;1; i&lt;end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j&#x3D;i; j&gt;0; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nums[j] &lt; nums[j-1])</span><br><span class="line">                swap (nums[j], nums[j-1]);</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第二种写法</span><br><span class="line">&#x2F;&#x2F;        for (int j&#x3D;i; j&gt;0 &amp;&amp; nums[j-1]&gt;nums[j]; j--)</span><br><span class="line">&#x2F;&#x2F;            swap (nums[j], nums[j-1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>优化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void insertSortOpt(vector&lt;T&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line">    int start &#x3D; 0, end &#x3D; nums.size();</span><br><span class="line">    for (int i&#x3D;1; i&lt;end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        T temp &#x3D; nums[i];</span><br><span class="line">        int j;</span><br><span class="line">        for (j&#x3D;i; j&gt;0; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[j-1] &gt; temp)</span><br><span class="line">                nums[j] &#x3D; nums[j-1];</span><br><span class="line">            else</span><br><span class="line">                break;      &#x2F;&#x2F; break不可缺少</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第二种写法</span><br><span class="line">&#x2F;&#x2F;        for (j&#x3D;i; j&gt;0 &amp;&amp; nums[j-1]&gt;temp; j--)</span><br><span class="line">&#x2F;&#x2F;            nums[j] &#x3D; nums[j-1];</span><br><span class="line"></span><br><span class="line">        nums[j] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序——改进的插入排序"><a href="#希尔排序——改进的插入排序" class="headerlink" title="希尔排序——改进的插入排序"></a>希尔排序——改进的插入排序</h2><p>相对于普通插入排序，希尔排序在间隔大的时候移动次数少；间隔小的时候移动的距离比较短。<br>希尔排序通过设定不同的间隔对序列进行排序，每次的间隔逐渐减小，最后一次排序为普通的插入排序。<br>希尔排序每次排序可以将较小的元素放在前面，较大的元素放在后面，所以移动的次数和移动的距离都小于普通的插入排序。<br>但是，希尔排序是不稳定的排序，对于重复的元素，其位置可能发生变化。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void shellSort(vector&lt;T&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line">    int h &#x3D; 1;</span><br><span class="line">    while (h &lt; nums.size() &#x2F; 3)</span><br><span class="line">        h &#x3D; 3*h + 1;</span><br><span class="line"></span><br><span class="line">    while (h &gt;&#x3D; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i&#x3D;h; i&lt;nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            T temp &#x3D; nums[i];</span><br><span class="line">            int j;</span><br><span class="line">            for (j&#x3D;i; j&lt;nums.size(); j-&#x3D;h)</span><br><span class="line">            &#123;</span><br><span class="line">                if(nums[j-h] &gt; nums[j] )</span><br><span class="line">                nums[j] &#x3D; nums[j-h];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nums[j] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h &#x3D; h &#x2F; 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
      <categories>
        <category>数据结构</category>
        <category>内部排序</category>
      </categories>
      <tags>
        <tag>插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title>08-datastructure-交换排序</title>
    <url>/2019/11/28/08-datastructure-%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据结构中，排序可以分为内部排序和外部排序。内部排序可以划分为插入排序、交换排序、选择排序、归并排序等。本文主要记录交换排序算法，包括<br>冒泡排序、快速排序。<br><a id="more"></a></p>
<h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul>
<li>每次标定最小的元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void bubbleSortMinFirst(vector&lt;T&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line">    int start &#x3D; 0, end &#x3D; nums.size() - 1;</span><br><span class="line">    for (int i&#x3D;0; i&lt;end; i++)       &#x2F;&#x2F; 趟数</span><br><span class="line">    &#123;</span><br><span class="line">        bool swapFlag &#x3D; false;</span><br><span class="line">        for (int j&#x3D;end; j&gt;i; j--)   &#x2F;&#x2F; 内层循环包括end</span><br><span class="line">        &#123;</span><br><span class="line">            if (nums[j-1] &gt; nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                swap (nums[j], nums[j-1]);</span><br><span class="line">                swapFlag &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!swapFlag)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每次标定最大的元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void bubbleSortMaxFirst(vector&lt;T&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line">    int start &#x3D; 0, end &#x3D; nums.size() - 1;</span><br><span class="line">    for (int i&#x3D;0; i&lt;end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bool swapFlag &#x3D; false;</span><br><span class="line">        for (int j&#x3D;1; j&lt;end-i+1; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nums[j-1] &gt; nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                swap (nums[j], nums[j-1]);</span><br><span class="line">                swapFlag &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!swapFlag)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每次标定最大的元素优化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void bubbleSortOpt(vector&lt;T&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line">    int start &#x3D; 0, end &#x3D; nums.size();</span><br><span class="line">    int swapPos;</span><br><span class="line"></span><br><span class="line">    do&#123;</span><br><span class="line">        swapPos &#x3D; 0;</span><br><span class="line">        for (int j&#x3D;1; j&lt;end; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[j-1] &gt; nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                swap (nums[j-1], nums[j]);</span><br><span class="line">                swapPos &#x3D; j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        end &#x3D; swapPos;</span><br><span class="line">    &#125;while(swapPos &gt; 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>任取一个元素为中心</li>
<li>所有比它小的元素一律前方，比它大的元素一律后方，形成左右两个子表</li>
<li>对各子表重新选择中心元素并依此规则调整，直到每个子表的元素只剩一个</li>
</ol>
<ul>
<li>每一趟的子表的形成是采用从两头向中间交替式逼近法</li>
<li>由于每趟中对各子表的操作都相似，可采用递归算法</li>
</ul>
<p>缺点：如果序列是近乎有序的序列，则左右两部分会成为及其不平衡的两部分，则快速排序退化成$O(n^2)$的时间复杂度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">int __partition(vector&lt;T&gt;&amp; nums, int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">    T pivot &#x3D; nums[left];</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; j标定小于pivot的最后一个值</span><br><span class="line">	&#x2F;&#x2F; j+1标定大于等于pivot的第一个值</span><br><span class="line">    int j &#x3D; left;   </span><br><span class="line">    for (int i&#x3D;left+1; i&lt;&#x3D;right; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (nums[i] &lt; pivot)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(nums[++j], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(nums[j], nums[left]);</span><br><span class="line"></span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void __quickSort(vector&lt;T&gt;&amp; nums, int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">    if (left &gt;&#x3D; right)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    int p &#x3D; __partition(nums, left, right);</span><br><span class="line">    __quickSort(nums, left, p-1);</span><br><span class="line">    __quickSort(nums, p+1, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void quickSort(vector&lt;T&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line">    int start &#x3D; 0, end &#x3D; nums.size()-1;</span><br><span class="line">    __quickSort(nums, start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">int __partitionOpt(vector&lt;T&gt;&amp; nums, int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">    swap (nums[left], nums[rand() % (right-left+1) + left]);</span><br><span class="line"></span><br><span class="line">    T pivot &#x3D; nums[left];</span><br><span class="line"></span><br><span class="line">    int i &#x3D; left+1, j &#x3D; right;</span><br><span class="line">    &#x2F;&#x2F; i &#x3D;&#x3D; j用来限定pivot后的值都是大于或者都是小于的情况</span><br><span class="line">    while ( i&lt;&#x3D;j )</span><br><span class="line">    &#123;</span><br><span class="line">        while (i&lt;&#x3D;j &amp;&amp; nums[i]&lt;pivot) i++;</span><br><span class="line">        while (i&lt;&#x3D;j &amp;&amp; nums[j]&gt;pivot) j--;</span><br><span class="line"></span><br><span class="line">        if (i&gt;j)</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        swap(nums[i], nums[j]);</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; j最后指向小于pivot的最后一个值</span><br><span class="line">    swap (nums[left], nums[j]);</span><br><span class="line"></span><br><span class="line">    return j;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void __quickSortOpt(vector&lt;T&gt;&amp; nums, int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">    if (left &gt;&#x3D; right)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    int p &#x3D; __partitionOpt(nums, left, right);</span><br><span class="line">    __quickSortOpt(nums, left, p-1);</span><br><span class="line">    __quickSortOpt(nums, p+1, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void quickSortOpt(vector&lt;T&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    int start &#x3D; 0, end &#x3D; nums.size()-1;</span><br><span class="line">    __quickSortOpt(nums, start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三路快速排序"><a href="#三路快速排序" class="headerlink" title="三路快速排序"></a>三路快速排序</h2><p>步骤：</p>
<ul>
<li>任取一个元素为基准值</li>
<li>所有比它小的元素一律前方，等于它的元素跳过，比它大的元素一律后方，形成左右两个子表</li>
<li>对各子表重新选择中心元素并依此规则调整，直到每个子表的元素只剩一个</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void __quickSort3Ways(vector&lt;T&gt;&amp; nums, int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">    if (left &gt;&#x3D; right)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    swap (nums[left], nums[rand() % (right-left+1) + left]);</span><br><span class="line">    T pivot &#x3D; nums[left];</span><br><span class="line"></span><br><span class="line">    int lt &#x3D; left;      &#x2F;&#x2F; nums[left+1...lt] &lt; pivot</span><br><span class="line">    int gt &#x3D; right+1;   &#x2F;&#x2F; nums[gt...right] &gt; pivot</span><br><span class="line">    int i &#x3D; left+1;     &#x2F;&#x2F; nums[lt+1...i) &#x3D;&#x3D; pivot</span><br><span class="line">    while (i&lt;gt)</span><br><span class="line">    &#123;</span><br><span class="line">        if (nums[i] &lt; pivot)</span><br><span class="line">            swap (nums[i++], nums[++lt]);</span><br><span class="line">        else if(nums[i] &gt; pivot)</span><br><span class="line">            swap (nums[--gt], nums[i]);</span><br><span class="line">        else</span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap (nums[lt], nums[left]);    &#x2F;&#x2F; 交换后 nums[lt] &#x3D;&#x3D; pivot</span><br><span class="line"></span><br><span class="line">    __quickSort3Ways(nums, left, lt-1);</span><br><span class="line">    __quickSort3Ways(nums, gt, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void quickSort3Ways(vector&lt;T&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    int start&#x3D;0, end&#x3D;nums.size()-1;</span><br><span class="line">    __quickSort3Ways(nums, start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用-求数组中第K大的值"><a href="#应用-求数组中第K大的值" class="headerlink" title="应用-求数组中第K大的值"></a>应用-求数组中第K大的值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">int __findKthLargestPartition(vector&lt;T&gt;&amp; nums, int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">    swap(nums[left], nums[rand()%(right-left+1) + left]);</span><br><span class="line">    T pivot &#x3D; nums[left];</span><br><span class="line">    int i&#x3D;left+1, j&#x3D;right;</span><br><span class="line">    while(i &lt;&#x3D; j)</span><br><span class="line">    &#123;</span><br><span class="line">        while(i&lt;&#x3D;j &amp;&amp; nums[i]&lt;pivot) i++;</span><br><span class="line">        while(i&lt;&#x3D;j &amp;&amp; nums[j]&gt;pivot) j--;</span><br><span class="line"></span><br><span class="line">        if(i&gt;j)</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        swap(nums[i], nums[j]);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums[left], nums[j]);</span><br><span class="line"></span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">int __findKthLargest(vector&lt;T&gt;&amp; nums, int left, int right, int k)</span><br><span class="line">&#123;</span><br><span class="line">    if(left&gt;right)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    int p &#x3D; __findKthLargestPartition(nums, left, right);</span><br><span class="line">    if (p &#x3D;&#x3D; k)     &#x2F;&#x2F; 如果 p&#x3D;&#x3D;k, 该值就是需要找的值</span><br><span class="line">        return p;</span><br><span class="line">    else if(p &gt; k)  &#x2F;&#x2F; 如果 p&gt;k, 该值在[left, p-1]中</span><br><span class="line">        return __findKthLargest(nums, left, p-1, k);</span><br><span class="line">    else            &#x2F;&#x2F; 如果 p&lt;k, 该值在[p+1, right]中</span><br><span class="line">        return __findKthLargest(nums, p+1, right, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 寻找数组中第K个最大的元素</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">int findKthLargest(vector&lt;T&gt;&amp; nums, int k)</span><br><span class="line">&#123;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    int start&#x3D;0, end&#x3D;nums.size()-1;</span><br><span class="line">    k &#x3D; nums.size()-k;  &#x2F;&#x2F; 第K个最大的元素(从1开始，如第1个最大的值)，等同于数组中索引为nums.size()-k的值</span><br><span class="line">    int ret &#x3D; __findKthLargest(nums, start, end, k);</span><br><span class="line">&#x2F;&#x2F;    return nums[ret];</span><br><span class="line">    return nums[ret];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
      <categories>
        <category>数据结构</category>
        <category>内部排序</category>
      </categories>
      <tags>
        <tag>交换排序</tag>
      </tags>
  </entry>
  <entry>
    <title>11-datastructure-排序算法总结</title>
    <url>/2019/11/30/11-datastructure-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a>
<h1 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h1><p><img src="/images/11-datastructure-排序算法总结/排序算法总结.jpg" alt="&quot;排序算法总结&quot;">  </p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>内部排序</category>
      </categories>
  </entry>
  <entry>
    <title>09-datastructure-选择排序</title>
    <url>/2019/11/29/09-datastructure-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据结构中，排序可以分为内部排序和外部排序。内部排序可以划分为插入排序、交换排序、选择排序、归并排序等。本文主要记录选择排序算法，包括简单选择排序和堆排序。<br><a id="more"></a></p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><ul>
<li>每次排序标定最小的元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">选择排序:</span><br><span class="line">1. 外层循环：指定每次排序的位置</span><br><span class="line">2. 内层循环：从外层循环以外的数据中找出最小值，与外层循环每次排序的位置进行交换</span><br><span class="line">时间复杂度：O(n^2)</span><br><span class="line">*&#x2F;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void selectSort(vector&lt;T&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 默认从小到大排序</span><br><span class="line">    int start &#x3D; 0, end &#x3D; nums.size();</span><br><span class="line">    for (int i&#x3D;0; i&lt;end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int minIndex &#x3D; i;</span><br><span class="line">        for (int j&#x3D;i+1; j&lt;end; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nums[j] &lt; nums[minIndex])</span><br><span class="line">                minIndex &#x3D; j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap (nums[i], nums[minIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择排序是不稳定的排序：如：2(1) 2(2) 2(3) 1 3。第一次使用选择排序：1 2(2) 2(3) 2(1) 3<br>此时不同2的位置发生变化，故选择排序是不稳定的排序。</p>
<ul>
<li>每次排序标定最小和最大的元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void selectSortOpt(vector&lt;T&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line">    int start &#x3D; 0, end &#x3D; nums.size()-1;</span><br><span class="line">    while(start &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        int minIndex &#x3D; start;</span><br><span class="line">        int maxIndex &#x3D; end;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 每次确定最大值和最小值</span><br><span class="line">        if (nums[minIndex] &gt; nums[maxIndex])</span><br><span class="line">            swap(nums[minIndex], nums[maxIndex]);</span><br><span class="line"></span><br><span class="line">        for (int i&#x3D;start+1; i&lt;end; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nums[i] &lt; nums[minIndex])</span><br><span class="line">                minIndex &#x3D; i;</span><br><span class="line">            if (nums[i] &gt; nums[maxIndex])</span><br><span class="line">                maxIndex &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(nums[start], nums[minIndex]);</span><br><span class="line">        swap(nums[end], nums[maxIndex]);</span><br><span class="line"></span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是一种树形选择排序方法，它的特点是：在排序过程中，堆是一棵完全二叉树的顺序存储结构，可以用数组方式存储。实际堆元素可以从数组索引0开始存储，也可以从数组索引1开始存储。<br>堆利用完全二叉树中双亲结点和孩子结点之间的内在关系，在当前无序区中选择关键字最大(或最小的)元素，因此堆可以分为大根堆和小跟堆。大根堆中最大元素存放在根结点，且对其任一非根结点，它的值小于或等于双亲结点。小根堆中最小元素存放在根结点，且对其任一非根结点，它的值大于或等于双亲结点。堆经常被用来实现优先级队列。以下以大根堆为例进行说明。</p>
<h3 id="堆从数组索引1开始存储"><a href="#堆从数组索引1开始存储" class="headerlink" title="堆从数组索引1开始存储"></a>堆从数组索引1开始存储</h3><p><img src="/images/09-datastructure-选择排序/01-大根堆.png" alt="&quot;01-大根堆&quot;">  </p>
<ul>
<li>堆在内存中的存储方式是线性数组，当存储的位置是从索引1开始。满足：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parent(i) &#x3D; i&#x2F;2         (索引为i的结点的父节点的索引 i&#x2F;2)</span><br><span class="line">left child(i) &#x3D; 2*i     (索引为i的结点的左孩子的索引 2*i)</span><br><span class="line">right child(i) &#x3D; 2*i+1  (索引为i的结点的右孩子的索引 2*i+1)</span><br><span class="line">最后一个非叶子结点的索引   end&#x2F;2</span><br></pre></td></tr></table></figure>
<p>实际中，将一个不满足堆结构的数组构建为一个满足堆结构的数组，叫做<font color="red">构建初始堆</font>。构建初始堆有两种调整方式，向上调整和向下调整。<br>如下代码演示了向上调整的过程。每次将一个数组的元素插入堆中，待插入元素之前的元素都是满足堆条件的。向上调整的过程只会影响一条分支。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class MaxHeap</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F; 堆在数组中的存储范围：[1, end]</span><br><span class="line">    MaxHeap()</span><br><span class="line">    &#123;</span><br><span class="line">        data.push_back(0);  &#x2F;&#x2F; 堆元素从数组的索引1开始存储</span><br><span class="line">        end &#x3D; 0;            &#x2F;&#x2F; end指向堆的最后一个元素</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void insert(T t)</span><br><span class="line">    &#123;</span><br><span class="line">        data.push_back(t);</span><br><span class="line">        end++;</span><br><span class="line">        shiftUpOpt(end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 插入一个元素到已经满足堆特性的堆中</span><br><span class="line">    void shiftUp(int k)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; data[k]只有比data[k&#x2F;2]大时，才可以交换</span><br><span class="line">        while(k&gt;1 &amp;&amp; data[k]&gt;data[k&#x2F;2])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(data[k], data[k&#x2F;2]);</span><br><span class="line">            k &#x3D; k&#x2F;2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void shiftUpOpt(int k)</span><br><span class="line">    &#123;</span><br><span class="line">        data[0] &#x3D; data[k];</span><br><span class="line">        while(k&gt;1 &amp;&amp; data[0]&gt;data[k&#x2F;2])</span><br><span class="line">        &#123;</span><br><span class="line">            data[k] &#x3D; data[k&#x2F;2];</span><br><span class="line">            k &#x3D; k&#x2F;2;</span><br><span class="line">        &#125;</span><br><span class="line">        data[k] &#x3D; data[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        for(T e : data)</span><br><span class="line">            cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;T&gt; data;</span><br><span class="line">    int end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; nums &#x3D; &#123;15, 17, 19, 13, 22, 16, 28, 30, 41, 62&#125;;</span><br><span class="line">    MaxHeap&lt;int&gt; maxheap;</span><br><span class="line">    for(vector&lt;int&gt;::iterator it&#x3D;nums.begin(); it!&#x3D;nums.end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        maxheap.insert(*it);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    maxheap.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下代码演示了向下调整的过程。每一层从下向上，从右向左依次找到对应的子树，构建大根堆。对于每一棵子树，只会影响一条分支。这种构建初始堆的方式称为heapify。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class MaxHeap</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F; 堆在数组中的存储范围：[1, end]</span><br><span class="line">    MaxHeap(vector&lt;T&gt;&amp; nums)</span><br><span class="line">    &#123;</span><br><span class="line">        data.push_back(0);</span><br><span class="line">        end &#x3D; 0;</span><br><span class="line">        for(T e : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            data.push_back(e);</span><br><span class="line">            nums.pop_back();</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp &#x3D; nums;</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;end&#x2F;2; i&gt;&#x3D;1; i--)</span><br><span class="line">            shiftDownOpt(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; k是一棵至少具有左孩子的树</span><br><span class="line">    &#x2F;&#x2F; 每一棵树向下调整都是一个向下的分支</span><br><span class="line">    &#x2F;&#x2F; 最终都会到叶结点</span><br><span class="line">    void shiftDown(int k)</span><br><span class="line">    &#123;</span><br><span class="line">        while(2*k&lt;&#x3D;end)</span><br><span class="line">        &#123;</span><br><span class="line">            int j &#x3D; 2*k;</span><br><span class="line">            if(j+1&lt;&#x3D;end &amp;&amp; data[j+1]&gt;data[j]) j&#x3D;j+1;</span><br><span class="line">            if(data[k] &gt; data[j]) break;</span><br><span class="line">            swap(data[k], data[j]);</span><br><span class="line">            k &#x3D; j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void shiftDownOpt(int k)</span><br><span class="line">    &#123;</span><br><span class="line">        data[0] &#x3D; data[k];</span><br><span class="line">        while(2*k&lt;&#x3D;end)</span><br><span class="line">        &#123;</span><br><span class="line">            int j &#x3D; 2*k;</span><br><span class="line">            if(j+1&lt;&#x3D;end &amp;&amp; data[j+1]&gt;data[j]) j&#x3D;j+1;</span><br><span class="line">            if(data[0] &gt; data[j]) break;</span><br><span class="line">            data[k] &#x3D; data[j];</span><br><span class="line">            k &#x3D; j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        data[k] &#x3D; data[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        for(T e : data)</span><br><span class="line">            cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;T&gt; data;</span><br><span class="line">    vector&lt;T&gt; temp;</span><br><span class="line">    int end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; nums &#x3D; &#123;15, 17, 19, 13, 22, 16, 28, 30, 41, 62&#125;;</span><br><span class="line">    MaxHeap&lt;int&gt; maxheap(nums);</span><br><span class="line"></span><br><span class="line">    maxheap.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上可知，堆排序中存在向上调整和向下调整两种思路。向上调整的出发点是：插入一个未进行堆排序的元素到排好序的堆中。向下调整的出发点是：某元素作为根结点的树不满足<br>堆的条件，需要向下调整该元素到合适的位置，保证树满足堆的特性。</p>
<p>在实际构建初始堆的过程中，将n个元素逐个插入到一个空堆中，算法复杂度O(nlogn)；而heapify的过程，算法复杂度为O(n)。</p>
<p>那么，如何输出正确的排序结果呢？我们知道，大根堆根结点是数组中最大的元素，但是其他结点并不是排好序的。所以，一旦输出了根结点的值，就需要重新调整堆结构。通常的做法是，输出根结点后，将根结点元素值和最后一个叶子结点的值进行交换，然后按照向下调整的思路重新构建大根堆；重复以上过程，最后就能输出正确排序的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class MaxHeap</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F; 堆在数组中的存储范围：[1, end]</span><br><span class="line">    MaxHeap(vector&lt;T&gt;&amp; nums):temp(nums)</span><br><span class="line">    &#123;</span><br><span class="line">        data.push_back(0);</span><br><span class="line">        end &#x3D; 0;</span><br><span class="line">        for(T e : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            data.push_back(e);</span><br><span class="line">            nums.pop_back();</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 构建初始堆 heapify</span><br><span class="line">        for(int i&#x3D;end&#x2F;2; i&gt;&#x3D;1; i--)</span><br><span class="line">            shiftDownOpt(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 插入操作</span><br><span class="line">    void insert(T t)</span><br><span class="line">    &#123;</span><br><span class="line">        data.push_back(t);</span><br><span class="line">        end++;</span><br><span class="line">        shiftUpOpt(end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void shiftUpOpt(int k)</span><br><span class="line">    &#123;</span><br><span class="line">        data[0] &#x3D; data[k];</span><br><span class="line">        while(k&gt;1 &amp;&amp; data[0]&gt;data[k&#x2F;2])</span><br><span class="line">        &#123;</span><br><span class="line">            data[k] &#x3D; data[k&#x2F;2];</span><br><span class="line">            k &#x3D; k&#x2F;2;</span><br><span class="line">        &#125;</span><br><span class="line">        data[k] &#x3D; data[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void shiftDownOpt(int k)</span><br><span class="line">    &#123;</span><br><span class="line">        data[0] &#x3D; data[k];</span><br><span class="line">        while(2*k&lt;&#x3D;end)</span><br><span class="line">        &#123;</span><br><span class="line">            int j &#x3D; 2*k;</span><br><span class="line">            if(j+1&lt;&#x3D;end &amp;&amp; data[j+1]&gt;data[j]) j&#x3D;j+1;</span><br><span class="line">            if(data[0] &gt; data[j]) break;</span><br><span class="line">            data[k] &#x3D; data[j];</span><br><span class="line">            k &#x3D; j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        data[k] &#x3D; data[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T extractMax()</span><br><span class="line">    &#123;</span><br><span class="line">        T ret &#x3D; data[1];</span><br><span class="line">        swap(data[1], data[end]);</span><br><span class="line">        data.pop_back();</span><br><span class="line">        end--;</span><br><span class="line">        shiftDownOpt(1);</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void sort()</span><br><span class="line">    &#123;</span><br><span class="line">        int n &#x3D; end;</span><br><span class="line">        for(int i&#x3D;0; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(extractMax());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        for(T e : data)</span><br><span class="line">            cout &lt;&lt; e &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;T&gt; data;</span><br><span class="line">    vector&lt;T&gt; &amp;temp;    &#x2F;&#x2F; 引用，需要在构造函数之前进行初始化</span><br><span class="line">    int end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; nums &#x3D; &#123;15, 17, 19, 13, 22, 16, 28, 30, 41, 62&#125;;</span><br><span class="line">    MaxHeap&lt;int&gt; maxheap(nums);</span><br><span class="line">    maxheap.insert(25);</span><br><span class="line">    maxheap.sort(); &#x2F;&#x2F; 大根堆输出从大到小的排序</span><br><span class="line"></span><br><span class="line">    for(int e : nums)</span><br><span class="line">        cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结，按照堆的特性，可以知道堆可以进行向上调整和向下调整。插入一个新元素，采用向上调整；删除操作比较麻烦，如果是删除根结点，这个采用向下调整的方案即可，和依次<br>输出大根堆的最大值是一样的。</p>
<h3 id="堆从数组索引0开始存储"><a href="#堆从数组索引0开始存储" class="headerlink" title="堆从数组索引0开始存储"></a>堆从数组索引0开始存储</h3><p>堆从数组索引0开始存储可以用于实现原地堆排序。一般来说，用户提供的数组数据都是从0开始的，如果要按照上一部分进行堆排序，必须重新设置一个数组，将用户提供的数组数据从索引1开始存储，这样增加了空间复杂度。如果能够在用户提供的数组数据的基础上，直接进行原地堆排序，性能也会更好。  </p>
<p>如何进行原地堆排序呢？按照大根堆的做法，我们在对初始化堆之后，此时数组索引0存放的就是数组最大值。将索引0元素与数组最后一个元素交换，这样数组的最大元素就排序好了，然后对剩下的内容进行向下调整，重新构建堆结构。依次按照上述步骤，就可以在原地进行堆排序了。我们知道，堆排序的向上和向下调整都是<font color="red">父节点和子节点</font>之间比较交换的过程，所以研究数组索引0开始存储时，父节点和子节点之间的关系很重要。</p>
<p><img src="/images/09-datastructure-选择排序/02-大根堆.png" alt="&quot;02-大根堆&quot;">  </p>
<ul>
<li>堆在内存中的存储方式是线性数组，当存储的位置是从索引0开始。满足：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parent(i) &#x3D; (i-1)&#x2F;2     (索引为i的结点的父节点的索引 (i-1)&#x2F;2)</span><br><span class="line">left child(i) &#x3D; 2*i+1   (索引为i的结点的左孩子的索引 2*i+1)</span><br><span class="line">right child(i) &#x3D; 2*i+2  (索引为i的结点的右孩子的索引 2*i+2)</span><br><span class="line">最后一个非叶子结点的索引  (end-1)&#x2F;2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void __shiftDown(vector&lt;T&gt;&amp; nums, int k, int n)</span><br><span class="line">&#123;</span><br><span class="line">    while(2*k+1 &lt;&#x3D; n)</span><br><span class="line">    &#123;</span><br><span class="line">        int j &#x3D; 2*k;</span><br><span class="line">        if(j+1&lt;&#x3D;n &amp;&amp; nums[j+1]&gt;nums[j]) j&#x3D;j+1;</span><br><span class="line">        if(nums[k] &gt;&#x3D; nums[j]) break;</span><br><span class="line">        swap(nums[k], nums[j]); &#x2F;&#x2F; 交换操作</span><br><span class="line">        k &#x3D; j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void __shiftDownOpt(vector&lt;T&gt;&amp; nums, int k, int n)</span><br><span class="line">&#123;</span><br><span class="line">    T temp &#x3D; nums[k];</span><br><span class="line">    while(2*k+1 &lt;&#x3D; n)</span><br><span class="line">    &#123;</span><br><span class="line">        int j &#x3D; 2*k;</span><br><span class="line">        if(j+1&lt;&#x3D;n &amp;&amp; nums[j+1]&gt;nums[j]) j&#x3D;j+1;</span><br><span class="line">        if(temp &gt;&#x3D; nums[j]) break; &#x2F;&#x2F; 注意：这里是用temp进行比较</span><br><span class="line">        nums[k] &#x3D; nums[j];</span><br><span class="line">        k &#x3D; j;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[k] &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void heapSort(vector&lt;T&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; [start, end]</span><br><span class="line">    int start&#x3D;0, end&#x3D;nums.size()-1;</span><br><span class="line">    &#x2F;&#x2F; heapify</span><br><span class="line">    for(int i&#x3D;(end-1)&#x2F;2; i&gt;&#x3D;0; i--)</span><br><span class="line">        __shiftDownOpt(nums, i, end);</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;end; i&gt;0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(nums[0], nums[i]);</span><br><span class="line">        __shiftDownOpt(nums, 0, i-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆排序是不稳定的排序。稳定排序：对于相同的元素，在排序后，原来靠前的元素依然靠前。相等元素的相对位置没有发生改变。排序的稳定性和代码实现是相关的，代码实现的<br>不够好，也会导致稳定排序变成不稳定排序。同样，也可以通过自定义比较函数，让排序算法不存在稳定性问题。</p>
<p>// 比如：计算学生成绩，如果遇到相同成绩的学生，为了保证学生顺序不变性，可以增加对学号的比较<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool operator&lt;(const Student&amp; otherStudent)</span><br><span class="line">&#123;</span><br><span class="line">    return score !&#x3D; otherStudent.score ? score &gt; otherStudent.score : id &lt; otherStudent.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="索引堆"><a href="#索引堆" class="headerlink" title="索引堆"></a>索引堆</h3><p>堆经常用来实现优先级队列，优先级队列在操作系统的作业调度和其他领域有广泛的应用。如在操作系统的作业调度中，可以想见一个进程id号绑定一个进程的优先级。</p>
<p><img src="/images/09-datastructure-选择排序/03-大根堆.png" alt="&quot;03-大根堆&quot;"><br><img src="/images/09-datastructure-选择排序/04-大根堆.png" alt="&quot;04-大根堆&quot;">  </p>
<p>以上两图表示对不满足堆结构的数组进行heapify操作后的堆结构数组。可知存在很多问题，比如：如果数组元素很复杂，那么交换这些数组元素就会有很大的性能损失。在比如，将数组的索引看做是进程id号，则可以看出对数组进行heapify之后，数组元素位置发生了改变。进程id号和对应的优先级之间没有关联。这样如果操作系统需要修改对应进程的<br>优先级，就必须通过遍历数组元素的方式，找到对应的优先级进行修改，并且如果数组中多个元素优先级相同，修改对应进程的优先级就无法实现了。</p>
<p>为了解决数组heapify中index和data之间无关联的问题。我们可以构建索引堆，index和data都存储在数组中。构建堆结构的时候比较data，但是交换的是index的值。</p>
<p><img src="/images/09-datastructure-选择排序/01-索引堆.png" alt="&quot;01-索引堆&quot;">  </p>
<p><img src="/images/09-datastructure-选择排序/02-索引堆.png" alt="&quot;02-索引堆&quot;">  </p>
<p>以上两图表示，data值的顺序没有发生改变，index值的顺序发生了改变。一般索引值是int型，交换效率是很高的。这样保持了进程id号和优先级data之间的联系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class IndexMaxHeap</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F; 堆在数组中的存储范围：[1, end]</span><br><span class="line">    IndexMaxHeap(vector&lt;T&gt;&amp; nums):temp(nums)</span><br><span class="line">    &#123;</span><br><span class="line">        index.push_back(0);</span><br><span class="line">        data.push_back(0);</span><br><span class="line">        end &#x3D; 0;</span><br><span class="line">        for(T e : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            end++;</span><br><span class="line">            index.push_back(end);</span><br><span class="line">            data.push_back(e);</span><br><span class="line">            nums.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 构建初始堆</span><br><span class="line">        for(int i&#x3D;end&#x2F;2; i&gt;&#x3D;1; i--)</span><br><span class="line">            shiftDownOpt(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 插入操作</span><br><span class="line">    void insert(T e)</span><br><span class="line">    &#123;</span><br><span class="line">        end++;</span><br><span class="line">        index.push_back(end);</span><br><span class="line">        data.push_back(e);</span><br><span class="line">        shiftUpOpt(end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void shiftUp(int k)</span><br><span class="line">    &#123;</span><br><span class="line">        while(k&gt;1 &amp;&amp; data[index[0]]&gt;data[index[k&#x2F;2]])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(index[k], index[k&#x2F;2]);</span><br><span class="line">            k &#x3D; k&#x2F;2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void shiftUpOpt(int k)</span><br><span class="line">    &#123;</span><br><span class="line">        index[0] &#x3D; index[k];</span><br><span class="line">        while(k&gt;1 &amp;&amp; data[index[0]]&gt;data[index[k&#x2F;2]])</span><br><span class="line">        &#123;</span><br><span class="line">            index[k] &#x3D; index[k&#x2F;2];</span><br><span class="line">            k &#x3D; k&#x2F;2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        index[k] &#x3D; index[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void shiftDown(int k)</span><br><span class="line">    &#123;</span><br><span class="line">        while(2*k &lt;&#x3D; end)</span><br><span class="line">        &#123;</span><br><span class="line">            int j &#x3D; 2*k;</span><br><span class="line">            if(j+1&lt;&#x3D;end &amp;&amp; data[index[j+1]]&gt;data[index[j]]) j&#x3D;j+1;</span><br><span class="line">            if(data[index[0]] &gt; data[index[j]]) break;</span><br><span class="line">            swap(index[k], index[j]);</span><br><span class="line"></span><br><span class="line">            k &#x3D; j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    void shiftDownOpt(int k)</span><br><span class="line">    &#123;</span><br><span class="line">        index[0] &#x3D; index[k];</span><br><span class="line">        while(2*k&lt;&#x3D;end)</span><br><span class="line">        &#123;</span><br><span class="line">            int j &#x3D; 2*k;</span><br><span class="line">            if(j+1&lt;&#x3D;end &amp;&amp; data[index[j+1]]&gt;data[index[j]]) j&#x3D;j+1;</span><br><span class="line">            if(data[index[0]] &gt; data[index[j]]) break;</span><br><span class="line">            index[k] &#x3D; index[j];</span><br><span class="line">            k &#x3D; j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        index[k] &#x3D; index[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T extractMax()</span><br><span class="line">    &#123;</span><br><span class="line">        T ret &#x3D; data[index[1]];</span><br><span class="line">        swap(index[1], index[end]);</span><br><span class="line">        index.pop_back();</span><br><span class="line">        data.pop_back();</span><br><span class="line">        end--;</span><br><span class="line">        shiftDownOpt(1);</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;&#x3D;end; i++)</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        for(T e : index)</span><br><span class="line">            cout &lt;&lt; e &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        for(T e : data)</span><br><span class="line">            cout &lt;&lt; e &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void sort()</span><br><span class="line">    &#123;</span><br><span class="line">        int n &#x3D; end;</span><br><span class="line">        for(int i&#x3D;0; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(extractMax());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 修改某个索引对应的值</span><br><span class="line">    &#x2F;&#x2F; 用户指定的索引是从0开始的</span><br><span class="line">    void change(int i, T e)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 1.修改data值</span><br><span class="line">        data[i+1] &#x3D; e;</span><br><span class="line">        &#x2F;&#x2F; 2.修改data对应的索引在堆中的位置</span><br><span class="line">        &#x2F;&#x2F; 通过遍历的方式找到data索引在索引数组中的位置</span><br><span class="line">        for(int j&#x3D;1; j&lt;&#x3D;end; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(index[j] &#x3D;&#x3D; i+1)</span><br><span class="line">            &#123;</span><br><span class="line">                shiftUpOpt(j);</span><br><span class="line">                shiftDownOpt(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;T&gt; index;</span><br><span class="line">    vector&lt;T&gt; data;</span><br><span class="line">    vector&lt;T&gt; &amp;temp;    &#x2F;&#x2F; 引用，需要在构造函数之前进行初始化</span><br><span class="line">    int end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; nums &#x3D; &#123;15, 17, 19, 13, 22, 16, 28, 30, 41, 62&#125;;</span><br><span class="line">    IndexMaxHeap&lt;int&gt; indexmaxheap(nums);</span><br><span class="line">&#x2F;&#x2F;    indexmaxheap.change(9, 25);</span><br><span class="line">&#x2F;&#x2F;    indexmaxheap.print();</span><br><span class="line">    indexmaxheap.sort();</span><br><span class="line"></span><br><span class="line">    for(int e : nums)</span><br><span class="line">        cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述为构建索引堆的方法，其中实现了对数组data某个元素的修改。根据change函数可以知道，修改某个data的时间复杂度是O(1)。但是，重新构建索引堆，需要先在index数组中变量找到对应的索引，然后将index进行向上调整和向下调整操作。遍历时间复杂度是O(n)。如何能够使得找到对应索引为O(1)呢？那就是采用反向查找的方式。</p>
<p><img src="/images/09-datastructure-选择排序/03-索引堆.png" alt="&quot;03-索引堆&quot;">  </p>
<p>由图可知，index根据data构建的索引堆；data是原始数据；rev是data的索引在索引堆数组中的位置。反向查找，简单来说就是一组：key-value。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index[key] &#x3D; value  &#x2F;&#x2F; index[key] 表示data的索引，通过data的索引可以找到data</span><br><span class="line">rev[value] &#x3D; key    &#x2F;&#x2F; rev[key] 表示index的索引，通过index的索引可以找到data的索引</span><br><span class="line"></span><br><span class="line">index[rev[key]] &#x3D; key</span><br><span class="line">rev[index[key]] &#x3D; key</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class IndexReverseMaxHeap</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    IndexReverseMaxHeap(vector&lt;T&gt;&amp; nums):temp(nums)</span><br><span class="line">    &#123;</span><br><span class="line">        index.push_back(0);</span><br><span class="line">        data.push_back(0);</span><br><span class="line">        rev.push_back(0);</span><br><span class="line">        end &#x3D; 0;</span><br><span class="line">        for(T e : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            end++;</span><br><span class="line">            index.push_back(end);</span><br><span class="line">            data.push_back(e);</span><br><span class="line">            rev.push_back(end);</span><br><span class="line">            nums.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 构建初始堆</span><br><span class="line">        for(int i&#x3D;end&#x2F;2; i&gt;&#x3D;1; i--)</span><br><span class="line">            shiftDownOpt(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 插入操作</span><br><span class="line">    void insert(T e)</span><br><span class="line">    &#123;</span><br><span class="line">        end++;</span><br><span class="line">        index.push_back(end);</span><br><span class="line">        data.push_back(e);</span><br><span class="line">        rev.push_back(end);</span><br><span class="line">        shiftUpOpt(end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void shiftUp(int k)</span><br><span class="line">    &#123;</span><br><span class="line">        while(k&gt;1 &amp;&amp; data[index[0]]&gt;data[index[k&#x2F;2]])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(index[k], index[k&#x2F;2]);</span><br><span class="line">            rev[index[k]] &#x3D; k;</span><br><span class="line">            rev[index[k&#x2F;2]] &#x3D; k&#x2F;2;</span><br><span class="line">            k &#x3D; k&#x2F;2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void shiftUpOpt(int k)</span><br><span class="line">    &#123;</span><br><span class="line">        index[0] &#x3D; index[k];</span><br><span class="line">        while(k&gt;1 &amp;&amp; data[index[0]]&gt;data[index[k&#x2F;2]])</span><br><span class="line">        &#123;</span><br><span class="line">            index[k] &#x3D; index[k&#x2F;2];</span><br><span class="line">            rev[index[k]] &#x3D; k;</span><br><span class="line">            k &#x3D; k&#x2F;2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        index[k] &#x3D; index[0];</span><br><span class="line">        rev[index[k]] &#x3D; k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void shiftDown(int k)</span><br><span class="line">    &#123;</span><br><span class="line">        while(2*k &lt;&#x3D; end)</span><br><span class="line">        &#123;</span><br><span class="line">            int j &#x3D; 2*k;</span><br><span class="line">            if(j+1&lt;&#x3D;end &amp;&amp; data[index[j+1]]&gt;data[index[j]]) j&#x3D;j+1;</span><br><span class="line">            if(data[index[0]] &gt; data[index[j]]) break;</span><br><span class="line">            swap(index[k], index[j]);</span><br><span class="line"></span><br><span class="line">            rev[index[k]] &#x3D; k;</span><br><span class="line">            rev[index[j]] &#x3D; j;</span><br><span class="line"></span><br><span class="line">            k &#x3D; j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void shiftDownOpt(int k)</span><br><span class="line">    &#123;</span><br><span class="line">        index[0] &#x3D; index[k];</span><br><span class="line">        while(2*k&lt;&#x3D;end)</span><br><span class="line">        &#123;</span><br><span class="line">            int j &#x3D; 2*k;</span><br><span class="line">            if(j+1&lt;&#x3D;end &amp;&amp; data[index[j+1]]&gt;data[index[j]]) j&#x3D;j+1;</span><br><span class="line">            if(data[index[0]] &gt; data[index[j]]) break;</span><br><span class="line">            index[k] &#x3D; index[j];</span><br><span class="line">            rev[index[k]] &#x3D; k;</span><br><span class="line">            k &#x3D; j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        index[k] &#x3D; index[0];</span><br><span class="line">        rev[index[k]] &#x3D; k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T extractMax()</span><br><span class="line">    &#123;</span><br><span class="line">        T ret &#x3D; data[index[1]];</span><br><span class="line"></span><br><span class="line">        swap(index[1], index[end]);</span><br><span class="line">        rev[index[1]] &#x3D; 1;</span><br><span class="line">        rev[index[end]] &#x3D; end;</span><br><span class="line"></span><br><span class="line">        index.pop_back();</span><br><span class="line">        data.pop_back();</span><br><span class="line">        rev.pop_back();</span><br><span class="line">        end--;</span><br><span class="line">        shiftDownOpt(1);</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;&#x3D;end; i++)</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        for(T e : index)</span><br><span class="line">            cout &lt;&lt; e &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        for(T e : data)</span><br><span class="line">            cout &lt;&lt; e &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        for(T e : rev)</span><br><span class="line">            cout &lt;&lt; e &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void sort()</span><br><span class="line">    &#123;</span><br><span class="line">        int n &#x3D; end;</span><br><span class="line">        for(int i&#x3D;0; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(extractMax());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 修改某个索引对应的值</span><br><span class="line">    &#x2F;&#x2F; 用户指定的索引是从0开始的</span><br><span class="line">    void change(int i, T e)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 1.修改data值</span><br><span class="line">        data[i+1] &#x3D; e;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2.找到data在索引堆中索引的位置</span><br><span class="line">        shiftUp(rev[i+1]);</span><br><span class="line">        shiftDown(rev[i+1]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;T&gt; index;</span><br><span class="line">    vector&lt;T&gt; data;</span><br><span class="line">    vector&lt;T&gt; rev;</span><br><span class="line">    vector&lt;T&gt; &amp;temp;    &#x2F;&#x2F; 引用，需要在构造函数之前进行初始化</span><br><span class="line">    int end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; nums &#x3D; &#123;15, 17, 19, 13, 22, 16, 28, 30, 41, 62&#125;;</span><br><span class="line">    IndexReverseMaxHeap&lt;int&gt; indexrevrsemaxheap(nums);</span><br><span class="line">&#x2F;&#x2F;    indexrevrsemaxheap.change(9, 25);</span><br><span class="line">&#x2F;&#x2F;    indexrevrsemaxheap.print();</span><br><span class="line">    indexrevrsemaxheap.sort();</span><br><span class="line"></span><br><span class="line">    for(int e : nums)</span><br><span class="line">        cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用堆实现优先队列。比如在1000000个元素中选出前100名，就可以通过堆的方式，先从所有1000000个元素中选择100个元素构建堆，然后依次将剩下的元素放入这个100个元素的堆中，这样的时间复杂度为O(NlogM)。<br>使用堆实现多路归并排序。多路归并时，将多路元素放入堆中选出最大或者最小的元素。<br>实现d叉堆其实和二叉堆是一样的操作。原因在于向上调整和向下调整都只影响一个分支。</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>内部排序</category>
      </categories>
      <tags>
        <tag>选择排序</tag>
      </tags>
  </entry>
  <entry>
    <title>10-datastructure-归并排序</title>
    <url>/2019/11/30/10-datastructure-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据结构中，排序可以分为内部排序和外部排序。内部排序可以划分为插入排序、交换排序、选择排序、归并排序等。本文主要记录归并排序算法。<br><a id="more"></a></p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>归并操作原理(对应_merge函数)：</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>重复步骤3直到某一指针超出序列尾，最后将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 归并排序</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void __merge(vector&lt;T&gt;&amp; nums, int left, int mid, int right)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; left, j &#x3D; mid+1;</span><br><span class="line">    vector&lt;T&gt; temp;</span><br><span class="line">    &#x2F;&#x2F; 复制和比较数组中的元素</span><br><span class="line">    for (int i&#x3D;left; i&lt;&#x3D;right; i++)</span><br><span class="line">        temp.push_back(nums[i]);</span><br><span class="line"></span><br><span class="line">    for (int k&#x3D;left; k&lt;&#x3D;right; k++) &#x2F;&#x2F; 修改原数组中的值</span><br><span class="line">    &#123;</span><br><span class="line">        if (i &gt; mid)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[k] &#x3D; temp[j-left];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (j &gt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[k] &#x3D; temp[i-left];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (temp[i-left] &lt; temp[j-left])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[k] &#x3D; temp[i-left];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            nums[k] &#x3D; temp[j-left];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void __mergeSort(vector&lt;T&gt;&amp; nums, int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">    if (left &gt;&#x3D; right)</span><br><span class="line">        return;</span><br><span class="line">    int mid &#x3D; (right-left)&#x2F;2 + left;</span><br><span class="line">    __mergeSort(nums, left, mid);</span><br><span class="line">    __mergeSort(nums, mid+1, right);</span><br><span class="line">    __merge(nums, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void mergeSort(vector&lt;T&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line">    int start &#x3D; 0, end &#x3D; nums.size()-1;</span><br><span class="line">    __mergeSort(nums, start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void __merge(vector&lt;T&gt;&amp; nums, int left, int mid, int right)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; left, j &#x3D; mid+1;</span><br><span class="line">    vector&lt;T&gt; temp;</span><br><span class="line">    &#x2F;&#x2F; 复制和比较数组中的元素</span><br><span class="line">    for (int i&#x3D;left; i&lt;&#x3D;right; i++)</span><br><span class="line">        temp.push_back(nums[i]);</span><br><span class="line"></span><br><span class="line">    for (int k&#x3D;left; k&lt;&#x3D;right; k++) &#x2F;&#x2F; 修改原数组中的值</span><br><span class="line">    &#123;</span><br><span class="line">        if (i &gt; mid)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[k] &#x3D; temp[j-left];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (j &gt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[k] &#x3D; temp[i-left];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (temp[i-left] &lt; temp[j-left])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[k] &#x3D; temp[i-left];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            nums[k] &#x3D; temp[j-left];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void __mergeInsertSortOpt(vector&lt;T&gt;&amp; nums, int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">    int start &#x3D; left, end &#x3D; right+1;</span><br><span class="line">    for (int i&#x3D;1; i&lt;end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        T temp &#x3D; nums[i];</span><br><span class="line">        int j;</span><br><span class="line"></span><br><span class="line">        for (j&#x3D;i; j&gt;0 &amp;&amp; nums[j-1]&gt;temp; j--)</span><br><span class="line">            nums[j] &#x3D; nums[j-1];</span><br><span class="line"></span><br><span class="line">        nums[j] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void __mergeSortOpt(vector&lt;T&gt;&amp; nums, int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">    if (right-left &lt;&#x3D; 15)</span><br><span class="line">    &#123;</span><br><span class="line">        __mergeInsertSortOpt(nums, left, right);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int mid &#x3D; (right-left)&#x2F;2 + left;</span><br><span class="line">    __mergeSort(nums, left, mid);</span><br><span class="line">    __mergeSort(nums, mid+1, right);</span><br><span class="line">    if (nums[mid] &gt; nums[mid+1])</span><br><span class="line">        __merge(nums, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void mergeSortOpt(vector&lt;T&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line">    int start &#x3D; 0, end &#x3D; nums.size()-1;</span><br><span class="line">    __mergeSortOpt(nums, start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>根据每次归并1，2，4，8，…自底向上的编程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void mergeSortBU(vector&lt;T&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line">    int start &#x3D; 0, end &#x3D; nums.size();</span><br><span class="line">    &#x2F;&#x2F; 外层循环每执行一次为原来的两倍；此时如果interval &gt; end就退出循环</span><br><span class="line">    for (int interval&#x3D;1; interval&lt;end; interval+&#x3D;interval)</span><br><span class="line">        &#x2F;&#x2F; 左边界 i &lt;&#x3D; end-1</span><br><span class="line">		&#x2F;&#x2F; 中值 i+interval-1 &lt; end-1 --&gt; i &lt; end-interval 这样至少 end-1 属于right</span><br><span class="line">		&#x2F;&#x2F; 右边界通过min(i+interval+interval-1, end-1) 限定</span><br><span class="line">        for (int i&#x3D;0; i&lt;end-interval; i+&#x3D;(interval+interval))</span><br><span class="line">            __merge(nums, i, i+interval-1, min(i+interval+interval-1, end-1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用-求逆序对"><a href="#应用-求逆序对" class="headerlink" title="应用-求逆序对"></a>应用-求逆序对</h2><ol>
<li>归并排序递归</li>
<li>在合并归并排序后的两部分时，会比较左右两部分的值的大小，由此可以确定逆序对的数目</li>
<li>逆序对的数目等于：左边排序好部分的逆序数 + 右边排序好部分的逆序数 + 左右部分合并部分的逆序数</li>
<li>如果左侧部分的值nums[left]大于右侧部分的值nums[right]，则左边排序中nums[left]之后的数都与nums[right]构成逆序对</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">long long __inversionMerge(vector&lt;T&gt;&amp; nums, int left, int mid, int right)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;T&gt; temp;</span><br><span class="line">    for(int i&#x3D;left; i&lt;&#x3D;right; i++)</span><br><span class="line">        temp.push_back(nums[i]);</span><br><span class="line"></span><br><span class="line">    long long ret &#x3D; 0;</span><br><span class="line">    int i&#x3D;left, j&#x3D;mid+1;</span><br><span class="line">    for(int k&#x3D;left; k&lt;&#x3D;right; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i&gt;mid)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[k]&#x3D;temp[j-left];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(j&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[k]&#x3D;temp[i-left];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(temp[i-left]&lt;&#x3D;temp[j-left])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[k] &#x3D; temp[i-left];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            nums[k] &#x3D; temp[j-left];</span><br><span class="line">            j++;</span><br><span class="line"></span><br><span class="line">            ret +&#x3D; (long long)(mid-i+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">long long __inversionCount(vector&lt;T&gt;&amp; nums, int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">    if (left &gt;&#x3D; right)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int mid &#x3D; (right-left)&#x2F;2 + left;</span><br><span class="line">    long long lret &#x3D; __inversionCount(nums, left, mid);</span><br><span class="line">    long long rret &#x3D; __inversionCount(nums, mid+1, right);</span><br><span class="line"></span><br><span class="line">    return lret+rret+__inversionMerge(nums, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">long long inversionCount(vector&lt;T&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line">    int start&#x3D;0, end&#x3D;nums.size()-1;</span><br><span class="line">    long long ret &#x3D; __inversionCount(nums, start, end);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
      <categories>
        <category>数据结构</category>
        <category>内部排序</category>
      </categories>
      <tags>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>12-leetcode-数组二</title>
    <url>/2019/11/30/12-leetcode-%E6%95%B0%E7%BB%84%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a>
<h1 id="旋转排序数组"><a href="#旋转排序数组" class="headerlink" title="旋转排序数组"></a>旋转排序数组</h1><h2 id="旋转排序数组的性质"><a href="#旋转排序数组的性质" class="headerlink" title="旋转排序数组的性质"></a>旋转排序数组的性质</h2><ul>
<li>二分之后一定是一半有序，一半无序</li>
</ul>
<h2 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">搜索旋转排序数组</a></h2><ul>
<li>数组中不存在重复元素。进行二分的时候，数组一定是一半有序的，一半无序。<br>根据 有序部分的 start 和 end 判断目标值是否在有序部分，否则在无序部分。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 时间复杂度 O(logn) 空间复杂度 O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int start &#x3D; 0, end &#x3D; nums.size() - 1, mid;</span><br><span class="line">        while (start &lt;&#x3D; end) &#123;</span><br><span class="line">            mid &#x3D; (start + end) &#x2F; 2;</span><br><span class="line">            if (nums[mid] &#x3D;&#x3D; target)</span><br><span class="line">                return mid;</span><br><span class="line">            else if (nums[start] &lt;&#x3D; nums[mid])	&#x2F;&#x2F; 前半段递增 注意等号(等号与左半部分结合)</span><br><span class="line">            &#123;</span><br><span class="line">                if (nums[start] &lt;&#x3D; target &amp;&amp; nums[mid] &gt; target)</span><br><span class="line">                    end &#x3D; mid - 1;</span><br><span class="line">                else</span><br><span class="line">                    start &#x3D; mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (nums[end] &gt;&#x3D; target &amp;&amp; nums[mid] &lt; target)	&#x2F;&#x2F; 后半段递增</span><br><span class="line">                    start &#x3D; mid + 1;</span><br><span class="line">                else</span><br><span class="line">                    end &#x3D; mid - 1;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="搜索旋转排序数组-II"><a href="#搜索旋转排序数组-II" class="headerlink" title="搜索旋转排序数组 II"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">搜索旋转排序数组 II</a></h2><ul>
<li>数组中存在重复元素，进行二分的时候，数组一定是一半有序的，一半无序。<br>根据 有序部分的 start 和 end 判断目标值是否在有序部分，否则在无序部分。存在一种特殊情况<br>如果 num[start] = nums[mid] = nums[end]，此时无法判断数组哪边是升序，哪边是降序。有解决这个问题，<br>可以 破环这个状态，num[start] = nums[mid] 必定有二分的两部分数组中，有一部分值全部相等，<br>而另一部分存在 目标值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        if(nums.size() &#x3D;&#x3D; 0) return false;</span><br><span class="line"></span><br><span class="line">        int start &#x3D; 0, end &#x3D; nums.size() - 1;</span><br><span class="line">        int mid &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        while(start &lt;&#x3D; end)&#123;</span><br><span class="line">            mid &#x3D; (start + end) &#x2F; 2;</span><br><span class="line">            if(nums[mid] &#x3D;&#x3D; target)</span><br><span class="line">                return true;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 去重 经过这个判断，一定可以知道哪一方有序</span><br><span class="line">            &#x2F;&#x2F; 由上可知 num[mid] &#x3D;&#x3D; nums[start] 都不是 target 可以舍去</span><br><span class="line">            &#x2F;&#x2F; nums[mid] &#x3D;&#x3D; nums[start] &#x3D; nums[end]时无法判断哪边有序</span><br><span class="line">            if(nums[mid] &#x3D;&#x3D; nums[start])&#123;</span><br><span class="line">                start++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(nums[mid] &gt; nums[start])&#123;  &#x2F;&#x2F; 如果大于成立，说明左半递增；如果等于不一定成立</span><br><span class="line">                if(nums[mid] &gt; target &amp;&amp; nums[start] &lt;&#x3D; target)</span><br><span class="line">                    end &#x3D; mid - 1;</span><br><span class="line">                else</span><br><span class="line">                    start &#x3D; mid + 1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(nums[mid] &lt; target &amp;&amp; nums[end] &gt;&#x3D; target)</span><br><span class="line">                    start &#x3D; mid + 1;</span><br><span class="line">                else</span><br><span class="line">                    end &#x3D; mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="寻找旋转排序数组中的最小值"><a href="#寻找旋转排序数组中的最小值" class="headerlink" title="寻找旋转排序数组中的最小值"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a></h2><ul>
<li>旋转之后，最小值之后的元素都小于数组最后的元素。如果数组没有旋转也成立。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMin(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size() &#x3D;&#x3D; 0)    return -1;</span><br><span class="line">        int start &#x3D; 0, end &#x3D; nums.size() - 1;</span><br><span class="line">        int mid &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 两边逼近，最后一定会有 start &#x3D; end</span><br><span class="line">        while(start &lt; end)&#123;</span><br><span class="line">            mid &#x3D; start + (end - start) &#x2F; 2;</span><br><span class="line">            if(nums[mid] &lt; nums[end])</span><br><span class="line">                end &#x3D; mid;</span><br><span class="line">            else</span><br><span class="line">                start &#x3D; mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>旋转之后，最小值之后的所有元素都小于第一个元素。如果数组没有旋转，该性质不成立，需要特判</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMin(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size() &#x3D;&#x3D; 0)    return -1;</span><br><span class="line">        if(nums.front() &lt; nums.back()) return nums.front();</span><br><span class="line">        int start &#x3D; 0, end &#x3D; nums.size() - 1;</span><br><span class="line">        int mid &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 两边逼近，最后一定会有 start &#x3D; end</span><br><span class="line">        while(start &lt; end)&#123;</span><br><span class="line">            mid &#x3D; start + (end - start) &#x2F; 2;</span><br><span class="line">            if(nums[mid] &lt; nums.front())</span><br><span class="line">                end &#x3D; mid;</span><br><span class="line">            else</span><br><span class="line">                start &#x3D; mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="寻找旋转排序数组中的最小值-II"><a href="#寻找旋转排序数组中的最小值-II" class="headerlink" title="寻找旋转排序数组中的最小值 II"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值 II</a></h2><ul>
<li>寻找旋转排序数组的旋转点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMin(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size() &#x3D;&#x3D; 0)    return -1;</span><br><span class="line">        int start &#x3D; 0, end &#x3D; nums.size() - 1;</span><br><span class="line">        int mid &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 两边逼近，最后一定会有 start &#x3D; end</span><br><span class="line">        while(start &lt; end)&#123;</span><br><span class="line">            mid &#x3D; start + (end - start) &#x2F; 2;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; nums[start] &#x3D;&#x3D; nums[mid] 可能就是最小值</span><br><span class="line">            &#x2F;&#x2F; 如果没有 start !&#x3D; mid 会把这个最小值跳过</span><br><span class="line">            if(nums[start] &#x3D;&#x3D; nums[mid] &amp;&amp; start !&#x3D; mid)&#123;</span><br><span class="line">                start++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 程序运行到这里，nums[mid] &#x3D;&#x3D; nums[end]时</span><br><span class="line">            &#x2F;&#x2F; mid 和 end 之间的数都相等 </span><br><span class="line">            if(nums[mid] &lt;&#x3D; nums[end])</span><br><span class="line">                end &#x3D; mid;</span><br><span class="line">            else</span><br><span class="line">                start &#x3D; mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>旋转排序数组问题主要要抓住二分查找后一半有序，一半无序的特点。以及旋转点具有的特殊性质。</p>
<h1 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">移动零</a></h1><ul>
<li>双指针</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int prev &#x3D; 0, next &#x3D; 0;</span><br><span class="line">        int k &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; prev指向需要赋值内存空间</span><br><span class="line">        while( next &lt;&#x3D; nums.size()-1)&#123;</span><br><span class="line">            if(nums[next] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                next++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                nums[prev++] &#x3D; nums[next++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;  for(int i&#x3D;0; i&lt;&#x3D;k; i++)&#123;      &#x2F;&#x2F; 越界</span><br><span class="line">        for(int i&#x3D;0; i&lt;k; i++)&#123;</span><br><span class="line">            nums[prev+i] &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>双指针优化一</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int index &#x3D; 0;      &#x2F;&#x2F; nums 中，[0...index)之间的元素为非零元素</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 遍历到第i个元素，保证[0...i]中所有非0元素</span><br><span class="line">        &#x2F;&#x2F; 都按照顺序排列在[0...index)中</span><br><span class="line">        for(int i&#x3D;0; i&lt;nums.size(); i++)</span><br><span class="line">            if(nums[i] !&#x3D; 0)</span><br><span class="line">                nums[index++] &#x3D; nums[i];</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;index; i&lt;nums.size(); i++)</span><br><span class="line">            nums[i] &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>双指针优化二</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int index &#x3D; 0;      &#x2F;&#x2F; nums 中，[0...index)之间的元素为非零元素</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 遍历到第i个元素，保证[0...i]中所有非0元素</span><br><span class="line">        &#x2F;&#x2F; 都按照顺序排列在[0...index)中</span><br><span class="line">        &#x2F;&#x2F; 同时 [index...i]为0</span><br><span class="line">        for(int i&#x3D;0; i&lt;nums.size(); i++)</span><br><span class="line">            if(nums[i] !&#x3D; 0)</span><br><span class="line">                if(index !&#x3D; i)    &#x2F;&#x2F; 考虑数组中都是非零元素</span><br><span class="line">                    swap(nums[index++], nums[i]);</span><br><span class="line">                else</span><br><span class="line">                    index++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">颜色分类</a></h1><ul>
<li>暴力解法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int count[3] &#x3D; &#123;0&#125;;</span><br><span class="line">        for(int i&#x3D;0; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            assert( nums[i] &gt;&#x3D; 0 &amp;&amp; nums[i] &lt;&#x3D; 2);</span><br><span class="line">            count[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line">        for(int i&#x3D;0; i&lt;count[0]; i++)&#123;</span><br><span class="line">            nums[index++] &#x3D; 0; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i&#x3D;0; i&lt;count[1]; i++)&#123;</span><br><span class="line">            nums[index++] &#x3D; 1; </span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        for(int i&#x3D;0; i&lt;count[2]; i++)&#123;</span><br><span class="line">            nums[index++] &#x3D; 2; </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>三路快排<br>直接使用三路快排</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int start &#x3D; 0, end &#x3D; nums.size() - 1;</span><br><span class="line"></span><br><span class="line">        _sortColors(nums, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void _sortColors(vector&lt;int&gt;&amp; nums, int left, int right)&#123;</span><br><span class="line">        if(left &gt;&#x3D; right)   return;</span><br><span class="line"></span><br><span class="line">        int lt &#x3D; left, gt &#x3D; right + 1;</span><br><span class="line">        int i &#x3D; left + 1;</span><br><span class="line">        int pivotValue &#x3D; nums[left];</span><br><span class="line">        &#x2F;&#x2F; [left+1, lt] &lt;　pivotValue [lt+1, gt-1] &#x3D;&#x3D; pivotValue [gt, right] &gt; pivotValue</span><br><span class="line">        while( i &lt; gt )&#123;</span><br><span class="line">            if( nums[i] &lt; pivotValue )</span><br><span class="line">                swap( nums[++lt], nums[i++] );</span><br><span class="line">            else if( nums[i] &#x3D;&#x3D; pivotValue )</span><br><span class="line">                i++;</span><br><span class="line">            else</span><br><span class="line">                swap( nums[i], nums[--gt] );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; [left, lt-1] &lt;　pivotValue [lt, gt-1] &#x3D;&#x3D; pivotValue [gt, right] &gt; pivotValue</span><br><span class="line">        swap( nums[left], nums[lt] );</span><br><span class="line">        _sortColors(nums, left, lt-1);</span><br><span class="line">        _sortColors(nums, gt, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>三路快排引申，三路快排的思想就是根据一个基准值，将数组分为大于基准值和小于基准值两部分。由于本题中只有 0,1,2 三个数字，<br>也就是说如果我们指定基准值为 1，就可以一次将数组排序好。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int zero &#x3D; -1, two &#x3D; nums.size();   &#x2F;&#x2F; zero 和 two 开始是空集</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        while( i &lt; two )&#123;   &#x2F;&#x2F; i 和 two 逼近 [zero+1, two-1]为 1, [two, nums.size()]为 2</span><br><span class="line">            if( nums[i] &lt; 1 )</span><br><span class="line">                swap( nums[++zero], nums[i++] );</span><br><span class="line">            else if( nums[i] &#x3D;&#x3D; 1 )</span><br><span class="line">                i++;</span><br><span class="line">            else</span><br><span class="line">                swap( nums[i], nums[--two] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">合并两个有序数组</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        int index &#x3D; m + n - 1, index1 &#x3D; m - 1, index2 &#x3D; n - 1;</span><br><span class="line">        while(index1 &gt;&#x3D; 0 &amp;&amp; index2 &gt;&#x3D; 0)</span><br><span class="line">            nums1[index--] &#x3D; nums1[index1] &gt; nums2[index2] ? nums1[index1--] : nums2[index2--];</span><br><span class="line"></span><br><span class="line">        while(index2 &gt;&#x3D; 0)</span><br><span class="line">            nums1[index--] &#x3D; nums2[index2--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>14-datastructure-二叉树</title>
    <url>/2019/12/02/14-datastructure-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a>
<h1 id="二叉排序-搜索-树-BST树"><a href="#二叉排序-搜索-树-BST树" class="headerlink" title="二叉排序(搜索)树(BST树)"></a>二叉排序(搜索)树(BST树)</h1><p>树是N(N≥0)个结点的有限集合，N=0时，称为空树。在任意一棵非空树中应满足：</p>
<ul>
<li>有且仅有一个特定的称为根的结点</li>
<li>当N&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集合，其中每一个集合本身又是一棵树，并且成为根结点的子树。</li>
</ul>
<p>由上可知，树的定义是递归的，是一种递归的数据结构。树作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点：</p>
<ul>
<li>树的根结点没有前驱结点，除根结点之外的所有结点有且只有一个前驱结点。</li>
<li>树中所有结点可以有零个或者多个后继结点。</li>
</ul>
<p>树适合表示具有层次结构的数据。树中的某个结点(除根结点外)最多只和上一层的一个结点(即其父节点)有直接关系，根结点没有上层结点。因此在n个结点的树中有n-1条边。而树中每个结点与其下一层的零个或者多个结点(即其子女结点)有直接关系。</p>
<p>树中一个结点的子结点个数称为该结点的度，树中结点的最大度数称为树的度。</p>
<p>二叉树是每个结点至多只有两棵子树(即二叉树中不存在度大于2的结点)，二叉树的子树有左右之分，其次序不能颠倒。</p>
<p><img src="/images/14-datastructure-二叉树/01-二叉树.png" alt="&quot;01-二叉树&quot;"></p>
<p>二叉树是有序树，若将其左右子树颠倒，就成为另一棵不同的二叉树。特殊的二叉树包括：满二叉树，完全二叉树，二叉排序树(BST)，平衡二叉树(AVL)，红黑树等。    </p>
<p>二叉树与度为2的有序树的区别：</p>
<ul>
<li>度为2的树至少有3个结点，而二叉树可以为空；</li>
<li>度为2的有序树的孩子结点的左右次序是相对于另一个孩子结点的，如果某个结点只有一个孩子结点，这个孩子结点无须区分其左右次序。而二叉树需要区分左右次序。</li>
</ul>
<p>二叉树可以采用顺序存储结构，也可以采用链式存储结构。对于满二叉树和完全二叉树，采用顺序存储空间利用率高，而且可以根据数组下标反映二叉树中结点之间的逻辑关系。<br>但是对于一般的二叉树，为使数组下标反映二叉树中结点之间的逻辑关系，只能添加一些并不存在的空结点让其每个结点与完全二叉树上的结点相对照，在存储到一维数组的相应分量中，这样的空间利用率不高。<br>二叉树更通用的方式是采用链式存储结构。链式结构指用一个链表来存储一棵二叉树，二叉树中每一个结点用链表的一个链接点来存储。在二叉树中，结点结构通常包括若干数据域和若干指针域。二叉链表至少包含3个域：数据域data、左指针域lchild和右指针域rchild。如果用二叉树存储字典数据结构，此时数据域包括key-value。</p>
<ul>
<li>堆和二叉树的区别：<br>以小根堆为例，堆的特点是双亲结点的关键字必然小于等于孩子结点的关键字，而两个孩子结点的关键字没有次序规定，而二叉排序数中，每个双亲结点的关键字均大于左子树结点的关键字，均小于右子树j结点的关键字，也就是说，每个双亲结点的左右孩子的关键字有次序关系，这样，当对两种树执行中序遍历后，二叉树会得到一个有序的序列，而堆不一定。</li>
</ul>
<h2 id="二叉排序-搜索-树的遍历"><a href="#二叉排序-搜索-树的遍历" class="headerlink" title="二叉排序(搜索)树的遍历"></a>二叉排序(搜索)树的遍历</h2><p>二叉树的遍历，是指按某条搜索路径访问树中的每个结点，使得每个结点均被访问一次，而且仅被访问一次。由二叉树的递归定义，遍历一棵二叉树便要决定对根结点(N)、左子树(L)、右子树(R)的访问顺序。按照先遍历左子树再遍历右子树的原则，常见的遍历次序有先序(NLR)、中序(LNR)和后序(LRN)三种。<font color="red">其中，序指的是根结点在何时被访问</font>。</p>
<p>先序遍历方式也可以认为是深度优先遍历方式。深度优先遍历方式的基本思想如下：首先访问图中某一起始顶点v,然后由v出发，访问与v邻接且未被访问的任一顶点$w_1$，再访问与$w_1$邻接且未被访问的任一顶点$w_2$，…，重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直到图中所有顶点均被访问过为止。</p>
<h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>先序遍历操作过程：<br>如果二叉树为空，什么也不做。否则：</p>
<ul>
<li>访问根结点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
</ul>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中序遍历操作过程：<br>如果二叉树为空，什么也不做。否则：</p>
<ul>
<li>中序遍历左子树</li>
<li>访问根结点</li>
<li>中序遍历右子树</li>
</ul>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>后序遍历操作过程：<br>如果二叉树为空，什么也不做。否则：</p>
<ul>
<li>后序遍历左子树</li>
<li>后序遍历右子树</li>
<li>访问根结点</li>
</ul>
<p>三种遍历算法中递归遍历左右子树的顺序都是固定的，只是访问根结点的顺序不同。不管采用那种遍历算法，每个结点都访问一次且仅访问一次，故时间复杂度都是O(n)。</p>
<h2 id="二叉排序-搜索-树的查找与删除"><a href="#二叉排序-搜索-树的查找与删除" class="headerlink" title="二叉排序(搜索)树的查找与删除"></a>二叉排序(搜索)树的查找与删除</h2><h3 id="最大值和最小值"><a href="#最大值和最小值" class="headerlink" title="最大值和最小值"></a>最大值和最小值</h3><p>二叉树的最小值是左子树最左侧分支中没有左孩子的结点。<br>二叉树的最大值是右子树最右侧分支中没有右孩子的结点。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ol>
<li>如果被删除结点是叶结点，则直接删除。</li>
<li>如果被删除结点Z只有一棵左子树或右子树，则让Z的子树称为Z父结点的子树，代替Z的位置。</li>
<li>如果被删除结点Z有左、右两棵子树，则令Z的直接后继(或者直接前驱)替代Z，然后从二叉树中删除这个直接后继(或直接前驱)，这样就转换成了第一或第二种情况。<br>直接后继就是删除结点右子树中的最小值；直接前驱就是删除结点左子树中的最大值。</li>
</ol>
<h2 id="二叉树的其他操作"><a href="#二叉树的其他操作" class="headerlink" title="二叉树的其他操作"></a>二叉树的其他操作</h2><h3 id="ceil和floor"><a href="#ceil和floor" class="headerlink" title="ceil和floor"></a>ceil和floor</h3><h3 id="rank和ceil"><a href="#rank和ceil" class="headerlink" title="rank和ceil"></a>rank和ceil</h3>]]></content>
      <categories>
        <category>数据结构</category>
        <category>查找</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>13-datastructure-二分查找</title>
    <url>/2019/12/01/13-datastructure-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>查找算法有很多种，常用的有顺序查找，二分查找，分块查找，树表查找，哈希查找等。本文介绍二分查找。<br><a id="more"></a></p>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><ul>
<li>区间为[start, end]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 非递归方式</span><br><span class="line">int binarySearch(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">    int start &#x3D; 0, end &#x3D; nums.size() - 1, mid;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 二分查找 mid向左取整	</span><br><span class="line">    while (start &lt;&#x3D; end) &#123;		&#x2F;&#x2F; [start, end]</span><br><span class="line">        &#x2F;&#x2F;mid &#x3D; (start + end) &#x2F; 2;	&#x2F;&#x2F; start 和 end 足够大的话会产生溢出</span><br><span class="line">        mid &#x3D; start + (end - start) &#x2F; 2;</span><br><span class="line"></span><br><span class="line">        if (nums[mid] &#x3D;&#x3D; target)</span><br><span class="line">            return mid;</span><br><span class="line">        else if (nums[mid] &gt; target)</span><br><span class="line">            end &#x3D; mid - 1;</span><br><span class="line">        else</span><br><span class="line">            start &#x3D; mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 递归方式</span><br><span class="line">&#x2F;&#x2F; 三要素：明确函数功能；寻找递归结束条件；找出函数的等价关系式，不断缩小参数范围</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">int __binarySearchWithRecursion(vector&lt;T&gt;&amp; nums, int left, int right, T target)</span><br><span class="line">&#123;</span><br><span class="line">    if(left &gt; right)    &#x2F;&#x2F; 循环终止条件</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    int mid &#x3D; left + (right-left) &#x2F; 2;</span><br><span class="line">    if(nums[mid] &#x3D;&#x3D; target)</span><br><span class="line">        return mid;</span><br><span class="line">    else if(nums[mid] &gt; target)</span><br><span class="line">        return __binarySearchWithRecursion(nums, left, mid-1, target);  &#x2F;&#x2F; 不断缩小参数范围</span><br><span class="line">    else</span><br><span class="line">        return __binarySearchWithRecursion(nums, mid+1, right, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">int binarySearchWithRecursion(vector&lt;T&gt;&amp; nums, T target)</span><br><span class="line">&#123;</span><br><span class="line">    int start &#x3D; 0, end &#x3D; nums.size()-1;</span><br><span class="line"></span><br><span class="line">    return __binarySearchWithRecursion(nums, start, end, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>区间为[start, end)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int binarySearch(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">    int start &#x3D; 0, end &#x3D; nums.size(), mid;</span><br><span class="line">    &#x2F;&#x2F; 二分查找 mid向左取整	</span><br><span class="line">    while (start &lt; end) &#123;		&#x2F;&#x2F; [start, end）</span><br><span class="line">        &#x2F;&#x2F;mid &#x3D; (start + end) &#x2F; 2;	&#x2F;&#x2F; start 和 end 足够大的话会产生溢出</span><br><span class="line">        mid &#x3D; start + (end - start) &#x2F; 2;</span><br><span class="line">        if (nums[mid] &#x3D;&#x3D; target)</span><br><span class="line">            return mid;</span><br><span class="line">        else if (nums[mid] &gt; target)	</span><br><span class="line">            end &#x3D; mid;			&#x2F;&#x2F; [start, end)</span><br><span class="line">        else</span><br><span class="line">            start &#x3D; mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分查找规律总结"><a href="#二分查找规律总结" class="headerlink" title="二分查找规律总结"></a>二分查找规律总结</h2><ol>
<li><p>奇数列：mid 为整数; 偶序列：mid 向左取整<br>如果是奇序列，len(左侧序列) = len(右侧序列)。<br>如果是偶序列，len(左侧序列) + 1 = len(右侧序列)。<br>比如：<br>奇序列：1 2 3 4 5 6 7 8 9 —-&gt; 中间数为5 左侧序列 1 2 3 4 右侧序列 6 7 8 9<br>偶序列：1 2 3 4 5 6 7 8 ——&gt; 中间数为4 左侧序列 1 2 3 右侧序列 5 6 7 8</p>
</li>
<li><p>为什么二分查找结束条件为：start &lt;= end<br>初始 [start, end] = [0, nums.size()-1], 也就是二分查找区间为<strong>闭区间</strong>。<br>当 start &lt; end 时，程序 start = end 时退出循环。此时闭区间中 还有一个元素 nums[start]=nums[end] 没有做判断，故二分查找有遗漏。所以二分查找结束条件为：start &lt;= end。<br>既然结束条件为：start &lt;= end。如果不满足条件，一定是 start = end + 1。也就是结束的时候 start &gt; end。<br>比如：<br>奇序列：10 11 12 13 14 15 16 17 18  目标值为19；由于该奇序列中没有符合要求的值，start 会不断向 end 靠近。循环结束时，start = end + 1;  此时 start = 9，end = 8。(start和end为序列下标，从 0 开始)<br>偶序列：10 11 12 13 14 15 16 17    目标值为9；由于该偶序列中没有符合要求的值，end 会不断向 start 靠近。循环结束时，end = start - 1; 此时 start = 0, end = -1。(start和end为序列下标，从 0 开始)</p>
</li>
<li><p>结束条件 start = end+1;<br>如果二分查找没有查找到适合 target，最终满足 start = end+1。<br>如<a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">搜索插入位置</a>这道题中，如果没有找到 target，那么插入位置一定是在 start 位置上。<br>可以分为三种情况讨论：</p>
</li>
</ol>
<ul>
<li>如果 target 可以插入序列中，nums[end] &lt; target &lt; nums[start]。</li>
<li>如果 target 小于序列所有元素。target &lt; nums[start]；</li>
<li>如果 target 大于序列所有元素，target &gt; nums[end]，target 插入位置为 end+1 = start</li>
</ul>
<p>总之，对于有序序列 target 插入位置为 start。</p>
<ol>
<li>二分查找最后一定是剩下两个元素<br>二分查找快完成的时候，start 指向两个元素的左侧元素，end 指向两个元素的右侧元素。当剩余两个元素时，mid 一定指向 start所指向的元素。<br>之后得到结果 <strong>结束条件 start = end+1;</strong>。</li>
</ol>
<h1 id="leetcode-二分查找"><a href="#leetcode-二分查找" class="headerlink" title="leetcode 二分查找"></a>leetcode 二分查找</h1><h2 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">搜索插入位置</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int start &#x3D; 0, end &#x3D; nums.size() - 1;</span><br><span class="line">        int mid &#x3D; 0;</span><br><span class="line">        while(start &lt;&#x3D; end)&#123;</span><br><span class="line">            mid &#x3D; (start + end) &#x2F; 2;</span><br><span class="line">            if(nums[mid] &#x3D;&#x3D; target)</span><br><span class="line">                return mid;</span><br><span class="line">            else if(nums[mid] &gt; target)</span><br><span class="line">                end &#x3D; mid - 1;</span><br><span class="line">            else</span><br><span class="line">                start &#x3D; mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 递归</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int __searchInsert(vector&lt;int&gt;&amp; nums, int left, int right, int target)</span><br><span class="line">    &#123;</span><br><span class="line">        if(left&gt;right)</span><br><span class="line">            return left;</span><br><span class="line"></span><br><span class="line">        int mid &#x3D; left+(right-left)&#x2F;2;</span><br><span class="line">        if(nums[mid] &#x3D;&#x3D; target)</span><br><span class="line">            return mid;</span><br><span class="line">        else if(nums[mid] &gt; target)</span><br><span class="line">            return __searchInsert(nums, left, mid-1, target);</span><br><span class="line">        else</span><br><span class="line">            return __searchInsert(nums, mid+1, right, target);</span><br><span class="line">    &#125;</span><br><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int start&#x3D;0, end&#x3D;nums.size()-1;</span><br><span class="line"></span><br><span class="line">        return __searchInsert(nums, start, end, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="搜索二维矩阵"><a href="#搜索二维矩阵" class="headerlink" title="搜索二维矩阵"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">搜索二维矩阵</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;</span><br><span class="line">        if(matrix.size() &#x3D;&#x3D; 0) return false;</span><br><span class="line">        int m &#x3D; matrix.size();</span><br><span class="line">        int n &#x3D; matrix[0].size();</span><br><span class="line"></span><br><span class="line">        int start &#x3D; 0, end &#x3D; m * n - 1;</span><br><span class="line">        int mid &#x3D; 0;</span><br><span class="line">        while(start &lt;&#x3D; end)&#123;</span><br><span class="line">            mid &#x3D; (start + end) &#x2F; 2;</span><br><span class="line">            &#x2F;&#x2F; 注意：是对整除 n，不是整除 m</span><br><span class="line">            if(matrix[mid &#x2F; n][mid % n] &#x3D;&#x3D; target)</span><br><span class="line">                return true;</span><br><span class="line">            else if(matrix[mid &#x2F; n][mid % n] &gt; target)</span><br><span class="line">                end &#x3D; mid - 1;</span><br><span class="line">            else</span><br><span class="line">                start &#x3D; mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Pow-x-n"><a href="#Pow-x-n" class="headerlink" title="Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">Pow(x, n)</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;limits.h&gt;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double myPow(double x, int n) &#123;</span><br><span class="line">        double result &#x3D; 0;</span><br><span class="line">        int flag &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        if (n &lt; 0) &#123;</span><br><span class="line">            if (n !&#x3D; INT_MIN) &#123;</span><br><span class="line">                x &#x3D; 1 &#x2F; x;</span><br><span class="line">                n &#x3D; -n;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                x &#x3D; 1 &#x2F; x;</span><br><span class="line">                n &#x3D; -(n + 1);</span><br><span class="line">                flag &#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result &#x3D; binaryPow(x, n);</span><br><span class="line"></span><br><span class="line">        if (flag &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            result &#x3D; result * x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	double binaryPow(double x, int n) &#123;</span><br><span class="line">        double result &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        if (n &#x3D;&#x3D; 0)</span><br><span class="line">            return 1;</span><br><span class="line">        result &#x3D; binaryPow(x, n&#x2F;2);</span><br><span class="line"></span><br><span class="line">        if (n % 2 &#x3D;&#x3D; 0)</span><br><span class="line">            return result * result;</span><br><span class="line">        else</span><br><span class="line">            return result * result * x;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="x-的平方根"><a href="#x-的平方根" class="headerlink" title="x 的平方根"></a><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">x 的平方根</a></h2><ul>
<li>牛顿迭代法<br><img src="/images/13-datastructure-二分查找/01-牛顿迭代法.gif" alt="&quot;01-牛顿迭代法&quot;"></li>
</ul>
<p>本图来自<a href="https://blog.csdn.net/batuwuhanpei/article/details/51979831" target="_blank" rel="noopener">牛顿法与拟牛顿法</a><br>在本题中，就要求这样的 <script type="math/tex">\ x: x^2 - a = 0</script>。即曲线 <script type="math/tex">f(x) = x^2 - a</script> 与 <script type="math/tex">x</script> 轴的交点(a为需要开方的值)。<br>牛顿迭代法：就是求在 <script type="math/tex">f(x)</script> 上的点<script type="math/tex">(x_0, f(x_0))</script>的切线与 <script type="math/tex">x</script> 轴的交点，经过若干次迭代，切线与 <script type="math/tex">x</script> 轴的交点值就等于 <script type="math/tex">f(x)</script> 与 <script type="math/tex">x</script> 轴的交点值。  </p>
<p>每次的切线与 <script type="math/tex">x</script> 的交点值为：</p>
<script type="math/tex; mode=display">\begin{equation}
f^{'}(x) = 2x \nonumber
\end{equation}</script><p>设 <script type="math/tex">f(x)</script> 上的点 <script type="math/tex">(x_0, f(x_0))</script>。这这一点的切线方程为：</p>
<script type="math/tex; mode=display">\begin{equation}
f(x) - f(x_0) = f^{'}(x_0)(x - x_0) \nonumber
\end{equation}</script><p>令<script type="math/tex">f(x)=0</script>，得切线与 <script type="math/tex">x</script>轴的交点为:</p>
<script type="math/tex; mode=display">\begin{equation}
f(x) - f(x_0) = f^{'}(x_0)(x - x_0) \nonumber
\end{equation}</script><p>本题中，每次做切线与 <script type="math/tex">x</script> 轴的交点为：</p>
<script type="math/tex; mode=display">\begin{equation}
x = \frac{1}{2}(x_0 + \frac{a}{x_0}) \nonumber
\end{equation}</script><p>由于对 整数 开方的结果一定为整数，所以 <script type="math/tex">x>0</script>。牛顿法迭代的结果就是 <script type="math/tex">f(x)</script> 的切点的 <script type="math/tex">x</script> 坐标和 切点的切线与 <script type="math/tex">x</script> 的坐标相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int mySqrt(int x) &#123;</span><br><span class="line">        double result &#x3D; 2.0;</span><br><span class="line"></span><br><span class="line">        if (x &#x3D;&#x3D; 0)	return 0;</span><br><span class="line">        return (int)NewtonMethod(x, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double NewtonMethod(double x, double result) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果result接近于0时 会出现除数为0的情况</span><br><span class="line">        &#x2F;&#x2F; 故要排除 x &#x3D; 0 的情况</span><br><span class="line">        double temp_result &#x3D; (result + x &#x2F; result) &#x2F; 2;</span><br><span class="line"></span><br><span class="line">        if (temp_result &#x3D;&#x3D; result)</span><br><span class="line">            return temp_result;</span><br><span class="line">        else</span><br><span class="line">        return NewtonMethod(x, temp_result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>二分查找</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int mySqrt(int x) &#123;</span><br><span class="line">        int start &#x3D; 0, end &#x3D; x;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 为了防止越界 采用 long long 类型</span><br><span class="line">        long long mid &#x3D; 0;</span><br><span class="line">        while (start &lt;&#x3D; end) &#123;</span><br><span class="line">            mid &#x3D; (start + end) &#x2F; 2;</span><br><span class="line">            if (pow(mid, 2) &#x3D;&#x3D; x)</span><br><span class="line">                return mid;</span><br><span class="line">            else if (pow(mid, 2) &gt; x)</span><br><span class="line">                end &#x3D; mid - 1;</span><br><span class="line">            else</span><br><span class="line">                start &#x3D; mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于 开平方 二分查找的方式是可以解决的，但是对于 开n次方 的问题就不好解决了！但是牛顿迭代法对于 开n次方 同样适用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>二分查找都可以写成递归的形式。递归三要素：明确函数功能；寻找递归结束条件；找出函数的等价关系式，不断缩小参数范围。</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>查找</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>15-datastructure-并查集</title>
    <url>/2019/12/03/15-datastructure-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集是一种可以动态维护若干个不重叠的集合，并支持合并与查询两种操作的一种数据结构。基本操作包括合并和查询。</p>
<h2 id="并查集的简单实现"><a href="#并查集的简单实现" class="headerlink" title="并查集的简单实现"></a>并查集的简单实现</h2><p>并查集主要包括合并和查询两个操作。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cassert&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class UnionFind</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    UnionFind(int n):parent(n)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;n &#x3D; n;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int find(int p)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(p&gt;&#x3D;0 &amp;&amp; p&lt;n);</span><br><span class="line">        return parent[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isConnected(int p, int q)</span><br><span class="line">    &#123;</span><br><span class="line">        return find(p) &#x3D;&#x3D; find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void unionElements(int p, int q)</span><br><span class="line">    &#123;</span><br><span class="line">        int pParent &#x3D; find(p);</span><br><span class="line">        int qParent &#x3D; find(q);</span><br><span class="line"></span><br><span class="line">        if(pParent &#x3D;&#x3D; qParent)</span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(parent[i] &#x3D;&#x3D; pParent)</span><br><span class="line">                parent[i] &#x3D; qParent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int elem : parent)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; elem &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void init()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            parent[i] &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; parent;</span><br><span class="line">    int n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>16-leetcode-对撞指针</title>
    <url>/2020/01/17/16-leetcode-%E5%AF%B9%E6%92%9E%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a>
<h1 id="c-中字母和数字相关的函数"><a href="#c-中字母和数字相关的函数" class="headerlink" title="c++中字母和数字相关的函数"></a>c++中字母和数字相关的函数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> cout &lt;&lt; isalpha(&#39;b&#39;) &lt;&lt; endl;   &#x2F;&#x2F; 小写字母返回   2</span><br><span class="line">cout &lt;&lt; isalpha(&#39;1&#39;) &lt;&lt; endl;   &#x2F;&#x2F; 非字母返回 0</span><br><span class="line">&#x2F;&#x2F; 判断一个字符是否为字母或数字 isalnum();</span><br><span class="line"> cout &lt;&lt; isalnum(&#39;b&#39;) &lt;&lt; endl; &#x2F;&#x2F; 字母返回   2</span><br><span class="line">cout &lt;&lt; isalnum(&#39;1&#39;) &lt;&lt; endl;   &#x2F;&#x2F; 数字返回   4</span><br><span class="line">cout &lt;&lt; isalnum(&#39;.&#39;) &lt;&lt; endl;   &#x2F;&#x2F; 非字母数字返回 0</span><br><span class="line">&#x2F;&#x2F; 判断一个字符是否为小写字母</span><br><span class="line"> cout &lt;&lt; islower(&#39;b&#39;) &lt;&lt; endl; &#x2F;&#x2F; 小写字母返回   2</span><br><span class="line">cout &lt;&lt; islower(&#39;2&#39;) &lt;&lt; endl;   &#x2F;&#x2F; 非小写字母返回 0</span><br><span class="line">cout &lt;&lt; islower(&#39;A&#39;) &lt;&lt; endl;   &#x2F;&#x2F; 非小写字母返回 0</span><br><span class="line">&#x2F;&#x2F; 判断一个字符是否为大写字母</span><br><span class="line">cout &lt;&lt; isupper(&#39;a&#39;) &lt;&lt; endl;   &#x2F;&#x2F; 非大写字母返回 0</span><br><span class="line">cout &lt;&lt; isupper(&#39;2&#39;) &lt;&lt; endl;   &#x2F;&#x2F; 非大写字母返回 0</span><br><span class="line">cout &lt;&lt; isupper(&#39;A&#39;) &lt;&lt; endl;   &#x2F;&#x2F; 大写字母返回 1</span><br><span class="line"> &#x2F;&#x2F; 大写转小写</span><br><span class="line"> cout &lt;&lt; (char)tolower(&#39;A&#39;) &lt;&lt; endl;</span><br><span class="line"> &#x2F;&#x2F; 小写转大写</span><br><span class="line"> cout &lt;&lt; (char)toupper(&#39;a&#39;) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool myIsAlpha(char c)</span><br><span class="line">&#123;</span><br><span class="line">    if(c&gt;&#x3D;&#39;A&#39;&amp;&amp; c&lt;&#x3D;&#39;Z&#39; || c&gt;&#x3D;&#39;a&#39;&amp;&amp; c&lt;&#x3D;&#39;z&#39;)</span><br><span class="line">        return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool myIsAlnum(char c)</span><br><span class="line">&#123;</span><br><span class="line">    if(c&gt;&#x3D;&#39;A&#39;&amp;&amp; c&lt;&#x3D;&#39;Z&#39; || c&gt;&#x3D;&#39;a&#39;&amp;&amp; c&lt;&#x3D;&#39;z&#39; || c&gt;&#x3D;&#39;0&#39;&amp;&amp; c&lt;&#x3D;&#39;9&#39;)</span><br><span class="line">        return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool myIsLower(char c)</span><br><span class="line">&#123;</span><br><span class="line">    if(c&gt;&#x3D;&#39;a&#39;&amp;&amp; c&lt;&#x3D;&#39;z&#39;)</span><br><span class="line">        return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool myIsUpper(char c)</span><br><span class="line">&#123;</span><br><span class="line">    if(c&gt;&#x3D;&#39;A&#39;&amp;&amp; c&lt;&#x3D;&#39;Z&#39;)</span><br><span class="line">        return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char myToLower(char c)</span><br><span class="line">&#123;</span><br><span class="line">    if(c&gt;&#x3D;&#39;A&#39;&amp;&amp; c&lt;&#x3D;&#39;Z&#39;)</span><br><span class="line">        return c+(&#39;a&#39;-&#39;A&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char myToUpper(char c)</span><br><span class="line">&#123;</span><br><span class="line">    if(c&gt;&#x3D;&#39;a&#39;&amp;&amp; c&lt;&#x3D;&#39;z&#39;)</span><br><span class="line">        return c-(&#39;a&#39;-&#39;A&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">验证回文串</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(string s) &#123;</span><br><span class="line">        if(s.size() &#x3D;&#x3D; 1)</span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        int i&#x3D;nextAlnums(s, 0);</span><br><span class="line">        int j&#x3D;prevAlnums(s, s.size()-1);</span><br><span class="line"></span><br><span class="line">        while(i&lt;&#x3D;j)</span><br><span class="line">        &#123;</span><br><span class="line">            if (tolower(s[i]) !&#x3D; tolower(s[j]))</span><br><span class="line">                return false;</span><br><span class="line">            i&#x3D;nextAlnums(s, i+1);</span><br><span class="line">            j&#x3D;prevAlnums(s, j-1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int nextAlnums(const string&amp; s, int index)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int k&#x3D;index; k&lt;s.size(); k++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(isalnum(s[k]))</span><br><span class="line">                return k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return s.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int prevAlnums(const string&amp; s, int index)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int k&#x3D;index; k&gt;&#x3D;0; k--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(isalnum(s[k]))</span><br><span class="line">                return k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="错误写法"><a href="#错误写法" class="headerlink" title="错误写法"></a>错误写法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool isPalindrome(string s) &#123;</span><br><span class="line">    int i&#x3D;0, j&#x3D;s.size()-1;</span><br><span class="line"></span><br><span class="line">    while(i&lt;&#x3D;j)</span><br><span class="line">    &#123;</span><br><span class="line">        i &#x3D; nextAlnums(s, i);</span><br><span class="line">        j &#x3D; prevAlnums(s, j);</span><br><span class="line">        if (i&gt;j || tolower(s[i]) !&#x3D; tolower(s[j])) &#x2F;&#x2F; &quot; &quot;</span><br><span class="line">            return false;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">反转字符串</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reverseString(vector&lt;char&gt;&amp; s) &#123;</span><br><span class="line">        int i&#x3D;0, j&#x3D;s.size()-1;</span><br><span class="line">        while(i&lt;&#x3D;j)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(s[i], s[j]);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="反转字符串中的元音字母"><a href="#反转字符串中的元音字母" class="headerlink" title="反转字符串中的元音字母"></a><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">反转字符串中的元音字母</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseVowels(string s) &#123;</span><br><span class="line">        int i &#x3D; nextVowel(s, 0);</span><br><span class="line">        int j &#x3D; prevVowel(s, s.size()-1);</span><br><span class="line">        while(i&lt;&#x3D;j)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(s[i], s[j]);</span><br><span class="line">            i &#x3D; nextVowel(s, i+1);</span><br><span class="line">            j &#x3D; prevVowel(s, j-1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int nextVowel(const string&amp; s, int index)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;index; i&lt;s.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(isVowel(s[i]))</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return s.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int prevVowel(const string&amp; s, int index)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;index; i&gt;&#x3D;0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(isVowel(s[i]))</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isVowel(char c)</span><br><span class="line">    &#123;</span><br><span class="line">        if(c&#x3D;&#x3D;&#39;a&#39; || c&#x3D;&#x3D;&#39;e&#39; || c&#x3D;&#x3D;&#39;i&#39; || c&#x3D;&#x3D;&#39;o&#39; || c&#x3D;&#x3D;&#39;u&#39; ||</span><br><span class="line">           c&#x3D;&#x3D;&#39;A&#39; || c&#x3D;&#x3D;&#39;E&#39; || c&#x3D;&#x3D;&#39;I&#39; || c&#x3D;&#x3D;&#39;O&#39; || c&#x3D;&#x3D;&#39;U&#39;)</span><br><span class="line">            return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="盛最多水的容器-https-leetcode-cn-com-problems-container-with-most-water"><a href="#盛最多水的容器-https-leetcode-cn-com-problems-container-with-most-water" class="headerlink" title="[盛最多水的容器]{https://leetcode-cn.com/problems/container-with-most-water/}"></a>[盛最多水的容器]{<a href="https://leetcode-cn.com/problems/container-with-most-water/}" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water/}</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxArea(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int i&#x3D;0, j&#x3D;height.size()-1;</span><br><span class="line">        int maxValue &#x3D; area(height, i, j);</span><br><span class="line"></span><br><span class="line">        while(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            if(height[i] &gt; height[j])</span><br><span class="line">                j &#x3D; prevHeight(height, j-1);</span><br><span class="line">            else</span><br><span class="line">                i &#x3D; nextHeight(height, i+1);</span><br><span class="line"></span><br><span class="line">            int areaValue &#x3D; area(height, i, j);</span><br><span class="line">            if(maxValue &lt; areaValue)</span><br><span class="line">                maxValue &#x3D; areaValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int area(const vector&lt;int&gt;&amp; height, int i, int j)</span><br><span class="line">    &#123;</span><br><span class="line">        if (i&gt;&#x3D;j) return 0;   &#x2F;&#x2F; 不可缺少</span><br><span class="line">        return (j-i)*min(height[i], height[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int prevHeight(const vector&lt;int&gt;&amp; height, int index)</span><br><span class="line">    &#123;</span><br><span class="line">        int pivot &#x3D; height[index+1];</span><br><span class="line">        for(int i&#x3D;index; i&gt;&#x3D;0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(height[i]&gt;pivot)</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int nextHeight(const vector&lt;int&gt;&amp; height, int index)</span><br><span class="line">    &#123;</span><br><span class="line">        int pivot &#x3D; height[index-1];</span><br><span class="line">        for(int i&#x3D;index; i&lt;height.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(height[i]&gt;pivot)</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return height.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对撞指针要注意跳出循环的条件，防止在使用对撞指针的过程中出现越界的现象。</p>
]]></content>
      <categories>
        <category>刷题</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>18-cpp-#define-const-static-sizeof</title>
    <url>/2020/02/09/18-cpp-const-static-sizeof/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a>
<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><h2 id="const修饰普通类型变量"><a href="#const修饰普通类型变量" class="headerlink" title="const修饰普通类型变量"></a>const修饰普通类型变量</h2><ul>
<li>const修饰普通类型的变量，放在类型前后没区别。即const int a 和 int const a 效果相同。</li>
<li>const修饰的普通类型变量，不可以通过指针的方式间接修改内存空间中的值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int test()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 编译器在编译的时候，会把常量放入一个符号表，编译的时候替换符合要求的常量。即编译器进行优化。</span><br><span class="line">    &#x2F;&#x2F; c语言中编译器不会进行优化</span><br><span class="line">&#x2F;&#x2F;    const int  a &#x3D; 7;</span><br><span class="line">    int const a &#x3D; 7;</span><br><span class="line">    int *p &#x3D; (int*)&amp;a;</span><br><span class="line">    *p &#x3D; 8;</span><br><span class="line">    cout &lt;&lt; &quot;a&#x3D;&quot; &lt;&lt; a &lt;&lt; &quot;,*p&#x3D;&quot; &lt;&lt; *p &lt;&lt; endl;  &#x2F;&#x2F; a&#x3D;7 *p&#x3D;8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>const修饰的普通类型变量，如果加上volatile，可以通过指针的方式间接修改内存空间中的值。volatile修饰的变量不会被编译器优化。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int test()</span><br><span class="line">&#123;</span><br><span class="line">    volatile int const a &#x3D; 7;</span><br><span class="line">    int *p &#x3D; (int*)&amp;a;</span><br><span class="line">    *p &#x3D; 8;</span><br><span class="line">    cout &lt;&lt; &quot;a&#x3D;&quot; &lt;&lt; a &lt;&lt; &quot;,*p&#x3D;&quot; &lt;&lt; *p &lt;&lt; endl;  &#x2F;&#x2F; a&#x3D;8 *p&#x3D;8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="const修饰指针变量"><a href="#const修饰指针变量" class="headerlink" title="const修饰指针变量"></a>const修饰指针变量</h2><ul>
<li>const修饰指针变量指向的内存空间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int test()</span><br><span class="line">&#123;</span><br><span class="line">	int a &#x3D; 10, b &#x3D; 20;</span><br><span class="line">	&#x2F;&#x2F; 将const int *p1看作两部分 const int 和 *p1 即指针变量所指向的内存空间为const</span><br><span class="line">	const int *p1 &#x3D; &amp;a;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;    *p1 &#x3D; b;		&#x2F;&#x2F; *p1为常量 error</span><br><span class="line">	p1 &#x3D; &amp;b;		&#x2F;&#x2F; p1是可变的指针变量</span><br><span class="line">	cout &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>const修饰指针变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int test()</span><br><span class="line">&#123;</span><br><span class="line">	int a &#x3D; 10, b &#x3D; 20;</span><br><span class="line">	&#x2F;&#x2F; 将int* const p2看作两部分 int* 和 const p2</span><br><span class="line">	int* const p2 &#x3D; &amp;a;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; const修饰指针变量</span><br><span class="line">	*p2 &#x3D; b;</span><br><span class="line">&#x2F;&#x2F;	p2 &#x3D; &amp;b;		&#x2F;&#x2F; p2是不变的指针变量 error</span><br><span class="line">	cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>const修饰指针变量和指针变量所指向的内存空间<br>指针变量是常量，指针变量所指向的内存空间也是常量</li>
</ul>
<p>参考<a href="https://www.runoob.com/w3cnote/cpp-const-keyword.html" target="_blank" rel="noopener">C++ const 关键字小结</a></p>
<h2 id="C-中const的作用"><a href="#C-中const的作用" class="headerlink" title="C++中const的作用"></a>C++中const的作用</h2><ol>
<li>用于定义常量：const定义的常量编译器可以对其进行数据静态类型安全检查</li>
<li>const修饰函数形参</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void func(A a);     &#x2F;&#x2F; 存在临时对象的构造、复制、析构，效率低</span><br><span class="line">void func(A const &amp;a);  &#x2F;&#x2F; 引用传递不产生临时对象，const保证引用对象不可修改</span><br><span class="line">&#x2F;&#x2F; A const &amp;a; 此时const修饰的是普通变量，不是指针变量。所以const放置在A的前后表示的含义一样</span><br><span class="line">&#x2F;&#x2F; 但是A如果是自定义类型，比如类类型。需要保证在funct函数中调用的类成员函数不会修改a的值</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Teacher</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Teacher(string name, int age)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;name &#x3D; name;</span><br><span class="line">        this-&gt;age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Teacher(const Teacher&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;拷贝构造函数&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void setName(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    void setAge(int age)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">    string getName()</span><br><span class="line">    &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    int getAge()</span><br><span class="line">    &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 必须用const修饰</span><br><span class="line">    void print() const</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;name&#x3D;&quot; &lt;&lt; name &lt;&lt; &quot;,age&#x3D;&quot; &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    string name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 引用修饰，保证对象t不会被修改</span><br><span class="line">void func(const Teacher &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;    t.setAge(35); &#x2F;&#x2F; error</span><br><span class="line">    t.print();  &#x2F;&#x2F; 由于引用用const修饰，必须保证引用不会被修改，所以调用的类成员函数必须用const修饰</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    Teacher t(&quot;simon&quot;, 25);</span><br><span class="line">    func(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>const修饰函数返回值</li>
<li>const修饰类成员函数</li>
</ol>
<h1 id="define"><a href="#define" class="headerlink" title="define"></a>define</h1><p>宏定义在预处理阶段由预处理器进行替换，只是单纯的进行文本替换。一个完整的宏定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define 宏名 宏体</span><br><span class="line">&#x2F;&#x2F; 无参宏</span><br><span class="line">#define SEC_PER_YEAR (365*24*60UL)</span><br><span class="line">&#x2F;&#x2F; 带参宏</span><br><span class="line">#define SQR(x) ((x)*(x))</span><br></pre></td></tr></table></figure>
<h2 id="宏定义的使用"><a href="#宏定义的使用" class="headerlink" title="宏定义的使用"></a>宏定义的使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define Sqr(x) (x*x)</span><br><span class="line">#define SQR(x) ((x)*(x))</span><br><span class="line"></span><br><span class="line">int test()</span><br><span class="line">&#123;</span><br><span class="line">	int a, b &#x3D; 3;</span><br><span class="line"></span><br><span class="line">	a &#x3D; Sqr(b+2);   &#x2F;&#x2F; 原地替换 a &#x3D; (b+2*b+2)</span><br><span class="line">	cout &lt;&lt; &quot;a&#x3D;&quot; &lt;&lt; a &lt;&lt; endl;  &#x2F;&#x2F; a&#x3D;11</span><br><span class="line"></span><br><span class="line">    a &#x3D; SQR(b+2);   &#x2F;&#x2F; 原地替换 a &#x3D; ((b+2)*(b+2))</span><br><span class="line">    cout &lt;&lt; &quot;a&#x3D;&quot; &lt;&lt; a &lt;&lt; endl;  &#x2F;&#x2F; a&#x3D;25</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="define的替代方案"><a href="#define的替代方案" class="headerlink" title="#define的替代方案"></a>#define的替代方案</h2><h2 id="define无参宏的替代方案-const"><a href="#define无参宏的替代方案-const" class="headerlink" title="#define无参宏的替代方案-const"></a>#define无参宏的替代方案-const</h2><h1 id="define和const都可以定义常量。两者的不同之处："><a href="#define和const都可以定义常量。两者的不同之处：" class="headerlink" title="define和const都可以定义常量。两者的不同之处："></a>define和const都可以定义常量。两者的不同之处：</h1><ul>
<li>宏定义由预处理器处理只是单纯的文本替换，没有类型检查和作用域检查</li>
<li>const由编译器进行处理，有类型检查和作用域检查</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;#define N 10  &#x2F;&#x2F; 预处理阶段</span><br><span class="line"></span><br><span class="line">int test()</span><br><span class="line">&#123;</span><br><span class="line">    const int N &#x3D; 10; &#x2F;&#x2F; 编译阶段</span><br><span class="line">    int array[N] &#x3D; &#123; 1, 2, 3 &#125;;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; N; i++) &#123;</span><br><span class="line">        cout &lt;&lt; array[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>作用域举例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void func() &#123;</span><br><span class="line">#define a 10	&#x2F;&#x2F; 对于文件中所有的a都会进行替换</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;#undef a	  &#x2F;&#x2F; 只有卸载这个宏，才不会影响到其他函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test() &#123;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;  &#x2F;&#x2F; a &#x3D; 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>const由编译器处理 由类型检查和作用域检查</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void func() &#123;</span><br><span class="line">  const int a &#x3D; 10;   &#x2F;&#x2F; a这个常量的作用域在函数内</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test() &#123;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;  &#x2F;&#x2F; error,a没有定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="define有参宏的替代方案-内联函数"><a href="#define有参宏的替代方案-内联函数" class="headerlink" title="#define有参宏的替代方案-内联函数"></a>#define有参宏的替代方案-内联函数</h2><p>C++中 可以使用 内联函数 替代有参宏。内联函数声明时 inline 关键字必须和函数定义结合在一起，否则编译器会直接忽略内联请求。</p>
<ul>
<li>有参宏举例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MYFUNC(a, b) ((a) &lt; (b) ? (a) : (b))</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">	int a &#x3D; 1, b &#x3D; 3;</span><br><span class="line">	int c &#x3D; MYFUNC(a++, b);</span><br><span class="line">	&#x2F;&#x2F; 等价于 int c &#x3D; ((a++) &lt; (b) ? (a++) : (b))</span><br><span class="line">	&#x2F;&#x2F; (a++) &lt; (b) --&gt; 1&lt;3  a&#x3D;2 c&#x3D;((a++)) c&#x3D;2 a&#x3D;3</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; &quot;a&#x3D;&quot; &lt;&lt; a &lt;&lt; endl;      &#x2F;&#x2F; 3</span><br><span class="line">	cout &lt;&lt; &quot;b&#x3D;&quot; &lt;&lt; b &lt;&lt; endl;      &#x2F;&#x2F; 3</span><br><span class="line">	cout &lt;&lt; &quot;c&#x3D;&quot; &lt;&lt; c &lt;&lt; endl;      &#x2F;&#x2F; 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>内联函数举例</li>
</ul>
<p>内联函数适用于代码量小的函数块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">inline int myfunc(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">	return ((a) &lt; (b) ? (a) : (b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">	int a &#x3D; 1, b &#x3D; 3;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; C++编译器直接将函数体插入在函数调用的地方</span><br><span class="line">	&#x2F;&#x2F; 在 a++ 之前，先将 a 的值复制到myfunc函数的形参a中，然后自增1</span><br><span class="line">	int c &#x3D; myfunc(a++, b);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;a&#x3D;&quot; &lt;&lt; a &lt;&lt; endl;      &#x2F;&#x2F; 2</span><br><span class="line">	cout &lt;&lt; &quot;b&#x3D;&quot; &lt;&lt; b &lt;&lt; endl;      &#x2F;&#x2F; 3</span><br><span class="line">	cout &lt;&lt; &quot;c&#x3D;&quot; &lt;&lt; c &lt;&lt; endl;      &#x2F;&#x2F; 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="静态成员特点"><a href="#静态成员特点" class="headerlink" title="静态成员特点"></a>静态成员特点</h2><ul>
<li>静态成员是属于类的，不属于对象，不占用对象的内存空间。</li>
<li>可以通过 类名::成员/ 对象.成员 的方式调用。静态成员在 类对象之间 共享。</li>
<li>在类中声明成员函数为静态需要加 static，静态成员存储于静态存储区，必须对它进行初始化。</li>
<li>基类定义的静态成员被所有派生类共享，并遵循类层次体系的访问控制。</li>
<li>静态成员函数中只能调用静态成员变量。原因在于：静态成员函数属于类，普通成员变量在对象没有定义之前没有定义。</li>
<li>静态成员函数中不需要this指针，原因在于静态成员函数有明确的归属；普通成员函数需要this指针，以区分不同的对象。</li>
<li>静态成员属于类本身，在类加载的时候就会分配内存；类对象只有创建时才会分配内存。</li>
</ul>
<p>静态成员的初始化格式：<br>  &lt;数据类型&gt; &lt;类名&gt;::&lt;静态数据成员名&gt; = &lt;值&gt;;<br>注意：</p>
<ol>
<li>初始化在类外进行，前面不加static关键字，以免与在类外定义的静态变量混淆。</li>
<li>初始化不加该成员的访问控制符</li>
<li>初始化用作用域运算符标定该变量所属类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Parent</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static int num;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F; 静态成员函数可以修改静态成员变量的值</span><br><span class="line">    static void add()</span><br><span class="line">    &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 普通成员函数可以修改静态成员变量的值</span><br><span class="line">    void set(int i)</span><br><span class="line">    &#123;</span><br><span class="line">        num &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 普通成员函数可以输出静态成员变量的值</span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;num &#x3D; &quot; &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &lt;数据类型&gt; &lt;类名&gt;::&lt;静态数据成员名&gt; &#x3D; &lt;值&gt;;</span><br><span class="line">int Parent::num &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F; 初始化在类外进行，前面不加static关键字，以免与在类外定义的静态变量混淆</span><br><span class="line">static int a;</span><br><span class="line"></span><br><span class="line">class Child : public Parent</span><br><span class="line">&#123;</span><br><span class="line">    int c;  &#x2F;&#x2F; 默认是私有的</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F; 静态成员函数不依赖于类数据结构的共同操作,没有this指针</span><br><span class="line">    &#x2F;&#x2F; 静态成员函数中只能调用静态成员变量</span><br><span class="line">    &#x2F;&#x2F; 原因：静态成员函数属于类,在没有对象之前,普通成员变量是没有定义的</span><br><span class="line">    static void add()</span><br><span class="line">    &#123;</span><br><span class="line">&#x2F;&#x2F;        c++;  &#x2F;&#x2F; error</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void set(int i)</span><br><span class="line">    &#123;</span><br><span class="line">        num &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;num &#x3D; &quot; &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    Parent p;</span><br><span class="line">    Child c;</span><br><span class="line"></span><br><span class="line">    p.add();</span><br><span class="line">    p.print();</span><br><span class="line">    c.print();</span><br><span class="line"></span><br><span class="line">    c.add();</span><br><span class="line">    p.print();</span><br><span class="line">    c.print();</span><br><span class="line"></span><br><span class="line">    p.set(10);</span><br><span class="line">    p.print();</span><br><span class="line">    c.print();</span><br><span class="line"></span><br><span class="line">    c.set(20);</span><br><span class="line">    p.print();</span><br><span class="line">    c.print();</span><br><span class="line"></span><br><span class="line">    Parent::num++;</span><br><span class="line">    p.print();</span><br><span class="line">    c.print();</span><br><span class="line"></span><br><span class="line">    Child::Parent::num++;</span><br><span class="line">    p.print();</span><br><span class="line">    c.print();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态成员变量不占用类对象的内存空间"><a href="#静态成员变量不占用类对象的内存空间" class="headerlink" title="静态成员变量不占用类对象的内存空间"></a>静态成员变量不占用类对象的内存空间</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class c1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int i;</span><br><span class="line">protected:</span><br><span class="line">    int j;</span><br><span class="line">private:</span><br><span class="line">    int k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class c2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int i;</span><br><span class="line">protected:</span><br><span class="line">    int j;</span><br><span class="line">private:</span><br><span class="line">    int k;</span><br><span class="line">    static int m;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void set(int i, int j, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;i &#x3D; i;</span><br><span class="line">        this-&gt;j &#x3D; j;</span><br><span class="line">        this-&gt;k &#x3D; k;</span><br><span class="line">        cout &lt;&lt; &quot;this is c2&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int c2::m &#x3D; 0;</span><br><span class="line"></span><br><span class="line">struct s1</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	int j;</span><br><span class="line">	int k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct s2</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	int j;</span><br><span class="line">	int k;</span><br><span class="line">	static int m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 类的内存大小等于类中非静态成员变量的内存大小总和</span><br><span class="line">    cout &lt;&lt; &quot;sizeof(c1) &#x3D; &quot; &lt;&lt; sizeof(c1) &lt;&lt; endl;  &#x2F;&#x2F; 12</span><br><span class="line">    cout &lt;&lt; &quot;sizeof(c2) &#x3D; &quot; &lt;&lt; sizeof(c2) &lt;&lt; endl;  &#x2F;&#x2F; 12</span><br><span class="line">    &#x2F;&#x2F; 结构体的内存大小等于类的内存大小</span><br><span class="line">    cout &lt;&lt; &quot;sizeof(s1) &#x3D; &quot; &lt;&lt; sizeof(s1) &lt;&lt; endl;  &#x2F;&#x2F; 12</span><br><span class="line">    cout &lt;&lt; &quot;sizeof(s2) &#x3D; &quot; &lt;&lt; sizeof(s2) &lt;&lt; endl;  &#x2F;&#x2F; 12</span><br><span class="line">    &#x2F;&#x2F; 类的大小不包括this指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>数据类型定义<br>数据类型是固定内存大小的别名，编译器根据数据类型预算需要分配内存空间的大小。</li>
</ul>
<h3 id="数据类型别名：-define-和-typedef-的区别"><a href="#数据类型别名：-define-和-typedef-的区别" class="headerlink" title="数据类型别名：#define 和 typedef 的区别"></a>数据类型别名：#define 和 typedef 的区别</h3><p><code>#define</code> 和 typedef都可以给现有类型起别名。但是 #define 只是在预编译的时候进行文本替换，而 typedef 是在编译时进行处理。<br><code>#define</code> 宏名 需要替换的实际参数<br>typedef 原数据类型 数据类型的别名</p>
<ul>
<li><h1 id="define-1"><a href="#define-1" class="headerlink" title="define"></a>define</h1></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct teacher&#123;</span><br><span class="line">	char name[40];</span><br><span class="line">	int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; #define只是单纯的文本替换</span><br><span class="line">#define teacher struct teacher</span><br><span class="line">&#x2F;&#x2F; 以下会将 文本中的 teacher 直接替换成 struct teacher&#123; char name[40]; int age; &#125;;</span><br><span class="line">&#x2F;&#x2F; #define teacher struct teacher&#123; char name[40]; int age; &#125;;	</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	teacher t &#x3D; &#123;&quot;savana&quot;, 30 &#125;; </span><br><span class="line">	cout &lt;&lt; t.name &lt;&lt; &quot; &quot; &lt;&lt; t.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>typedef</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct teacher &#123; </span><br><span class="line">	char name[40]; </span><br><span class="line">	int age; </span><br><span class="line">&#125;teacher;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	teacher t &#x3D; &#123;&quot;savana&quot;, 30 &#125;;	</span><br><span class="line">	cout &lt;&lt; t.name &lt;&lt; &quot; &quot; &lt;&lt; t.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>区别</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define dpchar char*</span><br><span class="line">&#x2F;&#x2F; typdef必须以分号结尾</span><br><span class="line">typedef char* tpchar;</span><br><span class="line"> </span><br><span class="line">dpchar p1, p2;	&#x2F;&#x2F; 预编译器文本替换 char* p1, p2; p1 是指针变量 p2 是char</span><br><span class="line">tpchar p1, p2;	&#x2F;&#x2F; 编译器 tpchar p1, tpchar p2; p1 和 p2都是指针变量</span><br></pre></td></tr></table></figure>
<ul>
<li>函数也是一种数据类型</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>17-cpp-指针与引用</title>
    <url>/2020/02/07/17-cpp-%E6%8C%87%E9%92%88-const-%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>指针和引用学习。<br><a id="more"></a></p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="指针的本质"><a href="#指针的本质" class="headerlink" title="指针的本质"></a>指针的本质</h2><p>指针是一种变量，占4字节内存空间，用于保存所指向内存空间的<strong>内存地址</strong>。指针加1,结果是加上指针 所指向内存空间的数据类型 的步长。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Type a;</span><br><span class="line">Type* p &#x3D; &amp;a;</span><br><span class="line">&#x2F;&#x2F; p++ -&gt; (unsigned int)p + sizeof(Type)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>*p++ (*p)++ ++*p *++p</code>的区别</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a[10] &#x3D; &#123; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;;</span><br><span class="line">	int* p &#x3D; &amp;a[0];</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 后++：先计算*p，然后cout输出，最后p加1(指针变量加1)</span><br><span class="line">	cout &lt;&lt; *p++ &lt;&lt; endl;		&#x2F;&#x2F; 0	p &#x3D; p + 1</span><br><span class="line">	&#x2F;&#x2F; 后++：先计算*p，然后cout输出，最后*p加1(指针变量所指向的内存空间加1)</span><br><span class="line">	cout &lt;&lt; (*p)++ &lt;&lt; endl;		&#x2F;&#x2F; 1</span><br><span class="line">	&#x2F;&#x2F; 前++：先计算p加1，然后计算*(++p)，最后cout输出(指针加1)</span><br><span class="line">	cout &lt;&lt; *++p &lt;&lt; endl;		&#x2F;&#x2F; p &#x3D; p + 1	2</span><br><span class="line">	&#x2F;&#x2F; 前++：先计算*p，然后*p加1，最后cout输出1(指针变量所指向的内存空间加1)</span><br><span class="line">	cout &lt;&lt; ++(*p) &lt;&lt; endl;		&#x2F;&#x2F; 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><p>野指针产生的原因：指针变量和指针变量所指向的内存空间是两个不同的概念。指针变量所指向的内存空间释放，并不代表指针变量设置为Null。<br>指针变量存储的是内存空间的地址，和内存空间的变化无关。<br>避免野指针的方法：</p>
<ol>
<li>定义指针变量的时候初始化为 NULL。</li>
<li>使用指针变量前，将指针变量与有效内存空间的地址绑定。</li>
<li>内存空间使用完毕后，要将 指针变量 设置为 NULL。</li>
</ol>
<p>总之：指针要指向一个确定(指向的内存空间要是有效的)的有访问权限(如不能修改只读权限的内存空间)的内存空间。</p>
<h2 id="void-和-void"><a href="#void-和-void" class="headerlink" title="void 和 void*"></a>void 和 void*</h2><p>在C语言中，不存在<strong>变量没有数据类型</strong>。编译器编译的时候，要根据变量的类型来确定这个变量占用内存的字节数和这一段内存的解析方法。<br>虽然变量必须有数据类型，但是内存可以无类型，也就是变量和内存在没有关联之前是没有关系的。本质上内存就是没有类型的，内存只是因为和<br>具体的变量相关联后才有了确定的类型(其实内存只是存储颗粒，是编译器对特定的内存做出了划分和解释)。<br>void<em> 指向的内存空间还没有分配数据类型，我们可以通过强制类型转换将这段内存空间指定为某种数据类型。<br>void</em> 做左值的时候用于接收任意类型的指针，做右值的时候赋值给其他指针前需要进行强制类型转换。</p>
<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>字面量就是类似 0 1 2 3 ‘a’ 等数字。这些字面量是没有内存地址的，也就是不存在与堆栈这样的数据结构中。</p>
<h2 id="函数调用形参问题"><a href="#函数调用形参问题" class="headerlink" title="函数调用形参问题"></a>函数调用形参问题</h2><p>本质上，调用函数时传递实参都会复制一份给函数的形参。不管是普通变量还是指针变量。<br>以下例子中，可知在 main 函数中的指针变量 p 的地址和 func 函数中指针变量 p 的地址是不同的。<br>也就是编译器分配了两个内存空间，这两个内存空间中都存储了 p 的值(也就是a的地址)。所以在 func 函数中<br>可以间接地修改 main 函数中的a的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">间接赋值：</span><br><span class="line">1. 两个变量：一个实参a，一个形参p(实参数据类型的指针类型)</span><br><span class="line">2. 建立关联：实参 取地址赋值给 形参</span><br><span class="line">3. 通过 *p 间接修改实参的值</span><br><span class="line">也就是通过n级指针(形参)可以间接修改n-1级指针(实参)的值。</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">void func(int* p)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; &quot; &quot; &lt;&lt; &amp;p &lt;&lt; endl;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a &#x3D; 10;</span><br><span class="line">	int *p &#x3D; &amp;a;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; &quot; &quot; &lt;&lt; &amp;p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	func(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>定义：数组中元素类型 数组名[数组元素个数];<br>本质上，数组也是一个变量，数组名就是变量名。变量的本质就是一段内存空间，编译器在编译的时候，会将一个变量名和这段内存空间的第一个字节地址绑定，<br>变量类型决定这段内存空间的字节数。</p>
<h3 id="以-int-buf-100-为例，区分-buf、buf-0-、-amp-buf-0-、-amp-buf"><a href="#以-int-buf-100-为例，区分-buf、buf-0-、-amp-buf-0-、-amp-buf" class="headerlink" title="以 int buf[100] 为例，区分 buf、buf[0]、&amp;buf[0]、&amp;buf"></a>以 int buf[100] 为例，区分 buf、buf[0]、&amp;buf[0]、&amp;buf</h3><ul>
<li>buf 的两层含义</li>
</ul>
<ol>
<li>变量名(数组名)—&gt;既然是变量名，就可以对变量名取地址<br>通过 sizeof(buf) 可以知道数组所占的内存空间的大小。<br>从变量名的角度讲，buf不能作为左值。作为左值给buf赋值的时候，相对于对数组整体赋值(不同于数组的初始化)。</li>
<li>等价于 &amp;buf[0]—&gt;也就是数组首元素的首地址，<strong>是一个常量值</strong>。<br>从地址常量的角度讲，常量不允许被写，也就是 ++buf、buf++ 都是错误的。</li>
</ol>
<ul>
<li><p>&amp;buf[0]<br>数组首元素的首地址，等价于 buf，是一个地址常量。对buf加1就是 加数组中元素 数据类型的字节数(元素空间大小)。</p>
</li>
<li><p>&amp;buf<br>数组的地址，是一个地址常量。对 &amp;buf 加1就是 加数组类型的字节数(数组空间大小)。</p>
</li>
</ul>
<h3 id="指针数组与数组指针"><a href="#指针数组与数组指针" class="headerlink" title="指针数组与数组指针"></a>指针数组与数组指针</h3><p>指针数组就是由指针构成的数组。指针数组就是一个普通数组，只是数组中的元素是指针变量。<br>数组指针就是数组的指针。数组指针指向一个数组。</p>
<p>类比：<br>    int <em>p：编译器看到</em>p就认为这是一个指针;<br>    int p[100]: 编译器看到 p[100] 就认为这是一个数组<br>    优先级：() &gt; [] &gt; *</p>
<ul>
<li>int (*p)[100];  </li>
</ul>
<ol>
<li>找核心—-&gt;p  </li>
<li>找结合—-&gt;由于加了( )—-&gt;*p—-&gt;指针  </li>
<li>找类型——&gt;int (*)[100] 的数组指针类型<br>故p是一个指向数组类型的指针</li>
</ol>
<ul>
<li>int *p[100];  </li>
</ul>
<ol>
<li>找核心—-&gt;p  </li>
<li>找结合—-&gt;p[100]—-&gt;数组  </li>
<li>找类型—-&gt;int*—-&gt;数组元素类型为int8<br>故p是一个数组名</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int buf[10] &#x3D; &#123; &#125;;</span><br><span class="line">	&#x2F;&#x2F; buf是数组名 等价于&amp;buf[0]；是一个常量值</span><br><span class="line">	&#x2F;&#x2F; buf+1 ---&gt; buf+sizeof(int)</span><br><span class="line">	int *p1 &#x3D; buf, *p2 &#x3D; &amp;buf[0];</span><br><span class="line">	&#x2F;&#x2F; &amp;buf是数组这个变量的地址；是一个常量值</span><br><span class="line">	&#x2F;&#x2F; &amp;buf+1 ---&gt; &amp;buf+sizeof(buf)</span><br><span class="line">    int (*p3)[10] &#x3D; &amp;buf;</span><br><span class="line">    &#x2F;&#x2F; p4是数组名</span><br><span class="line">    int *p4[10];</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组作为函数参数的退化问题"><a href="#数组作为函数参数的退化问题" class="headerlink" title="数组作为函数参数的退化问题"></a>数组作为函数参数的退化问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数组做函数形参，会退化为一个指针</span><br><span class="line">void func(int a[], int num)&#123;</span><br><span class="line">    cout &lt;&lt; sizeof(a)&#x2F;sizeof(a[0]) &lt;&lt; endl;     &#x2F;&#x2F; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int buf[3] &#x3D; &#123;0, 1, 2&#125;;</span><br><span class="line">    cout &lt;&lt; sizeof(buf)&#x2F;sizeof(buf[0]) &lt;&lt; endl; &#x2F;&#x2F; 3</span><br><span class="line">    func(buf, sizeof(buf)&#x2F;sizeof(buf[0]));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：常量不能作为左值!</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>变量可以看作是一块存储数据的内存空间的名字，<font color="red">引用就是这块内存空间的别名</font>。类似于人的名字，人本身是没有名字的，但是为了识别不同的人，所以有了名字。也就是将某个变量名与内存空间绑定了。</p>
<h2 id="引用本质探究"><a href="#引用本质探究" class="headerlink" title="引用本质探究"></a>引用本质探究</h2><ul>
<li>普通引用在声明时必须用其他的变量进行初始化，类比常量也必须初始化，如 const int a;</li>
<li>引用作为函数参数声明时不需要进行初始化  </li>
</ul>
<p>由下程序可知，double &amp;a 占4个字节，说明 double&amp; 类似于指针类型(指针类型为4字节)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct teacher &#123;</span><br><span class="line">	char name[64];</span><br><span class="line">	double &amp;a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; sizeof(teacher) &lt;&lt; endl;	&#x2F;&#x2F; 64</span><br><span class="line">	cout &lt;&lt; sizeof(double*) &lt;&lt; endl;	&#x2F;&#x2F; 4</span><br><span class="line">	cout &lt;&lt; sizeof(double);				&#x2F;&#x2F; 8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上可知，Type &amp;a 等同于 Type <em> const a(a是不变的指针变量，</em>a是可变的内存空间)。Type &amp;a有自己的存储空间，为4字节。</p>
<ul>
<li>使用指针方式间接赋值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">间接赋值：</span><br><span class="line">1. 两个变量：一个实参a，一个形参p(实参数据类型的指针类型)</span><br><span class="line">2. 建立关联：实参 取地址赋值给 形参</span><br><span class="line">3. 通过 *p 间接修改实参的值</span><br><span class="line">也就是通过n级指针(形参)可以间接修改n-1级指针(实参)的值。</span><br><span class="line">*&#x2F;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void func(int* p)</span><br><span class="line">&#123;</span><br><span class="line">	*p &#x3D; 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">	int a &#x3D; 10;</span><br><span class="line">	int *p &#x3D; &amp;a;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;a&#x3D;&quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	func(p);</span><br><span class="line">	cout &lt;&lt; &quot;a&#x3D;&quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用指针方式，第1步和第2步在 主函数 中完成，第3步在被调函数中完成。</span><br></pre></td></tr></table></figure>
<ul>
<li>使用引用方式间接赋值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">间接赋值：</span><br><span class="line">1. 两个变量：一个实参a，一个形参p(实参数据类型的指针类型)</span><br><span class="line">2. 建立关联：实参 取地址赋值给 形参</span><br><span class="line">3. 通过 *p 间接修改实参的值</span><br><span class="line">也就是通过n级指针(形参)可以间接修改n-1级指针(实参)的值。</span><br><span class="line">*&#x2F;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void func(int &amp;a)&#123;</span><br><span class="line">	a &#x3D; 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; const修饰普通类型变量,放在类型前后没区别。</span><br><span class="line">&#x2F;&#x2F; 此时修饰的变量为常量</span><br><span class="line">void func1(const int &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;    a &#x3D; 20;   &#x2F;&#x2F; error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test()&#123;</span><br><span class="line">    int a &#x3D; 10;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;a&#x3D;&quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    func(a);</span><br><span class="line">    cout &lt;&lt; &quot;a&#x3D;&quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F;    func1(a);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 使用引用方式，编译器将第2步和第3步结合在一起，func(a)传递一个 int* const p 的指针变量。</span><br><span class="line">&#x2F;&#x2F; 之后间接赋值的时候，编译器进行 解引用 赋值。</span><br></pre></td></tr></table></figure>
<h2 id="函数返回值是引用"><a href="#函数返回值是引用" class="headerlink" title="函数返回值是引用"></a>函数返回值是引用</h2><p>当函数返回值为引用时：</p>
<ul>
<li>若返回栈变量，不能作为右值，也不能作为左值。</li>
<li>若返回静态变量或全局变量，可以作为右值，也可以作为左值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int&amp; func()&#123;</span><br><span class="line">    static int a &#x3D; 10;</span><br><span class="line"></span><br><span class="line">    a++;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;a&#x3D;&quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    func() &#x3D; 100;	&#x2F;&#x2F; 函数返回值引用 为左值	&#x2F;&#x2F; a &#x3D; 11</span><br><span class="line">    func();			&#x2F;&#x2F; a &#x3D; 101</span><br><span class="line"></span><br><span class="line">	int &amp;i &#x3D; func();	&#x2F;&#x2F; 函数返回值引用 为右值	&#x2F;&#x2F; a &#x3D; 102</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指针引用"><a href="#指针引用" class="headerlink" title="指针引用"></a>指针引用</h2><ul>
<li>二级指针间接赋值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Teacher</span><br><span class="line">&#123;</span><br><span class="line">	char name[64];</span><br><span class="line">	int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int getTe(Teacher **myp)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; 对 p 所指向的内存空间赋值</span><br><span class="line">	Teacher *p &#x3D; (Teacher *)malloc(sizeof(Teacher));</span><br><span class="line">	if (p &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	memset(p, 0, sizeof(Teacher));</span><br><span class="line">	p-&gt;age &#x3D; 33;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 修改主调函数中p的值</span><br><span class="line">	*myp &#x3D; p;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Teacher *p &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">	getTe(&amp;p);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;age&#x3D;&quot; &lt;&lt; p-&gt;age &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始 p 是一级空指针，如果要想修改一级空指针的值，需要使用二级指针。</p>
<ul>
<li>指针引用间接赋值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Teacher</span><br><span class="line">&#123;</span><br><span class="line">	char name[64];</span><br><span class="line">	int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int getTe(Teacher* &amp;myp)</span><br><span class="line">&#123;</span><br><span class="line">	myp &#x3D; (Teacher *)malloc(sizeof(Teacher));</span><br><span class="line">	if (myp &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	memset(myp, 0, sizeof(Teacher));</span><br><span class="line">	myp-&gt;age &#x3D; 34;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Teacher *p &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">	getTe(p);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;age&#x3D;&quot; &lt;&lt; p-&gt;age &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始 p 是一级空指针引用。</p>
<h2 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h2><h3 id="变量初始化常引用"><a href="#变量初始化常引用" class="headerlink" title="变量初始化常引用"></a>变量初始化常引用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a &#x3D; 100;</span><br><span class="line">	const int &amp; b &#x3D; &amp;a;		&#x2F;&#x2F; 等价于 const int * const b 只读 不能修改</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;b &#x3D; 200;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;b&#x3D;&quot; &lt;&lt; b &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字面量初始化常引用"><a href="#字面量初始化常引用" class="headerlink" title="字面量初始化常引用"></a>字面量初始化常引用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; 普通引用 等同于 int* const a 而字面量 100 是没有地址的</span><br><span class="line">	&#x2F;&#x2F;int&amp; a &#x3D; 100;		</span><br><span class="line">	&#x2F;&#x2F;cout &lt;&lt; &quot;a&#x3D;&quot; &lt;&lt; a &lt;&lt; endl;	&#x2F;&#x2F; error</span><br><span class="line"></span><br><span class="line">	const int&amp; b &#x3D; 100;			&#x2F;&#x2F; 会额外分配内存空间</span><br><span class="line">	cout &lt;&lt; &quot;b&#x3D;&quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>引用是一个C++特有的语法现象！相当于C++编译器对指针再次封装，可以简化指针操作。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>20-cpp-细节语法二</title>
    <url>/2020/02/12/20-cpp-%E7%BB%86%E8%8A%82%E8%AF%AD%E6%B3%95%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C语言字符串类型、友元 学习; 原码、反码和补码学习。<br><a id="more"></a></p>
<h1 id="C-语法细节"><a href="#C-语法细节" class="headerlink" title="C++语法细节"></a>C++语法细节</h1><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>C++可以在函数声明时为参数提供一个默认值。当函数调用没有指定这个参数值得时候，编译器会自动用默认值替代。</p>
<ul>
<li>默认参数写在函数参数列表的后面部分，在默认参数之后不能定义普通参数，也就是默认参数后的所有参数都是默认参数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int func(int a, int b &#x3D; 3, int c &#x3D; 6)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;a&#x3D;&quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;b&#x3D;&quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;c&#x3D;&quot; &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a &#x3D; 1;</span><br><span class="line">	int b &#x3D; 2;</span><br><span class="line">	int c &#x3D; 3;</span><br><span class="line"></span><br><span class="line">	func(a++, b, c);    &#x2F;&#x2F; 1 2 3</span><br><span class="line">	func(a++);          &#x2F;&#x2F; 2 3 6</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="占位参数"><a href="#占位参数" class="headerlink" title="占位参数"></a>占位参数</h2><p>占位参数只有参数类型声明，而没有参数名声明。也就是函数体内部无法使用占位参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第二个参数没有变量名</span><br><span class="line">int func(int a, int , int b)</span><br><span class="line">&#123;</span><br><span class="line">	return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;    func(1, 2); &#x2F;&#x2F; error: too few arguments to function &#39;int func(int, int, int)&#39;|</span><br><span class="line">	cout &lt;&lt; &quot;func(1, 2, 3)&#x3D;&quot; &lt;&lt; func(1, 2, 3) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">&#x2F;&#x2F; 第二个参数没有变量名，但是有默认参数</span><br><span class="line">int func(int a, int &#x3D;0, int b&#x3D;3)</span><br><span class="line">&#123;</span><br><span class="line">	return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;    func(1, 2); &#x2F;&#x2F; error: too few arguments to function &#39;int func(int, int, int)&#39;|</span><br><span class="line">	cout &lt;&lt; &quot;func(1, 2, 3)&#x3D;&quot; &lt;&lt; func(1, 2, 3) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针本质上还是指针。函数名的是指就是函数这段代码的首地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int func(int x)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;x&#x3D;&quot; &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int (*pFunc)(int);    &#x2F;&#x2F; 定义函数指针</span><br><span class="line">    &#x2F;&#x2F; 函数名做右值时加不加&amp;效果一样</span><br><span class="line">    &#x2F;&#x2F; 数组名做右值是不加&amp;表示数组首元素首地址 加&amp;表示数组地址</span><br><span class="line">&#x2F;&#x2F;    pFunc &#x3D; func;</span><br><span class="line">    pFunc &#x3D; &amp;func;</span><br><span class="line"></span><br><span class="line">    pFunc(2);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="typedef初步"><a href="#typedef初步" class="headerlink" title="typedef初步"></a>typedef初步</h2><ul>
<li>typedef 原数据类型 数据类型的别名<br>C/c++中有两种数据类型：一种是编译器定义的原生数据类型；一种是用户自定义类型，比如数组类型、结构体类型、函数类型。<br>由于这些类型往往比较长，我们可以通过typedef的方式进行重命名。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int func(int x)</span><br><span class="line">&#123;</span><br><span class="line">	return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int func(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">	return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int func(const char* s)</span><br><span class="line">&#123;</span><br><span class="line">	return strlen(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; PFUNC就是 int (*)(int , int)类型</span><br><span class="line">&#x2F;&#x2F; 这里重命名类型的方式有点不一样</span><br><span class="line">typedef int(*PFUNC)(int , int);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int c &#x3D; 0;</span><br><span class="line">	PFUNC p &#x3D; func;</span><br><span class="line"></span><br><span class="line">	c &#x3D; p(1, 2);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="对象的动态建立和释放"><a href="#对象的动态建立和释放" class="headerlink" title="对象的动态建立和释放"></a>对象的动态建立和释放</h2><h3 id="new-和-delete的语法"><a href="#new-和-delete的语法" class="headerlink" title="new 和 delete的语法"></a>new 和 delete的语法</h3><p>使用形式：<br>指针变量 = new 类型(常量);    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *p1 &#x3D; new int;</span><br><span class="line">delete p1;</span><br><span class="line"></span><br><span class="line">int *p2 &#x3D; new int(10);	&#x2F;&#x2F; 动态分配int类型空间，并初始化为10</span><br><span class="line">delete p2;</span><br></pre></td></tr></table></figure>
<p>指针变量 = new 类型[表达式];</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *p &#x3D; new int[10];	&#x2F;&#x2F; 动态分配10个int类型的空间</span><br><span class="line">delete p[];</span><br></pre></td></tr></table></figure>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>友元函数破坏了类的封装性。通过在类中设置函数为友元，可以在友元函数中修改类的私有属性。友元函数重要的应用场景在于对输入输出运算符的重载。</p>
<h1 id="leetcode知识"><a href="#leetcode知识" class="headerlink" title="leetcode知识"></a>leetcode知识</h1><h2 id="两数相除"><a href="#两数相除" class="headerlink" title="两数相除"></a><a href="https://leetcode-cn.com/problems/divide-two-integers/" target="_blank" rel="noopener">两数相除</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int divide(int dividend, int divisor) &#123;</span><br><span class="line">		&#x2F;&#x2F; 异或：相同为0 相异为1</span><br><span class="line">		int flag &#x3D; (dividend &gt; 0) ^ (divisor &gt; 0);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 除数不为0,故不需要判断等于除数等于0的情况</span><br><span class="line">		&#x2F;&#x2F; 除数为 -2^31 时需要单独判断  </span><br><span class="line">		if (divisor &#x3D;&#x3D; pow(-2, 31)) &#123;</span><br><span class="line">			if (dividend &#x3D;&#x3D; divisor)</span><br><span class="line">				return 1;</span><br><span class="line">			else</span><br><span class="line">				return 0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;*</span><br><span class="line">		负边界计算</span><br><span class="line">		-2^31   &#x2F; -1 出错   &#x2F;&#x2F; 需要单独计算这种情况</span><br><span class="line">		-2^31   &#x2F;  1 正确</span><br><span class="line"></span><br><span class="line">		-2^31+1 &#x2F; -1 正确   &#x2F;&#x2F; 考虑将 -2^31+1 计算商，然后减1</span><br><span class="line">		-2^31+1 &#x2F;  1 正确</span><br><span class="line"></span><br><span class="line">		正边界计算</span><br><span class="line">		2^31-1  &#x2F; -1 正确</span><br><span class="line">		2^31-1  &#x2F;  1 正确</span><br><span class="line">		*&#x2F;</span><br><span class="line">		int nflag &#x3D; 0;</span><br><span class="line">		int result &#x3D; 0, absdividend &#x3D; 0, absdivisor &#x3D; 0;</span><br><span class="line"></span><br><span class="line">		if (dividend &#x3D;&#x3D; pow(-2, 31)) &#123;</span><br><span class="line">			dividend &#x3D; pow(-2, 31) + 1;</span><br><span class="line">			nflag &#x3D; 1;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		absdividend &#x3D; abs(dividend);</span><br><span class="line">		absdivisor &#x3D; abs(divisor);</span><br><span class="line"></span><br><span class="line">		while (absdividend &gt;&#x3D; absdivisor) &#123;</span><br><span class="line">			int temp_divisor &#x3D; absdivisor;</span><br><span class="line">			int temp_result &#x3D; 1;</span><br><span class="line"></span><br><span class="line">			while (absdividend &gt;&#x3D; (temp_divisor &lt;&lt; 1)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 对于左移来讲，pow(2, 30)是最大的除数 任何除数大于等于 pow(2, 30) 都没有意义</span><br><span class="line">        &#x2F;&#x2F; 当 temp_divisor &lt; pow(2, 30) 时， temp_divisor &lt;&lt; 1 一定小于 pow(2, 31)</span><br><span class="line">				if (temp_divisor &gt;&#x3D; pow(2, 30))</span><br><span class="line">					break;</span><br><span class="line"></span><br><span class="line">				temp_result &#x3D; temp_result &lt;&lt; 1;</span><br><span class="line">				temp_divisor &#x3D; temp_divisor &lt;&lt; 1;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			absdividend &#x3D; absdividend - temp_divisor;</span><br><span class="line">			result +&#x3D; temp_result;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (nflag &#x3D;&#x3D; 1) &#123;</span><br><span class="line">			absdividend &#x3D; -absdividend - 1;</span><br><span class="line">			if (absdividend &#x3D;&#x3D; divisor &amp;&amp; (divisor &#x3D;&#x3D; -1))</span><br><span class="line">				return pow(2, 31) - 1;</span><br><span class="line">			else if (absdividend &#x3D;&#x3D; divisor &amp;&amp; (divisor !&#x3D; -1))</span><br><span class="line">				result++;</span><br><span class="line">			else if (absdividend &#x3D;&#x3D; -divisor &amp;&amp; (dividend &lt; 0))</span><br><span class="line">				return -result - 1;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (flag)</span><br><span class="line">			result &#x3D; -result;</span><br><span class="line"></span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="定点数表示"><a href="#定点数表示" class="headerlink" title="定点数表示"></a>定点数表示</h2><h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h3><p>整个机器字长的全部二进制位均为数值位，没有符号位，原码表示即可。 </p>
<h3 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h3><p>最高位 0 表示正号，1 表示负号。</p>
<h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p>n位机器子长，原码整数取值范围 [-(2^n-1), (2^n-1)]<br>+0 的原码：0000 0000<br>-0 的原码：1000 0000  </p>
<p>原码需要单独计算符号位，并引入绝对值，进行加减法运算，比较麻烦。</p>
<h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><p>正数反码和原码相同；负数反码由 原码 符号位不变，其他位按位取反。<br>n位机器子长，补码整数的表示范围：[-(2^n-1), (2^n-1)]<br>+0 的反码：0111 1111<br>-0 的反码：1111 1111</p>
<h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>正数补码 和原码相同；负数补码 符号位与原码相同，数值位由原码取反加1得到。<br>补码的出现是让计算机只需要做加法就可以完成加减运算。<br>n位机器子长，补码整数的表示范围：[-2^n, 2^n-1]<br>+0 的补码：0000 0000<br>-0 的补码：0000 0000 </p>
<p><img src="/images/20-cpp-细节语法二/01-8位原码反码补码取值范围.jpg" alt="&quot;01-8位原码反码补码取值范围&quot;"></p>
<p>由于原码和反码都需要用两个数表示 +0 和 -0，而补码只需要一个数就可以表示 +0 和 -0。所以可以多表示一个数。</p>
<h2 id="C语言数据类型大小和取值范围"><a href="#C语言数据类型大小和取值范围" class="headerlink" title="C语言数据类型大小和取值范围"></a>C语言数据类型大小和取值范围</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;limits.h&gt;</span><br><span class="line">&#x2F;&#x2F; 取值范围可以用极限值符号(定义在imits.h头文件中)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;CHAR_MIN &#x3D; &quot; &lt;&lt; CHAR_MIN &lt;&lt; &quot; &quot; &lt;&lt; &quot;CHAR_MAX &#x3D; &quot; &lt;&lt; CHAR_MAX &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;INT_MIN &#x3D; &quot; &lt;&lt; INT_MIN &lt;&lt; &quot; &quot; &lt;&lt; &quot;INT_MAX &#x3D; &quot; &lt;&lt; INT_MAX &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;LONG_MIN &#x3D; &quot; &lt;&lt;  LONG_MIN &lt;&lt; &quot; &quot; &lt;&lt; &quot;LONG_MAX &#x3D; &quot; &lt;&lt; LONG_MAX &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;UCHAR_MAX &#x3D; &quot; &lt;&lt; UCHAR_MAX &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;UINT_MAX &#x3D; &quot; &lt;&lt; UINT_MAX &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;UINT_MAX &#x3D; &quot; &lt;&lt; ULONG_MAX &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/20-cpp-细节语法二/02-C语言数据类型取值范围.jpg" alt="&quot;02-C语言数据类型取值范围&quot;"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>计算机中无符号数用原码存即可(其实因为都是整数，原码、反码、补码都一样)；有符号数用补码存。<br>其实原码、反码和补码都只是真值的表示形式而已，只是补码只需要做加法，而其他两种没有这么方便。所以计算机使用补码存有符号数，并且补码还可以多表示一个数。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>21-cpp-构造析构-深浅拷贝</title>
    <url>/2020/02/13/21-cpp-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>类构造函数、析构函数、类做函数参数和函数返回值、深拷贝、浅拷贝 学习。<br><a id="more"></a></p>
<h1 id="类函数"><a href="#类函数" class="headerlink" title="类函数"></a>类函数</h1><p>C++类中与类名相同的成员函数叫做构造函数，构造函数没有返回值，C++默认提供无参构造函数和拷贝构造函数。<br>以下以 Teacher 类对类的性质进行说明。  </p>
<p>public:修饰成员变量和函数，可以在类的内部和类的外部访问<br>protected:修饰的成员变量和函数 只能在类的内部被访问,不能在类的外部访问 子类可以访问<br>private:修饰的成员变量和函数 只能在类的内部被访问,不能在类的外部访问 子类不可以访问</p>
<ol>
<li>类的成员函数和成员变量默认是私有属性</li>
<li>类的成员函数的默认参数只需要声明中定义即可，不需要再次在函数定义中再写一次。否则造成默认参数初始化两次错误。</li>
<li>在函数中创建匿名对象是没有意义的，构造完后就会立即析构。</li>
</ol>
<h2 id="无参构造函数"><a href="#无参构造函数" class="headerlink" title="无参构造函数"></a>无参构造函数</h2><p>C++默认提供无参构造函数，如果程序员手动定义了有参构造函数，必须同时提供无参构造函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Teacher::Teacher()</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;name &#x3D; &quot;&quot;;</span><br><span class="line">    this-&gt;age &#x3D; -1;</span><br><span class="line">    this-&gt;pContent &#x3D; NULL;</span><br><span class="line">    cout &lt;&lt; &quot;Teacher:Teacher()构造函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无参对象创建的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    Teacher t1;</span><br><span class="line">    Teacher t2 &#x3D; &#123;&#125;;</span><br><span class="line">    Teacher t3 &#x3D; Teacher(); &#x2F;&#x2F; 不创建匿名对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有参构造函数"><a href="#有参构造函数" class="headerlink" title="有参构造函数"></a>有参构造函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义中不设置默认参数</span><br><span class="line">Teacher::Teacher(string name, int age, const char* p)</span><br><span class="line">&#123;</span><br><span class="line">	if (p &#x3D;&#x3D; NULL)</span><br><span class="line">		this-&gt;pContent &#x3D; NULL;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		clen &#x3D; strlen(p);</span><br><span class="line">		&#x2F;&#x2F; 堆中申请空间</span><br><span class="line">		this-&gt;pContent &#x3D; new char[clen + 1];</span><br><span class="line">		strcpy(this-&gt;pContent, p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	this-&gt;name &#x3D; name;</span><br><span class="line">	this-&gt;age &#x3D; age;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;Teacher:&quot; &lt;&lt; this-&gt;name &lt;&lt; &quot;的Teacher(int age, string name, char* p)构造函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有参对象创建的三种方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 先创建的对象最后释放</span><br><span class="line">    Teacher t1(&quot;Lucy&quot;, 28);</span><br><span class="line">    Teacher t2 &#x3D; &#123;&quot;Sara&quot;, 28&#125;;</span><br><span class="line">    Teacher t3 &#x3D; Teacher(&quot;Bob&quot;, 28);	&#x2F;&#x2F; 不创建匿名对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>拷贝构造函数默认是浅拷贝，所有的成员变量都会拷贝一份值。如果在复制的过程中存在指针指向某一个动态分配的内存空间，则会有两个指针同时指向同一块内存空间。如果一个对象析构，会导致动态分配的内存空间被析构。则另一个对象访问该内存空间的时候就会出现段错误或者乱码。</p>
<ul>
<li>浅拷贝</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Teacher::Teacher(const Teacher&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;age &#x3D; obj.age;</span><br><span class="line">    this-&gt;name &#x3D; obj.name;</span><br><span class="line">    this-&gt;pContent &#x3D; obj.pContent;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Teacher:&quot; &lt;&lt; this-&gt;name &lt;&lt; &quot;的Teacher(const Teacher&amp; obj)拷贝构造函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 先创建的对象最后释放</span><br><span class="line">    Teacher t1(&quot;Lucy&quot;, 28, &quot;this is lucy&quot;);</span><br><span class="line">    Teacher t2 &#x3D; t1;    &#x2F;&#x2F; 此时,拷贝构造函数执行浅拷贝</span><br><span class="line">    t1.~Teacher();      &#x2F;&#x2F; 析构后会释放空间</span><br><span class="line">    cout &lt;&lt; t2.getContent() &lt;&lt; endl;    &#x2F;&#x2F; &#x2F;&#x2F; codeblock乱码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>深拷贝</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Teacher::Teacher(const Teacher&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;name &#x3D; obj.name;</span><br><span class="line">	this-&gt;age &#x3D; obj.age;</span><br><span class="line"></span><br><span class="line">	if (obj.pContent &#x3D;&#x3D; NULL)</span><br><span class="line">		this-&gt;pContent &#x3D; NULL;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		clen &#x3D; strlen(obj.pContent);</span><br><span class="line">		&#x2F;&#x2F; 堆中申请空间</span><br><span class="line">		this-&gt;pContent &#x3D; new char[clen + 1];</span><br><span class="line">		strcpy(this-&gt;pContent, obj.pContent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;Teacher:&quot; &lt;&lt; this-&gt;name &lt;&lt; &quot;的Teacher(const Teacher&amp; obj)拷贝构造函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 先创建的对象最后释放</span><br><span class="line">    Teacher t1(&quot;Lucy&quot;, 28, &quot;this is lucy&quot;);</span><br><span class="line">    Teacher t2 &#x3D; t1;    &#x2F;&#x2F; 此时,拷贝构造函数执行浅拷贝</span><br><span class="line">    t1.~Teacher();      &#x2F;&#x2F; 析构后会释放空间</span><br><span class="line">    cout &lt;&lt; t2.getContent() &lt;&lt; endl;    &#x2F;&#x2F; this is lucy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="等号操作符"><a href="#等号操作符" class="headerlink" title="等号操作符"></a>等号操作符</h2><p>等号操作符C++默认提供浅拷贝。</p>
<ul>
<li>浅拷贝</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Teacher&amp; Teacher::operator&#x3D;(Teacher&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;name &#x3D; obj.name;</span><br><span class="line">	this-&gt;age &#x3D; obj.age;</span><br><span class="line">    this-&gt;pContent &#x3D; obj.pContent;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;Teacher:&quot; &lt;&lt; this-&gt;name &lt;&lt; &quot;的operator&#x3D;(Teacher&amp; obj)等号操作符重载函数&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    Teacher t1 &#x3D; Teacher(&quot;Lucy&quot;, 28, &quot;this is lucy&quot;);	&#x2F;&#x2F; 初始化，调用有参构造函数</span><br><span class="line">    Teacher t2;</span><br><span class="line"></span><br><span class="line">    t2 &#x3D; t1;</span><br><span class="line">    t1.~Teacher();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; t2.getContent() &lt;&lt; endl;		&#x2F;&#x2F; codeblock乱码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>深拷贝</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 重载等号操作符，进行深拷贝</span><br><span class="line">Teacher&amp; Teacher::operator&#x3D;(Teacher&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;name &#x3D; obj.name;</span><br><span class="line">	this-&gt;age &#x3D; obj.age;</span><br><span class="line"></span><br><span class="line">    if (obj.pContent &#x3D;&#x3D; NULL)</span><br><span class="line">		this-&gt;pContent &#x3D; NULL;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		clen &#x3D; strlen(obj.pContent);</span><br><span class="line">		&#x2F;&#x2F; 堆中申请空间</span><br><span class="line">		this-&gt;pContent &#x3D; new char[clen + 1];</span><br><span class="line">		strcpy(this-&gt;pContent, obj.pContent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;Teacher:&quot; &lt;&lt; this-&gt;name &lt;&lt; &quot;的operator&#x3D;(Teacher&amp; obj)等号操作符重载函数&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>void test()<br>{<br>    Teacher t1 = Teacher(“Lucy”, 28, “this is lucy”);    // 初始化，调用有参构造函数<br>    Teacher t2;        // 调用无参构造函数</p>
<pre><code>// 非初始化，调用等号操作符操作
t2 = t1;
t1.~Teacher();

cout &lt;&lt; t2.getContent() &lt;&lt; endl;    // this is lucy
</code></pre><p>}</p>
<h2 id="重载-lt-lt-操作符"><a href="#重载-lt-lt-操作符" class="headerlink" title="重载&lt;&lt;操作符"></a>重载&lt;&lt;操作符</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; out, const Teacher&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; &quot;name&#x3D;&quot; &lt;&lt; obj.name &lt;&lt; &quot;,age&#x3D;&quot; &lt;&lt; obj.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    Teacher t &#x3D; &#123;&quot;simon&quot;, 25&#125;;</span><br><span class="line">    cout &lt;&lt; t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>C++类中与类名相同，并且类名前有~的成员函数叫做析构函数。析构函数没有参数也没有任何返回值。<br>在类对象销毁时自动调用析构函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Teacher::~Teacher()</span><br><span class="line">&#123;</span><br><span class="line">    if(this-&gt;pContent !&#x3D; NULL)</span><br><span class="line">        delete[] this-&gt;pContent;    &#x2F;&#x2F; 析构动态分配的内存空间</span><br><span class="line"></span><br><span class="line">    if(this-&gt;name &#x3D;&#x3D; &quot;&quot;)</span><br><span class="line">        cout &lt;&lt; &quot;Teacher:&quot; &lt;&lt; &quot;~Teacher()析构函数&quot; &lt;&lt; endl;</span><br><span class="line">    else</span><br><span class="line">        cout &lt;&lt; &quot;Teacher:&quot; &lt;&lt; this-&gt;name &lt;&lt; &quot;的~Teacher()的析构函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造函数初始化方法"><a href="#构造函数初始化方法" class="headerlink" title="构造函数初始化方法"></a>构造函数初始化方法</h2><p>本节通过student类说明构造函数的初始化方法。</p>
<ol>
<li>常量需要在定义类对象的时候初始化，声明的时候不能初始化。</li>
<li>默认参数写在声明中，不要写在定义中。</li>
<li>初始化列表写在定义中，不要写在声明中。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;teacher.h&quot;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F; 默认参数写在声明中，不要写在定义中</span><br><span class="line">	Student(string name&#x3D;&quot;&quot;, int age&#x3D;-1);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 初始化列表写在定义中，不要写在声明中</span><br><span class="line">	Student(string name, int age, string m_name, int m_age, string e_name, int e_age);</span><br><span class="line">	virtual ~Student();</span><br><span class="line"></span><br><span class="line">	string getSchoolName();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string name;</span><br><span class="line">	int age;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Student类中包含Teacher类</span><br><span class="line">	Teacher englishTeacher;</span><br><span class="line">	Teacher mathTeacher;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 常量</span><br><span class="line">	const string schoolName;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>student.cpp</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 常量需要在定义类对象的时候初始化，声明的时候不能初始化</span><br><span class="line">&#x2F;&#x2F; 默认参数写在声明中，不要写在定义中。</span><br><span class="line">Student::Student(string name, int age) : schoolName(&quot;HIT&quot;)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;name &#x3D; name;</span><br><span class="line">    this-&gt;age &#x3D; age;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;Student 无参构造函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化列表写在定义中，不要写在声明中</span><br><span class="line">&#x2F;&#x2F; Student 类中包含Teacher 类对象的初始化，Teacher 类对象按照定义顺序进行初始化，最后初始化Student 类对象</span><br><span class="line">&#x2F;&#x2F; 析构的顺序与构造的顺序相反，先析构Student 类对象，然后析构Teacher 类对象(先初始化的类对象先析构，后初始化的对象后析构)</span><br><span class="line">Student::Student(string name, int age, string m_name, int m_age, string e_name, int e_age) : mathTeacher(m_name, m_age), englishTeacher(e_name, e_age), schoolName(&quot;HIT&quot;)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;name &#x3D; name;</span><br><span class="line">	this-&gt;age &#x3D; age;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;Student:&quot; &lt;&lt; this-&gt;name &lt;&lt; &quot;有参构造函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student::~Student()</span><br><span class="line">&#123;</span><br><span class="line">    if(this-&gt;name &#x3D;&#x3D; &quot;&quot;)</span><br><span class="line">        cout &lt;&lt; &quot;Student 的析构函数&quot; &lt;&lt; endl;</span><br><span class="line">    else</span><br><span class="line">        cout &lt;&lt; &quot;Student:&quot; &lt;&lt; this-&gt;name &lt;&lt; &quot;的析构函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string Student::getSchoolName()</span><br><span class="line">&#123;</span><br><span class="line">    return this-&gt;schoolName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">	Student student(&quot;Simon&quot;, 25, &quot;Lucy&quot;, 35, &quot;Bob&quot;, 32);</span><br><span class="line">	cout &lt;&lt; student.getSchoolName() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类做函数参数与函数返回值"><a href="#类做函数参数与函数返回值" class="headerlink" title="类做函数参数与函数返回值"></a>类做函数参数与函数返回值</h1><h2 id="类做函数参数调用拷贝构造函数"><a href="#类做函数参数调用拷贝构造函数" class="headerlink" title="类做函数参数调用拷贝构造函数"></a>类做函数参数调用拷贝构造函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 调用拷贝构造函数</span><br><span class="line">void classAsFormalParameter(Teacher t)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; t.getContent() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不构成函数重载</span><br><span class="line">void classAsFormalParameter(Teacher &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; t.getContent() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">	Teacher t &#x3D; Teacher(&quot;lucy&quot;, 28, &quot;this is lucy&quot;);   &#x2F;&#x2F; 调用有参构造函数</span><br><span class="line">	classAsFormalParameter(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类做函数返回值调用拷贝构造函数"><a href="#类做函数返回值调用拷贝构造函数" class="headerlink" title="类做函数返回值调用拷贝构造函数"></a>类做函数返回值调用拷贝构造函数</h2><p>类做函数返回值调用拷贝构造函数或等号操作符函数，返回一个匿名对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 为什么形参不能是引用？原因是匿名对象没有名字，也就没有别名</span><br><span class="line">&#x2F;&#x2F; Teacher&amp; Teacher::operator&#x3D;(Teacher&amp; obj)</span><br><span class="line">Teacher&amp; Teacher::operator&#x3D;(Teacher obj)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;name &#x3D; obj.name;</span><br><span class="line">	this-&gt;age &#x3D; obj.age;</span><br><span class="line"></span><br><span class="line">    if (obj.pContent &#x3D;&#x3D; NULL)</span><br><span class="line">		this-&gt;pContent &#x3D; NULL;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		clen &#x3D; strlen(obj.pContent);</span><br><span class="line">		&#x2F;&#x2F; 堆中申请空间</span><br><span class="line">		this-&gt;pContent &#x3D; new char[clen + 1];</span><br><span class="line">		strcpy(this-&gt;pContent, obj.pContent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;Teacher:&quot; &lt;&lt; this-&gt;name &lt;&lt; &quot;的operator&#x3D;(Teacher&amp; obj)等号操作符重载函数&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Teacher ClassAsReturnValue()</span><br><span class="line">&#123;</span><br><span class="line">	Teacher t &#x3D; &#123;&quot;simon&quot;, 25&#125;;        &#x2F;&#x2F; 调用有参构造函数</span><br><span class="line"></span><br><span class="line">	return t;                           &#x2F;&#x2F; 调用拷贝构造函数，产生匿名对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">	Teacher t1 &#x3D; Teacher(&quot;Lucy&quot;, 28);   &#x2F;&#x2F; 调用有参构造函数</span><br><span class="line">	t1 &#x3D; ClassAsReturnValue();          &#x2F;&#x2F; 调用等号操作符，匿名对象被析构</span><br><span class="line"></span><br><span class="line">	Teacher t2 &#x3D; ClassAsReturnValue();    &#x2F;&#x2F; 不调用等号操作符，匿名对象直接作为t2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- teacher.h</span><br></pre></td></tr></table></figure>
<h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <string.h></h1><p>using namespace std;</p>
<p>class Teacher   // Teacher是类 类型<br>{<br>public:<br>    Teacher();<br>    Teacher(string name, int age, const char* p = NULL);<br>    Teacher(const Teacher&amp; obj);<br>    //Teacher&amp; operator=(Teacher obj);<br>    Teacher&amp; operator=(Teacher&amp; obj);<br>    ~Teacher();</p>
<pre><code>char* getContent();
void setContent(const char* p);
</code></pre><p>private:<br>    int age;<br>    string name;<br>    char* pContent;<br>    int clen;<br>};</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- teacher.cpp</span><br></pre></td></tr></table></figure>
<h1 id="include-“teacher-h”"><a href="#include-“teacher-h”" class="headerlink" title="include “teacher.h”"></a>include “teacher.h”</h1><p>Teacher::Teacher()<br>{<br>    this-&gt;name = “”;<br>    this-&gt;age = -1;<br>    this-&gt;pContent = NULL;<br>    cout &lt;&lt; “Teacher:Teacher()构造函数” &lt;&lt; endl;<br>}</p>
<p>// 定义中不设置默认参数<br>Teacher::Teacher(string name, int age, const char* p)<br>{<br>    this-&gt;name = name;<br>    this-&gt;age = age;</p>
<pre><code>if (p == NULL)
    this-&gt;pContent = NULL;
else
{
    clen = strlen(p);
    // 堆中申请空间
    this-&gt;pContent = new char[clen + 1];
    strcpy(this-&gt;pContent, p);
}

cout &lt;&lt; &quot;Teacher:&quot; &lt;&lt; this-&gt;name &lt;&lt; &quot;的Teacher(int age, string name, char* p)构造函数&quot; &lt;&lt; endl;
</code></pre><p>}</p>
<p>//Teacher::Teacher(const Teacher&amp; obj)<br>//{<br>//    this-&gt;age = obj.age;<br>//    this-&gt;name = obj.name;<br>//    this-&gt;pContent = obj.pContent;<br>//<br>//    cout &lt;&lt; “Teacher:” &lt;&lt; this-&gt;name &lt;&lt; “的Teacher(const Teacher&amp; obj)拷贝构造函数” &lt;&lt; endl;<br>//}</p>
<p>Teacher::Teacher(const Teacher&amp; obj)<br>{<br>    this-&gt;name = obj.name;<br>    this-&gt;age = obj.age;</p>
<pre><code>if (obj.pContent == NULL)
    this-&gt;pContent = NULL;
else
{
    clen = strlen(obj.pContent);
    // 堆中申请空间
    this-&gt;pContent = new char[clen + 1];
    strcpy(this-&gt;pContent, obj.pContent);
}

cout &lt;&lt; &quot;Teacher:&quot; &lt;&lt; this-&gt;name &lt;&lt; &quot;的Teacher(const Teacher&amp; obj)拷贝构造函数&quot; &lt;&lt; endl;
</code></pre><p>}</p>
<p>//Teacher&amp; Teacher::operator=(Teacher&amp; obj)<br>//{<br>//    this-&gt;name = obj.name;<br>//    this-&gt;age = obj.age;<br>//    this-&gt;pContent = obj.pContent;<br>//<br>//    cout &lt;&lt; “Teacher:” &lt;&lt; this-&gt;name &lt;&lt; “的operator=(Teacher&amp; obj)等号操作符重载函数” &lt;&lt; endl;<br>//<br>//    return *this;<br>//}</p>
<p>//Teacher&amp; Teacher::operator=(Teacher obj)<br>Teacher&amp; Teacher::operator=(Teacher&amp; obj)<br>{<br>    this-&gt;name = obj.name;<br>    this-&gt;age = obj.age;</p>
<pre><code>if (obj.pContent == NULL)
    this-&gt;pContent = NULL;
else
{
    clen = strlen(obj.pContent);
    // 堆中申请空间
    this-&gt;pContent = new char[clen + 1];
    strcpy(this-&gt;pContent, obj.pContent);
}

cout &lt;&lt; &quot;Teacher:&quot; &lt;&lt; this-&gt;name &lt;&lt; &quot;的operator=(Teacher&amp; obj)等号操作符重载函数&quot; &lt;&lt; endl;

return *this;
</code></pre><p>}</p>
<p>Teacher::~Teacher()<br>{<br>    if(this-&gt;pContent != NULL)<br>        delete[] this-&gt;pContent;    // 析构动态分配的内存空间</p>
<pre><code>if(this-&gt;name == &quot;&quot;)
    cout &lt;&lt; &quot;Teacher:&quot; &lt;&lt; &quot;~Teacher()析构函数&quot; &lt;&lt; endl;
else
    cout &lt;&lt; &quot;Teacher:&quot; &lt;&lt; this-&gt;name &lt;&lt; &quot;的~Teacher()的析构函数&quot; &lt;&lt; endl;
</code></pre><p>}</p>
<p>char* Teacher::getContent()<br>{<br>    return this-&gt;pContent;<br>}</p>
<p>void Teacher::setContent(const char* p)<br>{<br>    if (p == NULL)<br>        this-&gt;pContent = NULL;<br>    else<br>    {<br>        clen = strlen(p);<br>        // 堆中申请空间<br>        this-&gt;pContent = new char[clen + 1];<br>        strcpy(this-&gt;pContent, p);<br>    }<br>}</p>
<p>// 调用拷贝构造函数<br>void classAsFormalParameter(Teacher t)<br>{<br>    cout &lt;&lt; t.getContent() &lt;&lt; endl;<br>}</p>
<p>//void classAsFormalParameter(Teacher &amp;t)<br>//{<br>//    cout &lt;&lt; t.getContent() &lt;&lt; endl;<br>//}</p>
<p>Teacher ClassAsReturnValue()<br>{<br>    Teacher t = {“simon”, 25};        // 调用有参构造函数</p>
<pre><code>return t;                          // 调用拷贝构造函数，产生匿名对象
</code></pre><p>}</p>
<p>ostream&amp; operator&lt;&lt;(ostream&amp; out, const Teacher&amp; obj)<br>{<br>    out &lt;&lt; “name=” &lt;&lt; obj.name &lt;&lt; “,age=” &lt;&lt; obj.age &lt;&lt; endl;<br>}<br><code>
</code></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>析构函数还存在虚析构函数的问题。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>22-cpp-重载</title>
    <url>/2020/02/14/22-cpp-%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a>
<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><h2 id="函数重载的条件"><a href="#函数重载的条件" class="headerlink" title="函数重载的条件"></a>函数重载的条件</h2><p>函数重载就是使用同一个函数名定义不同的函数。函数重载和形参有关，<font color="red">与返回值无关</font>。<br>形参的三个条件可以产生函数重载：</p>
<ul>
<li>参数个数不同</li>
<li>参数类型不同</li>
<li>参数顺序不同</li>
</ul>
<p>重载函数的函数类型不同，本质上是相互独立的不同函数。设计函数重载时，注意不要产生二义性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int func(int x)</span><br><span class="line">&#123;</span><br><span class="line">	return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;默认参数导致二义性产生</span><br><span class="line">&#x2F;&#x2F;int func(int a, int b&#x3D;0)</span><br><span class="line">&#x2F;&#x2F;&#123;</span><br><span class="line">&#x2F;&#x2F;	return a + b;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">int func(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">	return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int func(const char* s)</span><br><span class="line">&#123;</span><br><span class="line">	return strlen(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int c &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	c &#x3D; func(1);</span><br><span class="line">	cout &lt;&lt; &quot;c&#x3D;&quot; &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	c &#x3D; func(1, 2);</span><br><span class="line">	cout &lt;&lt; &quot;c&#x3D;&quot; &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	c &#x3D; func(&quot;12345&quot;);</span><br><span class="line">	cout &lt;&lt; &quot;c&#x3D;&quot; &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>运算符重载本质上就是函数，可以写成全局函数的形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 运算符本质上是函数，通过函数形式也可以调用</span><br><span class="line">&#x2F;&#x2F; operator+经过变成类的成员函数或者友元函数就可以通过运算符的形式访问</span><br><span class="line">Complexes operator+(Complexes &amp;c1, Complexes &amp;c2) &#123;</span><br><span class="line"></span><br><span class="line">	Complexes tmp(c1.getA() + c2.getA(), c1.getB() + c2.getB());</span><br><span class="line"></span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 成员函数形式：</span><br><span class="line">Complexes operator-(Complexes&amp; c) &#123;</span><br><span class="line">	return Complexes(this-&gt;a - c.a, this-&gt;b - c.b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 友元函数声明</span><br><span class="line">friend Complexes operator*(Complexes&amp; c1, Complexes&amp; c2);</span><br><span class="line">&#x2F;&#x2F; 友元函数</span><br><span class="line">Complexes operator*(Complexes&amp; c1, Complexes&amp; c2) &#123;</span><br><span class="line">	return Complexes((c1.a*c2.a - c1.b*c2.b), </span><br><span class="line">		(c1.a*c2.b + c2.a*c1.b));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 与全局函数对比可知，全局函数不能直接访问类的私有属性，但是友元函数可以</span><br></pre></td></tr></table></figure>
<h2 id="运算符重载：-lt-lt-gt-gt-lt-gt"><a href="#运算符重载：-lt-lt-gt-gt-lt-gt" class="headerlink" title="运算符重载：&lt;&lt; &gt;&gt; == != [] &lt; &gt;"></a>运算符重载：&lt;&lt; &gt;&gt; == != [] &lt; &gt;</h2><p>运算符重载本质上是一个函数。运算符重载有两种方式：友元函数形式和成员函数形式。<br>一般重载 输入和输出操作符 使用友元函数，重载其他操作符使用成员函数。</p>
<p>可以重载的运算符<br><img src="/images/29-cpp-重载/01-可重载的运算符.png" alt="&quot;01-可重载的运算符&quot;"></p>
<p>重载运算符函数可以对运算符做出新的解释，但原有基本语义不变：</p>
<ul>
<li>不改变运算符的优先级</li>
<li>不改变运算符的结合性</li>
<li>不改变运算符所需要的操作数</li>
<li>不能创建新的运算符</li>
</ul>
<p>运算符与结合性：<br><img src="/images/29-cpp-重载/02-运算符和结合性一.png" alt="&quot;02-运算符和结合性一&quot;"><br><img src="/images/29-cpp-重载/03-运算符和结合性二.png" alt="&quot;03-运算符和结合性二&quot;"></p>
<h3 id="MyString重载案例"><a href="#MyString重载案例" class="headerlink" title="MyString重载案例"></a>MyString重载案例</h3><ul>
<li>MyString</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class MyString</span><br><span class="line">&#123;</span><br><span class="line">	friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyString&amp; s);</span><br><span class="line">	friend istream&amp; operator&gt;&gt;(istream&amp; in, MyString&amp; s);</span><br><span class="line">public:</span><br><span class="line">	MyString(int len &#x3D; 0);</span><br><span class="line">	MyString(const char* p);</span><br><span class="line">	MyString(const MyString&amp; s);</span><br><span class="line">	~MyString();</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 重载等号操作符</span><br><span class="line">	MyString&amp; operator&#x3D;(MyString&amp; s);</span><br><span class="line">	MyString&amp; operator&#x3D;(const char* p);</span><br><span class="line">	&#x2F;&#x2F; 重载[] 操作符</span><br><span class="line">	char&amp; operator[](int index);</span><br><span class="line">	&#x2F;&#x2F; 重载 &#x3D;&#x3D; 操作符</span><br><span class="line">	&#x2F;&#x2F; const表示 this常量指针所指向的空间为常量，不可修改</span><br><span class="line">	bool operator&#x3D;&#x3D;(const MyString&amp; s) const;</span><br><span class="line">	&#x2F;&#x2F; 重载 !&#x3D; 操作符</span><br><span class="line">	bool operator!&#x3D;(const MyString&amp; s) const;</span><br><span class="line">	&#x2F;&#x2F; 重载 &gt; 操作符</span><br><span class="line">	int operator&gt;(const MyString&amp; s) const;</span><br><span class="line">	&#x2F;&#x2F; 重载 &lt; 操作符</span><br><span class="line">	int operator&lt;(const MyString&amp; s) const;</span><br><span class="line"></span><br><span class="line">	int getLength();</span><br><span class="line">	void setLength(int len);</span><br><span class="line">	</span><br><span class="line">private:</span><br><span class="line">	int len;</span><br><span class="line">	char* p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>MyString.cpp</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &quot;MyString.h&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回引用以便 连续输出</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; out, MyString&amp; s) &#123;</span><br><span class="line">	cout &lt;&lt; s.p;</span><br><span class="line"></span><br><span class="line">	return out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream&amp; operator&gt;&gt;(istream&amp; in, MyString&amp; s) &#123;</span><br><span class="line">	cin &gt;&gt; s.p;</span><br><span class="line"></span><br><span class="line">	return in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString::MyString(int len)&#123;</span><br><span class="line">	if (len &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		this-&gt;len &#x3D; 0;</span><br><span class="line">		this-&gt;p &#x3D; new char[this-&gt;len + 1];</span><br><span class="line">		strcpy(this-&gt;p, &quot;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		this-&gt;len &#x3D; len;</span><br><span class="line">		this-&gt;p &#x3D; new char[this-&gt;len + 1];</span><br><span class="line">		memset(this-&gt;p, 0, this-&gt;len);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString::MyString(const char* p)&#123;</span><br><span class="line">	if (p &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		this-&gt;len &#x3D; 0;</span><br><span class="line">		this-&gt;p &#x3D; new char[this-&gt;len + 1];</span><br><span class="line">		strcpy(this-&gt;p, &quot;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		this-&gt;len &#x3D; strlen(p);</span><br><span class="line">		this-&gt;p &#x3D; new char[this-&gt;len + 1];</span><br><span class="line">		strcpy(this-&gt;p, p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString::MyString(const MyString&amp; s) &#123;</span><br><span class="line">	this-&gt;len &#x3D; s.len;</span><br><span class="line">	this-&gt;p &#x3D; new char[this-&gt;len + 1];</span><br><span class="line">	strcpy(this-&gt;p, s.p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回引用以便连续赋值</span><br><span class="line">MyString&amp; MyString::operator&#x3D;(MyString&amp; s)&#123;</span><br><span class="line">	if (this-&gt;p !&#x3D; NULL) &#123;</span><br><span class="line">		delete[] this-&gt;p;</span><br><span class="line">		this-&gt;p &#x3D; NULL;</span><br><span class="line">		this-&gt;len &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	this-&gt;len &#x3D; s.len;</span><br><span class="line">	this-&gt;p &#x3D; new char[this-&gt;len + 1];</span><br><span class="line">	strcpy(this-&gt;p, s.p);</span><br><span class="line"></span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString&amp; MyString::operator&#x3D;(const char* p)&#123;</span><br><span class="line">	if (this-&gt;p !&#x3D; NULL) &#123;</span><br><span class="line">		delete[] this-&gt;p;</span><br><span class="line">		this-&gt;p &#x3D; NULL;</span><br><span class="line">		this-&gt;len &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	this-&gt;len &#x3D; strlen(p);</span><br><span class="line">	this-&gt;p &#x3D; new char[this-&gt;len + 1];</span><br><span class="line">	strcpy(this-&gt;p, p);</span><br><span class="line"></span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char&amp; MyString::operator[](int index) &#123;</span><br><span class="line">	return this-&gt;p[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool MyString::operator&#x3D;&#x3D;(const MyString&amp; s) const &#123;</span><br><span class="line">	if (this-&gt;len !&#x3D; s.len)</span><br><span class="line">		return false;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; strcmp相等返回0 大于返回1 小于返回-1</span><br><span class="line">	return !strcmp(this-&gt;p, s.p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool MyString::operator!&#x3D;(const MyString&amp; s) const</span><br><span class="line">&#123;</span><br><span class="line">	return !(*this &#x3D;&#x3D; s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int MyString::operator&gt;(const MyString&amp; s) const &#123;</span><br><span class="line">	return strcmp(this-&gt;p, s.p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int MyString::operator&lt;(const MyString&amp; s) const &#123;</span><br><span class="line">	return strcmp(s.p, this-&gt;p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString::~MyString()&#123;</span><br><span class="line">	if (this-&gt;p !&#x3D; NULL) &#123;</span><br><span class="line">		delete[] this-&gt;p;</span><br><span class="line">		this-&gt;len &#x3D; 0;</span><br><span class="line">		this-&gt;p &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MyString::setLength(int len)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;len &#x3D; len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int MyString::getLength()</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前置-后置-和—的重载"><a href="#前置-后置-和—的重载" class="headerlink" title="前置/后置++和—的重载"></a>前置/后置++和—的重载</h2><p>前置/后置++和—的运算符重载函数的函数名和参数相同，为了区分前置/后置。前置—需要加上占位参数。<br>并且前置—返回值引用，原因是—c1 是先对 c1 的值减1，然后返回。后置—返回普通变量，原因是后置—是先返回值，然后减1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; c1--;	&#x2F;&#x2F; 后--</span><br><span class="line">Complexes operator--(int) &#123;</span><br><span class="line">	Complexes tmp &#x3D; *this;</span><br><span class="line">	this-&gt;a--;</span><br><span class="line">	this-&gt;b--;</span><br><span class="line"></span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; --c1;	&#x2F;&#x2F; 前--</span><br><span class="line">Complexes&amp; operator--() &#123;</span><br><span class="line">	this-&gt;a--;</span><br><span class="line">	this-&gt;b--;</span><br><span class="line"></span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; c2++;	&#x2F;&#x2F; 后++</span><br><span class="line">Complexes operator++(int) &#123;</span><br><span class="line">	Complexes tmp &#x3D; *this;</span><br><span class="line">	this-&gt;a++;</span><br><span class="line">	this-&gt;b++;</span><br><span class="line"></span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ++c2;	&#x2F;&#x2F; 前++	</span><br><span class="line">&#x2F;&#x2F; 注意：前++返回的是变量，不是引用</span><br><span class="line">Complexes&amp; operator++() &#123;</span><br><span class="line">	this-&gt;a++;</span><br><span class="line">	this-&gt;b++;</span><br><span class="line"></span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Complexes.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Complexes</span><br><span class="line">&#123;</span><br><span class="line">	friend Complexes operator*(Complexes&amp; c1, Complexes&amp; c2);</span><br><span class="line">public:</span><br><span class="line">	Complexes(int a &#x3D; 0, int b &#x3D; 0);</span><br><span class="line">	~Complexes();</span><br><span class="line"></span><br><span class="line">	int getA();</span><br><span class="line">	int getB();</span><br><span class="line">	void getComplexes();</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 变成成员函数</span><br><span class="line">	Complexes operator-(Complexes&amp; c);</span><br><span class="line">	&#x2F;&#x2F; c1--;	&#x2F;&#x2F; 后--</span><br><span class="line">	Complexes operator--(int);</span><br><span class="line">	&#x2F;&#x2F; --c1;	&#x2F;&#x2F; 前--</span><br><span class="line">	Complexes&amp; operator--();</span><br><span class="line">	&#x2F;&#x2F; c2++;	&#x2F;&#x2F; 后++</span><br><span class="line">	Complexes operator++(int);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; ++c2;	&#x2F;&#x2F; 前++	</span><br><span class="line">	&#x2F;&#x2F; 注意：前++返回的是变量，不是引用</span><br><span class="line">	Complexes&amp; operator++();</span><br><span class="line">private:</span><br><span class="line">	int a;</span><br><span class="line">	int b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complexes operator+(Complexes &amp;c1, Complexes &amp;c2);</span><br></pre></td></tr></table></figure>
<ul>
<li>Complexes.cpp</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &quot;Complexes.h&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 运算符本质上是函数，通过函数形式也可以调用</span><br><span class="line">&#x2F;&#x2F; operator+经过变成类的成员函数或者友元函数就可以通过运算符的形式访问</span><br><span class="line">Complexes operator+(Complexes &amp;c1, Complexes &amp;c2) &#123;</span><br><span class="line"></span><br><span class="line">	Complexes tmp(c1.getA() + c2.getA(), c1.getB() + c2.getB());</span><br><span class="line"></span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complexes operator*(Complexes&amp; c1, Complexes&amp; c2) &#123;</span><br><span class="line">	return Complexes((c1.a*c2.a - c1.b*c2.b),</span><br><span class="line">		(c1.a*c2.b + c2.a*c1.b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complexes::Complexes(int a &#x3D; 0, int b &#x3D; 0) &#123;</span><br><span class="line">	this-&gt;a &#x3D; a;</span><br><span class="line">	this-&gt;b &#x3D; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Complexes::getA() &#123;</span><br><span class="line">	return this-&gt;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Complexes::getB() &#123;</span><br><span class="line">	return this-&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Complexes::getComplexes() &#123;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; &quot;+&quot; &lt;&lt; b &lt;&lt; &quot;i&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 变成成员函数</span><br><span class="line">Complexes Complexes::operator-(Complexes&amp; c) &#123;</span><br><span class="line">	return Complexes(this-&gt;a - c.a, this-&gt;b - c.b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; c1--;	&#x2F;&#x2F; 后--</span><br><span class="line">Complexes Complexes::operator--(int) &#123;</span><br><span class="line">	Complexes tmp &#x3D; *this;</span><br><span class="line">	this-&gt;a--;</span><br><span class="line">	this-&gt;b--;</span><br><span class="line"></span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complexes&amp; Complexes::operator--() &#123;</span><br><span class="line">	this-&gt;a--;</span><br><span class="line">	this-&gt;b--;</span><br><span class="line"></span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; c2++;	&#x2F;&#x2F; 后++</span><br><span class="line">Complexes Complexes::operator++(int) &#123;</span><br><span class="line">	Complexes tmp &#x3D; *this;</span><br><span class="line">	this-&gt;a++;</span><br><span class="line">	this-&gt;b++;</span><br><span class="line"></span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complexes&amp; Complexes::operator++() &#123;</span><br><span class="line">	this-&gt;a++;</span><br><span class="line">	this-&gt;b++;</span><br><span class="line"></span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complexes::~Complexes()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="逻辑运算符-amp-amp-和-的重载"><a href="#逻辑运算符-amp-amp-和-的重载" class="headerlink" title="逻辑运算符&amp;&amp;和||的重载"></a>逻辑运算符&amp;&amp;和||的重载</h2><p>逻辑运算符的短路规则重载之后不起作用。短路规则是指两个元素做逻辑运算，如果第一个元素就不满足逻辑运算就会直接输出结果。<br>如 a=0, b=1。a &amp;&amp; b 不会计算 b，因为 a=0 表示逻辑与的结果为0；<br>在如 a=1, b=0。a || b 不会计算 b，因为 a=1 表示逻辑或的结果为1。<br>但是重载之后，短路规则失效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">public:</span><br><span class="line">	Test(int i&#x3D;0) &#123;</span><br><span class="line">		this-&gt;i &#x3D; i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Test operator+(const Test&amp; obj) &#123;</span><br><span class="line">		Test tmp;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; &quot;operator+被执行&quot; &lt;&lt; endl;</span><br><span class="line">		return Test(this-&gt;i + obj.i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool operator&amp;&amp;(const Test&amp; obj) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;operator&amp;&amp;被执行&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		return this-&gt;i &amp;&amp; obj.i;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	int i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Test t1, t2(0);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; + 的优先级 高于 &amp;&amp;</span><br><span class="line">	if (t2 &amp;&amp; t1 + t2)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;&amp;&amp;的重载无法实现短路规则&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="重载、重写、重定义"><a href="#重载、重写、重定义" class="headerlink" title="重载、重写、重定义"></a>重载、重写、重定义</h1><p>函数重载：必须在同一个类中进行，子类无法重载父类的函数，父类同名函数将被<font color="red">名称覆盖</font>，重载是在编译期间根据参数类型和个数决定函数调用。<br>函数重写：发生在父类和子类之间，并且父类和子类的函数必须名称相同。<br>若父类和子类之间名称相同的函数没有加virtual关键字，则称为重定义。<br>若父类和子类之间名称相同的函数有加上virtual关键字，则构成多态。</p>
<ul>
<li>overLoadAndoverWrite.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Parent</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Parent()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Parent()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Parent(int i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Parent()&quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 同个类中函数名称相同的函数构成函数重载</span><br><span class="line">    void func()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Parent::func()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void func(int i)    &#x2F;&#x2F; 构成多态</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Parent::func(int)&quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void func(int i, int j)     &#x2F;&#x2F; 构成函数重定义</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Parent::func(int, int)&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Child : public Parent</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Child() &#x2F;&#x2F; 默认调用父类的默认构造函数</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Child()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 父类和子类中函数名称相同的函数构成函数重写</span><br><span class="line">    virtual void func(int i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Child::func(int)&quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void func(int i, int j)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Child::func(int, int)&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void run(Parent* p)</span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;func(1);     &#x2F;&#x2F; 有virtual关键字,多态</span><br><span class="line">    p-&gt;func(1, 2);  &#x2F;&#x2F; 不构成多态,会一直调用父类的void func(int, int)函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    Parent p &#x3D; Parent();</span><br><span class="line">    Child c &#x3D; Child();  &#x2F;&#x2F; 会调用父类的默认构造函数</span><br><span class="line">&#x2F;&#x2F;    c.func();   &#x2F;&#x2F; error,由于父类和子类之间是函数重写,</span><br><span class="line">&#x2F;&#x2F; 子类重写父类同名称的函数，此时父类的同名称函数需要加上父类标识才可以调用</span><br><span class="line">    c.Parent::func();</span><br><span class="line"></span><br><span class="line">    run(&amp;p);</span><br><span class="line">    run(&amp;c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>重载需要掌握：函数重载的条件；运算符重载；重载、重写和重定义的区别。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>23-cpp-继承</title>
    <url>/2020/02/14/23-cpp-%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的定义"><a href="#继承的定义" class="headerlink" title="继承的定义"></a>继承的定义</h2><p>若类B继承自类A，则称类B为派生类(子类)，类A为基类(父类)。<br>派生类的定义:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class 派生类名 : 基类名表</span><br><span class="line">&#123;</span><br><span class="line">  数据成员和成员函数声明</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">基类名表构成:</span><br><span class="line">  访问控制 基类名1, 访问控制 基类名2, ... , 访问控制 基类名n</span><br><span class="line">访问控制:</span><br><span class="line">  public&#x2F;protected&#x2F;private</span><br></pre></td></tr></table></figure>
<h2 id="继承的说明"><a href="#继承的说明" class="headerlink" title="继承的说明"></a>继承的说明</h2><ol>
<li>子类拥有父类的所有成员变量和成员函数</li>
<li>子类可以扩展父类没有的成员变量和成员函数</li>
<li>子类对象可以当作父类对象使用</li>
</ol>
<h2 id="不同访问控制的继承方式解析"><a href="#不同访问控制的继承方式解析" class="headerlink" title="不同访问控制的继承方式解析"></a>不同访问控制的继承方式解析</h2><ul>
<li>publicInherit.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Parent</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    int a;</span><br><span class="line">protected:</span><br><span class="line">    int b;</span><br><span class="line">private:</span><br><span class="line">    int c;</span><br><span class="line">public:</span><br><span class="line">    Parent(int a&#x3D;0, int b&#x3D;0, int c&#x3D;0)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;a &#x3D; a;</span><br><span class="line">        this-&gt;b &#x3D; b;</span><br><span class="line">        this-&gt;c &#x3D; c;</span><br><span class="line">        cout &lt;&lt; &quot;Parent(int a&#x3D;0, int b&#x3D;0, int c&#x3D;0)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void set(int a, int b, int c)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;a &#x3D; a;</span><br><span class="line">        this-&gt;b &#x3D; b;</span><br><span class="line">        this-&gt;c &#x3D; c;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Child : public Parent</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Child() &#x2F;&#x2F; 默认调用父类的默认构造函数</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Child()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">&#x2F;&#x2F;        Parent::print();</span><br><span class="line">      cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;    &#x2F;&#x2F; 子类可以访问父类的公有成员</span><br><span class="line">		  cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;    &#x2F;&#x2F; 子类可以访问父类的保护成员</span><br><span class="line">&#x2F;&#x2F;		cout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;    &#x2F;&#x2F; 子类不能访问父类的私有成员</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    Parent p;</span><br><span class="line">    Child c;</span><br><span class="line"></span><br><span class="line">    p.a &#x3D; 100;  &#x2F;&#x2F; public在类的外部可以访问</span><br><span class="line">    &#x2F;&#x2F;p.b &#x3D; 200;  &#x2F;&#x2F; protected在类的外部不能访问</span><br><span class="line">    &#x2F;&#x2F;p.c &#x3D; 300;  &#x2F;&#x2F; private在类的外部不能访问</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 公有继承会保持父类原有的访问控制,在类外的访问结果同上</span><br><span class="line">    c.a &#x3D; 100;    &#x2F;&#x2F; public</span><br><span class="line">&#x2F;&#x2F;    c.b &#x3D; 200;    &#x2F;&#x2F; protected</span><br><span class="line">&#x2F;&#x2F;    c.c &#x3D; 300;    &#x2F;&#x2F; private</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 公有继承会保持父类原有的访问控制,子类不能访问父类的private成员</span><br><span class="line">    c.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>protectedInherit.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Parent</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    int a;</span><br><span class="line">protected:</span><br><span class="line">    int b;</span><br><span class="line">private:</span><br><span class="line">    int c;</span><br><span class="line">public:</span><br><span class="line">    Parent(int a&#x3D;0, int b&#x3D;0, int c&#x3D;0)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;a &#x3D; a;</span><br><span class="line">        this-&gt;b &#x3D; b;</span><br><span class="line">        this-&gt;c &#x3D; c;</span><br><span class="line">        cout &lt;&lt; &quot;Parent(int a&#x3D;0, int b&#x3D;0, int c&#x3D;0)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void set(int a, int b, int c)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;a &#x3D; a;</span><br><span class="line">        this-&gt;b &#x3D; b;</span><br><span class="line">        this-&gt;c &#x3D; c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Child : protected Parent</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Child() &#x2F;&#x2F; 默认调用父类的默认构造函数</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Child()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">      cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;    &#x2F;&#x2F; 子类可以访问父类的保护成员</span><br><span class="line">		  cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;    &#x2F;&#x2F; 子类可以访问父类的保护成员</span><br><span class="line">&#x2F;&#x2F;		cout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;    &#x2F;&#x2F; 子类不能访问父类的私有成员</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    Parent p;</span><br><span class="line">    Child c;</span><br><span class="line"></span><br><span class="line">    p.a &#x3D; 100;  &#x2F;&#x2F; public在类的外部可以访问</span><br><span class="line">    &#x2F;&#x2F;p.b &#x3D; 200;  &#x2F;&#x2F; protected在类的外部不能访问</span><br><span class="line">    &#x2F;&#x2F;p.c &#x3D; 300;  &#x2F;&#x2F; private在类的外部不能访问</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 保护继承会将父类public继承的成员访问控制属性改为protected</span><br><span class="line">    &#x2F;&#x2F; 其他访问控制属性不变</span><br><span class="line">&#x2F;&#x2F;    c.a &#x3D; 100;    &#x2F;&#x2F; protected</span><br><span class="line">&#x2F;&#x2F;    c.b &#x3D; 200;    &#x2F;&#x2F; protected</span><br><span class="line">&#x2F;&#x2F;    c.c &#x3D; 300;    &#x2F;&#x2F; private</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 保护继承会将父类public继承的成员访问控制属性改为protected</span><br><span class="line">    &#x2F;&#x2F; 其他访问控制属性不变.子类不能访问父类的private成员</span><br><span class="line">    c.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>privateInherit.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Parent</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    int a;</span><br><span class="line">protected:</span><br><span class="line">    int b;</span><br><span class="line">private:</span><br><span class="line">    int c;</span><br><span class="line">public:</span><br><span class="line">    Parent(int a&#x3D;0, int b&#x3D;0, int c&#x3D;0)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;a &#x3D; a;</span><br><span class="line">        this-&gt;b &#x3D; b;</span><br><span class="line">        this-&gt;c &#x3D; c;</span><br><span class="line">        cout &lt;&lt; &quot;Parent(int a&#x3D;0, int b&#x3D;0, int c&#x3D;0)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void set(int a, int b, int c)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;a &#x3D; a;</span><br><span class="line">        this-&gt;b &#x3D; b;</span><br><span class="line">        this-&gt;c &#x3D; c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Child : private Parent</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Child() &#x2F;&#x2F; 默认调用父类的默认构造函数</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Child()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">      cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;    &#x2F;&#x2F; 子类可以访问父类的私有继承的成员</span><br><span class="line">		  cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;    &#x2F;&#x2F; 子类可以访问父类的私有继承的成员</span><br><span class="line">&#x2F;&#x2F;		cout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;    &#x2F;&#x2F; 子类不能访问父类的私有成员</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    Parent p;</span><br><span class="line">    Child c;</span><br><span class="line"></span><br><span class="line">    p.a &#x3D; 100;  &#x2F;&#x2F; public在类的外部可以访问</span><br><span class="line">    &#x2F;&#x2F;p.b &#x3D; 200;  &#x2F;&#x2F; protected在类的外部不能访问</span><br><span class="line">    &#x2F;&#x2F;p.c &#x3D; 300;  &#x2F;&#x2F; private在类的外部不能访问</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 私有继承会将父类成员的访问控制权限都修改为private</span><br><span class="line">&#x2F;&#x2F;    c.a &#x3D; 100;    &#x2F;&#x2F; private</span><br><span class="line">&#x2F;&#x2F;    c.b &#x3D; 200;    &#x2F;&#x2F; private</span><br><span class="line">&#x2F;&#x2F;    c.c &#x3D; 300;    &#x2F;&#x2F; private</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 私有继承会将父类成员的访问控制权限都修改为private</span><br><span class="line">    c.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>在类的外部，只有公有继承的公有成员可以访问</li>
<li>在类的内部，只有(公有/保护/私有)继承的私有成员不可以访问</li>
</ol>
<p>问题：<br>子类的私有继承和保护继承，在子类内部可以访问的内容和在子类外部可以访问的内容一样，那保护继承有什么意义？</p>
<h2 id="类型兼容性原则"><a href="#类型兼容性原则" class="headerlink" title="类型兼容性原则"></a>类型兼容性原则</h2><p>类型兼容性原则：需要基类对象的任何地方，都可以使用<font color="red">公有派生类的对象</font>来代替。<br>通过公有继承，派生类得到基类中除构造函数、析构函数以外的所有成员。替代之后，派生类作为基类对象使用，但是只能使用<br>从基类继承的成员。<br>适用情况：</p>
<ul>
<li>子类对象可以当作父类对象使用</li>
<li>子类对象可以直接赋值给父类对象</li>
<li>子类对象可以直接初始化父类对象</li>
<li>父类指针可以直接指向子类对象</li>
<li><p>父类引用可以直接引用子类对象</p>
</li>
<li><p>childAsParent.h</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Parent</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    string name;</span><br><span class="line">public:</span><br><span class="line">    Parent()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Parent()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Parent(const string name)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;name &#x3D; name;</span><br><span class="line">        cout &lt;&lt; &quot;Parent(const string name)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;    Parent(const Parent&amp; obj)</span><br><span class="line">&#x2F;&#x2F;    &#123;</span><br><span class="line">&#x2F;&#x2F;        this-&gt;name &#x3D; obj.name;</span><br><span class="line">&#x2F;&#x2F;        cout &lt;&lt; &quot;Parent(const Parent&amp; obj)&quot; &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;name &#x3D; &quot; &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;Parent print()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Parent()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~Parent()&quot;  &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Child : public Parent     &#x2F;&#x2F; 必须是公有继承</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int age;</span><br><span class="line">public:</span><br><span class="line">    Child()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Child()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Child(const string name, int age) : Parent(name) &#x2F;&#x2F;默认调用父类的默认构造函数</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;age &#x3D; age;</span><br><span class="line">        cout &lt;&lt; &quot;Child(const string name, int age)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;name &#x3D; &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; &quot;age &#x3D; &quot; &lt;&lt; age&lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;Child print()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Child()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~Child()&quot;  &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 构造时:先构造父类,再构造子类</span><br><span class="line">    &#x2F;&#x2F; 析构时:先析构子类,后析构父类</span><br><span class="line">    Child c(&quot;simonXi-tech&quot;, 25);</span><br><span class="line">    c.print();</span><br><span class="line"></span><br><span class="line">    Parent p1 &#x3D; c;  &#x2F;&#x2F; 子类初始化父类</span><br><span class="line">    p1.print();</span><br><span class="line"></span><br><span class="line">    Parent* p2 &#x3D; &amp;c;    &#x2F;&#x2F; 父类指针指向子类对象</span><br><span class="line">    p2-&gt;print();</span><br><span class="line"></span><br><span class="line">    Parent&amp; p3 &#x3D; c;     &#x2F;&#x2F; 父类引用子类对象</span><br><span class="line">    p3.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承与组合构造和析构顺序"><a href="#继承与组合构造和析构顺序" class="headerlink" title="继承与组合构造和析构顺序"></a>继承与组合构造和析构顺序</h2><p>当子类中有定义类成员变量时:<br>  构造时：先构造父类，在构造类成员变量，最后构造子类<br>  析构时：先析构子类，在析构类成员变量，最后析构父类</p>
<ul>
<li>destructorSequence.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Obj</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int i;</span><br><span class="line">public:</span><br><span class="line">    Obj()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Obj()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Obj(int i)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;i &#x3D; i;</span><br><span class="line">        cout &lt;&lt; &quot;Obj()&quot; &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Obj()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~Obj()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Parent</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    string name;</span><br><span class="line">public:</span><br><span class="line">    Parent()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Parent()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Parent(const string name)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;name &#x3D; name;</span><br><span class="line">        cout &lt;&lt; &quot;Parent(const string name)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Parent()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~Parent()&quot;  &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Child : public Parent     &#x2F;&#x2F; 必须是公有继承</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int age;</span><br><span class="line">public:</span><br><span class="line">    Child()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Child()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 调用父类的有参构造函数，需要在子类的初始化列表中显示调用</span><br><span class="line">    Child(const string name, int age) : Parent(name)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;age &#x3D; age;</span><br><span class="line">        cout &lt;&lt; &quot;Child(const string name, int age)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Child(const string name, int age, int i) : Parent(name), obj2(i)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;age &#x3D; age;</span><br><span class="line">        cout &lt;&lt; &quot;Child(const string name, int age)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ~Child()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~Child()&quot;  &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    Obj obj1;</span><br><span class="line">    Obj obj2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 构造时:先构造父类,再构造子类</span><br><span class="line">    &#x2F;&#x2F; 析构时:先析构子类,后析构父类</span><br><span class="line">    Child c1(&quot;simonXi-tech&quot;, 25);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当子类中有定义类成员变量时</span><br><span class="line">    &#x2F;&#x2F; 构造时：先构造父类，在构造类成员变量，最后构造子类</span><br><span class="line">    &#x2F;&#x2F; 析构时：先析构子类，在析构类成员变量，最后析构父类</span><br><span class="line">    Child c2(&quot;simonXi&quot;, 25, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="子类和父类同名成员"><a href="#子类和父类同名成员" class="headerlink" title="子类和父类同名成员"></a>子类和父类同名成员</h2><p>子类和父类同名成员，子类依然冲父类继承同名成员。<br>子类和父类同名成员：默认使用子类的成员，需要使用父类成员时需要通过作用域分辨符::进行同名区分</p>
<ul>
<li>samePropInInherit.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Parent</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Parent(int a&#x3D;0, int b&#x3D;0)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;a &#x3D; a;</span><br><span class="line">        this-&gt;b &#x3D; b;</span><br><span class="line">        cout &lt;&lt; &quot;Parent(int a&#x3D;0, int b&#x3D;0)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Child : public Parent</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int b;</span><br><span class="line">public:</span><br><span class="line">    Child()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Child()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Child(int b):Parent(1, 2)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;b &#x3D; b;</span><br><span class="line">        cout &lt;&lt; &quot;Child()&quot; &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    Child c(25);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; c.a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c.b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c.Parent::b &lt;&lt; endl;</span><br><span class="line">    c.print();</span><br><span class="line">    c.Parent::print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>多继承的二义性</p>
<ul>
<li>multiInherit.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Parent1 : public Base</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int p1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Parent2 : public Base</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int p2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Child : public Parent1, public Parent2</span><br><span class="line">&#123;</span><br><span class="line"> private:</span><br><span class="line">     int c;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    Child c;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 多继承产生二义性</span><br><span class="line">&#x2F;&#x2F;    cout &lt;&lt; c.b &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F; 为了防止二义性,需要显式指定从Base类继承的两个b</span><br><span class="line">    cout &lt;&lt; c.Parent1::b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c.Parent2::b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了防止一个子类继承两个父类时，这两个父类又有相同的基类时可能产生的二义性，此时需要进行虚继承(virtual关键字)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Parent1 : virtual public Base</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int p1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Parent2 : virtual public Base</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int p2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Child : public Parent1, public Parent2</span><br><span class="line">&#123;</span><br><span class="line"> private:</span><br><span class="line">     int c;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    Child c;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; c.b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>继承主要把握父类的成员是存在于子类之中的。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>19-cpp-细节语法</title>
    <url>/2020/02/10/19-cpp-%E7%BB%86%E8%8A%82%E8%AF%AD%E6%B3%95%E4%B8%80/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>命名空间、struct类型加强、三目运算符增强。<br><a id="more"></a></p>
<h1 id="C-对C的加强"><a href="#C-对C的加强" class="headerlink" title="C++对C的加强"></a>C++对C的加强</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>namespace 就是标识符的可见范围。使用 <code>#include &lt;iostream&gt;</code>时，该头文件中没有定义全局命名空间，所以 std 这个命名空间中的标识符时不可以使用的，必须使用 <code>using namespace std</code> 才可以引入命名空间。全局命名空间类似全局变量，容易导致变量冲突问题。std 是C++标准命名空间，C++标准程序库中的所有标识符都被定义在 std 中。</p>
<h3 id="命名空间的定义"><a href="#命名空间的定义" class="headerlink" title="命名空间的定义"></a>命名空间的定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace name &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">namespace name</span><br></pre></td></tr></table></figure>
<ul>
<li>示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">namespace NameSpaceA</span><br><span class="line">&#123;</span><br><span class="line">	int a &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace NameSpaceB</span><br><span class="line">&#123;</span><br><span class="line">	int a &#x3D; 1;</span><br><span class="line"></span><br><span class="line">	namespace NameSpaceC</span><br><span class="line">	&#123;</span><br><span class="line">		struct Teacher</span><br><span class="line">		&#123;</span><br><span class="line">			char name[10];</span><br><span class="line">			int age;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    using namespace std;</span><br><span class="line">	using namespace NameSpaceA;     &#x2F;&#x2F; 函数中使用命名空间NameSpaceA的a</span><br><span class="line">&#x2F;&#x2F;	using namespace NameSpaceB;     &#x2F;&#x2F; 同时使用命名空间NameSpaceB会造成二义性</span><br><span class="line">	using NameSpaceB::NameSpaceC::Teacher;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; NameSpaceB::a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Teacher t &#x3D; &#123;&quot;simon&quot;, 3&#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;t.name &#x3D; &quot; &lt;&lt; t.name &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;t.age &#x3D; &quot; &lt;&lt; t.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="命名空间的使用"><a href="#命名空间的使用" class="headerlink" title="命名空间的使用"></a>命名空间的使用</h3><ul>
<li>std::cout 直接指定标识符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>这种方式非常麻烦，每个标识符都要加上对应的命名空间。</p>
<ul>
<li><p><code>using namespace std</code><br>如果将 <code>using namespace std</code> 放在函数外，则 std 中的所有标识符具有整个文件全局的作用域；如果放在函数内，则 std 具有函数的局部作用域。</p>
</li>
<li><p><code>using std::cout</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;using namespace std;</span><br><span class="line">using std::cout;	&#x2F;&#x2F; 使用命名空间中的具体标识符</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void bubbleSort(std::vector&lt;T&gt;&amp; nums)&#123;	&#x2F;&#x2F; 直接指定标识符</span><br><span class="line">    for(int i&#x3D;0; i&lt;nums.size()-1; i++)&#123;</span><br><span class="line">        bool flag &#x3D; false;</span><br><span class="line"></span><br><span class="line">        for(int j&#x3D;i+1; j&lt;nums.size(); j++)</span><br><span class="line">            if(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                std::swap&lt;T&gt;(nums[i], nums[j]);</span><br><span class="line">                flag &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        if(!flag)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void print_vec(std::vector&lt;T&gt;&amp; matrix)&#123;</span><br><span class="line">    for(T e : matrix)&#123;</span><br><span class="line">        cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    using namespace std;	&#x2F;&#x2F; 在函数中使用命名空间的所有标识符</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; inums &#x3D; &#123; 4, 1, 6, 0, 5, 2, 3 &#125;;</span><br><span class="line">    vector&lt;char&gt; cnums &#x3D; &#123;&#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;d&#39;&#125;;</span><br><span class="line">    vector&lt;string&gt; snums &#x3D; &#123; &quot;string&quot;, &quot;apple&quot;, &quot;world&quot;, &quot;hello&quot;, &quot;cpp&quot; &#125;;</span><br><span class="line"></span><br><span class="line">    bubbleSort&lt;int&gt;(inums);</span><br><span class="line">    bubbleSort&lt;char&gt;(cnums);</span><br><span class="line">    bubbleSort&lt;string&gt;(snums);</span><br><span class="line"></span><br><span class="line">    print_vec(inums);</span><br><span class="line">    print_vec(cnums);</span><br><span class="line">    print_vec(snums);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="struct-类型加强"><a href="#struct-类型加强" class="headerlink" title="struct 类型加强"></a>struct 类型加强</h2><p>C语言中struct定义为一组变量的集合，C编译器不认为这是一种新的类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Teacher&#123;</span><br><span class="line">    char name[20];</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;    Teacher t &#x3D; &#123; &quot;savana&quot;, 28 &#125;;   &#x2F;&#x2F; 错误 Teacher 不是结构体类型，结构体类型表示为 struct Teacher</span><br><span class="line">    struct Teacher t &#x3D; &#123; &quot;savana&quot;, 28 &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++中的struct是一个新类型的定义声明。类似于class，但是class中的成员不指定访问控制，默认是private，而struct默认是public。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Teacher为结构体类型</span><br><span class="line">struct Teacher&#123;</span><br><span class="line">    string name;</span><br><span class="line">    int age;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 构造函数</span><br><span class="line">    Teacher(string name, int age)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;name &#x3D; name;</span><br><span class="line">        this-&gt;age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Teacher(const Teacher&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;name &#x3D; obj.name;</span><br><span class="line">        this-&gt;age &#x3D; obj.age;</span><br><span class="line">        cout &lt;&lt; &quot;拷贝构造函数&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string getName()</span><br><span class="line">    &#123;</span><br><span class="line">        return this-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getAge()</span><br><span class="line">    &#123;</span><br><span class="line">        return this-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Teacher 是 struct 类型</span><br><span class="line">    Teacher t(&quot;simon&quot;, 25);</span><br><span class="line">    cout &lt;&lt; &quot;name&#x3D;&quot; &lt;&lt; t.getName() &lt;&lt; &quot;,age&#x3D;&quot; &lt;&lt; t.getAge() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三目运算符增强"><a href="#三目运算符增强" class="headerlink" title="三目运算符增强"></a>三目运算符增强</h2><ul>
<li>C语言中三目运算符不能做左值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a &#x3D; 10;</span><br><span class="line">	int b &#x3D; 20;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; C语言中的三目运算符返回变量值，不能作为左值使用</span><br><span class="line">&#x2F;&#x2F;	( a &lt; b ? a : b )&#x3D; 30;  &#x2F;&#x2F; error</span><br><span class="line">    *( a &lt; b ? &amp;a : &amp;b ) &#x3D; 30;</span><br><span class="line"></span><br><span class="line">	printf(&quot;a &#x3D; %d, b &#x3D; %d\n&quot;, a, b);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>C++三目运算符没有限制</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a &#x3D; 10;</span><br><span class="line">	int b &#x3D; 20;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; C++中直接返回变量本身</span><br><span class="line">&#x2F;&#x2F;	(a &lt; b ? a : b )&#x3D; 30;   &#x2F;&#x2F; 正确</span><br><span class="line">	*( a &lt; b ? &amp;a : &amp;b ) &#x3D; 30;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt;&quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
      <categories>
        <category>编程语言</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>24-cpp-static-this指针</title>
    <url>/2020/02/14/24-cpp-static-this%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C++对象模型中成员数据如图：<br><img src="/images/31-cpp-static-this指针/01-cpp-成员.png" alt="&quot;01-cpp-成员&quot;"><br><a id="more"></a></p>
<h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><p>C++类对象中成员变量和成员函数分开存储。由thisInCpp.h和thisInC.h可知，C++中的类普通成员变量结构类似于<br>结构体。类普通成员函数类似于thisInC.h的全局函数。C++中为了区分不同的对象，会自动将该对象取地址传递给<br>一个默认存在于类中的指针，也就是this指针。</p>
<ul>
<li>thisInCpp.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int ti;</span><br><span class="line">public:</span><br><span class="line">    Test(int i)</span><br><span class="line">    &#123;</span><br><span class="line">        ti &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int get()</span><br><span class="line">    &#123;</span><br><span class="line">        return ti;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;this is class test&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    Test t(100);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; t.get() &lt;&lt; endl;</span><br><span class="line">    t.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>thisInC.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct Test</span><br><span class="line">&#123;</span><br><span class="line">    int ti;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void TestInitialize(Test *pThis, int i)</span><br><span class="line">&#123;</span><br><span class="line">    pThis-&gt;ti &#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int TestGet(Test *pThis)</span><br><span class="line">&#123;</span><br><span class="line">    return pThis-&gt;ti;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestPrint()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;this is class test&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    Test t;</span><br><span class="line"></span><br><span class="line">    TestInitialize(&amp;t, 100);</span><br><span class="line">    cout &lt;&lt; TestGet(&amp;t) &lt;&lt; endl;</span><br><span class="line">    TestPrint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>普通成员变量存储于对象中，静态成员变量存储与静态储存区，成员函数存储于代码段。<br>C++中类的普通成员函数都隐式包含一个指向当前对象的 this 指针。<br>静态成员函数不包含指向具体对象的指针，普通成员函数包含一个指向具体对象的指针。</p>
<ul>
<li>this.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class thisPointer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F; 属于类</span><br><span class="line">    static void test1()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;istatic &#x3D; &quot; &lt;&lt; istatic &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 没有用到this指针</span><br><span class="line">    void test2()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;test2&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 没有用到this指针</span><br><span class="line">    void test3(int i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;i&#x3D;&quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用到this指针</span><br><span class="line">    void test4()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;inormal &#x3D; &quot; &lt;&lt; inormal &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    static int istatic;</span><br><span class="line">    int inormal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int thisPointer::istatic &#x3D; 0;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 类指针为空</span><br><span class="line">    thisPointer *p &#x3D; NULL;</span><br><span class="line">    p-&gt;test1();     &#x2F;&#x2F; 可以执行</span><br><span class="line">    p-&gt;test2();     &#x2F;&#x2F; 可以执行</span><br><span class="line">    p-&gt;test3(25);   &#x2F;&#x2F; 可以执行</span><br><span class="line">&#x2F;&#x2F;    p-&gt;test4();   &#x2F;&#x2F; 不可以执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>this是一个常量指针，也就是this 指针变量本身是不可修改的。比如类Test对应的 this指针为：Test* const this;<br>那如何让 this指针所指向的内存空间不可修改，答案是在函数定义后加上 const，表示 this指针所指向的内存空间不可修改。</p>
<ul>
<li>thisWithConst.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int t;</span><br><span class="line">public:</span><br><span class="line">    int setThis()</span><br><span class="line">    &#123;</span><br><span class="line">&#x2F;&#x2F;        this &#x3D; 0x222;   &#x2F;&#x2F; Test* const this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int setT(int t) const   &#x2F;&#x2F; 在函数定义后加的从const,使this指针指向的空间只读</span><br><span class="line">    &#123;</span><br><span class="line">&#x2F;&#x2F;        this-&gt;t &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    Test t;</span><br><span class="line">&#x2F;&#x2F;    t.setThis();</span><br><span class="line">&#x2F;&#x2F;    t.setT(10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>this指针主要是标记不同类对象的内存空间。static关键字标记的成员属于类，静态成员函数在类创建时就存在，不能在静态成员函数中访问还没有创建的对象成员变量。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>26-cpp-多态</title>
    <url>/2020/02/17/26-cpp-%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ol>
<li>联编就是一个程序模块、代码互相关联的过程。</li>
<li>多态存在的意义就是：当父类指针/引用指向父类对象时，调用父类的函数；当父类指针/引用指向子类对象，调用子类重写的同名函数。即同样的调用语句有多种不同的表现形态。</li>
<li>实际在编译过程中，编译器会自动根据指针的类型判断指向的时一个什么样的对象，所以编译器认为父类指针指向的父类对象。如果没有virtual关键字进行限定，<br>父类指针调用的永远是父类对象中成员函数。这种特性叫做静态联编。</li>
<li>为了使多态成立，需要将程序联编推迟到运行时进行，成为动态联编。</li>
<li>父类对象和子类对象的指针++步长不同，所以不要用父类指针++的方式操作子类数组。</li>
</ol>
<h2 id="多态的成立条件"><a href="#多态的成立条件" class="headerlink" title="多态的成立条件"></a>多态的成立条件</h2><ol>
<li>要有继承</li>
<li>要有函数重写</li>
<li>要有父类指针/引用指向子类对象</li>
</ol>
<ul>
<li>polyCondition.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Parent</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void func()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Parent::func()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 继承</span><br><span class="line">class Child : public Parent</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F; 函数重写</span><br><span class="line">    virtual void func()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Child::func()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 父类指针指向子类对象</span><br><span class="line">void run(Parent* p)</span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;func();     &#x2F;&#x2F; 有virtual关键字,多态</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    Parent p &#x3D; Parent();</span><br><span class="line">    Child c &#x3D; Child();</span><br><span class="line">    c.Parent::func();</span><br><span class="line"></span><br><span class="line">    run(&amp;p);</span><br><span class="line">    run(&amp;c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多态的实现原理"><a href="#多态的实现原理" class="headerlink" title="多态的实现原理"></a>多态的实现原理</h2><ol>
<li>当类中声明虚函数时，编译器会在类中生成一个虚函数表。</li>
<li>虚函数表是一个存储类成员函数指针的数据结构，virtual成员函数会被编译器放入虚函数表中。</li>
<li>虚函数表由编译器自动生成与维护。当存在虚函数时，每个对象都有一个指向虚函数表的指针，称为vptr指针。</li>
<li>在实现多态的过程中，父类和子类都有vptr指针。父类对象的vptr指针指向父类虚函数表，子类对象vptr指针指向子类虚函数表。</li>
<li>在对象创建时，如果对象中存在虚函数，编译器就会在对象中建立虚函数表，并用vptr指针指向这个虚函数表。</li>
<li>只有对象构造完成，vptr指针的指向才最终确定。</li>
</ol>
<ul>
<li>verifyVptr.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">public:</span><br><span class="line">    void func()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Test::func()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;t &#x3D; &quot; &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class VirtualTest</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">public:</span><br><span class="line">    virtual void func()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;VirtualTest::func()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;t &#x3D; &quot; &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 加virtual关键字会加一个指向虚函数表的指针</span><br><span class="line">    cout &lt;&lt; &quot;sizeof(Test) &#x3D; &quot; &lt;&lt; sizeof(Test) &lt;&lt; endl;          &#x2F;&#x2F; 4</span><br><span class="line">    cout &lt;&lt; &quot;sizeof(VirtualTest) &#x3D; &quot; &lt;&lt; sizeof(VirtualTest) &lt;&lt; endl;    &#x2F;&#x2F; 8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行过程中，编译器首先确定函数是否为虚函数，如果不是虚函数，编译器直接确定被调用的成员函数。<br>如果函数是虚函数，编译器根据传入对象的vptr指针，找到对应的虚函数表，找到对象对应的虚函数并调用。<br>所以父类指针不需要确定传入对象是子类对象还是父类对象。<br>当将函数声明为虚函数时，需要通过寻址操作找到真正应该调用的函数，所以虚函数的效率比普通函数低。<br>即可以将类中所有成员函数都声明为虚函数，但是没有必要。</p>
<h2 id="vptr指针分布初始化"><a href="#vptr指针分布初始化" class="headerlink" title="vptr指针分布初始化"></a>vptr指针分布初始化</h2><p>对象在创建中，编译器对vptr指针进行初始化。只有当对象构造完全结束后vptr指针的指向才最终确定。<br>在构建子类对象时，会先构造父类对象，此时在父类对象中调用虚函数，指向父类的虚函数。构造完父类对象，<br>此时子类对象调用虚函数，指向子类的虚函数。</p>
<ul>
<li>vptr.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Parent</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Parent()</span><br><span class="line">    &#123;</span><br><span class="line">        func();</span><br><span class="line">        cout &lt;&lt; &quot;Parent()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void func()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Parent::func()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Child : public Parent</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Child()</span><br><span class="line">    &#123;</span><br><span class="line">        func();</span><br><span class="line">        cout &lt;&lt; &quot;Child()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void func()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Child::func()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 定义子类对象时,vptr指针先指向父类的虚函数表,在父类构造完成之后</span><br><span class="line">    &#x2F;&#x2F; 子类的vptr才指向自己的虚函数表</span><br><span class="line">    Child c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p>普通析构函数在删除动态派生类对象会出现析构不彻底的现象。虚析构函数用于指引 delete 运算符正确析构动态对象。</p>
<ul>
<li>normalDestructor.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ~Base()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Base destructor&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Parent : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ~Parent()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Parent destructor&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Child : public Parent</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ~Child()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Child destructor&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    Child* pc &#x3D; new Child();</span><br><span class="line">    delete pc;</span><br><span class="line">    cout &lt;&lt; &quot;Child* pc&quot; &lt;&lt; endl;  &#x2F;&#x2F; 调用Base的析构函数&#x2F;Parent析构函数&#x2F;Child析构函数</span><br><span class="line"></span><br><span class="line">    Parent* pp &#x3D; new Child();</span><br><span class="line">    delete pp;</span><br><span class="line">    cout &lt;&lt; &quot;Parent* pp&quot; &lt;&lt; endl; &#x2F;&#x2F; 调用Base的析构函数&#x2F;Parent析构函数</span><br><span class="line"></span><br><span class="line">    Base* pb &#x3D; new Child();</span><br><span class="line">    delete pb;</span><br><span class="line">    cout &lt;&lt; &quot;Base* pb&quot; &lt;&lt; endl;   &#x2F;&#x2F; 只调用Base的析构函数</span><br><span class="line"></span><br><span class="line">    Child c;  &#x2F;&#x2F; 调用Base的析构函数&#x2F;Parent析构函数&#x2F;Child析构函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>virutualDestructor.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual ~Base()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Base destructor&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Parent : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual ~Parent()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Parent destructor&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Child : public Parent</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual ~Child()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Child destructor&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    Child* pc &#x3D; new Child();</span><br><span class="line">    delete pc;    &#x2F;&#x2F; 调用Base的析构函数&#x2F;Parent析构函数&#x2F;Child析构函数</span><br><span class="line">    cout &lt;&lt; &quot;Child* pc&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Parent* pp &#x3D; new Child();</span><br><span class="line">    delete pp;    &#x2F;&#x2F; 调用Base的析构函数&#x2F;Parent析构函数&#x2F;Child析构函数</span><br><span class="line">    cout &lt;&lt; &quot;Parent* pp&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Base* pb &#x3D; new Child();</span><br><span class="line">    delete pb;    &#x2F;&#x2F; 调用Base的析构函数&#x2F;Parent析构函数&#x2F;Child析构函数</span><br><span class="line">    cout &lt;&lt; &quot;Base* pb&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Child c;      &#x2F;&#x2F; 调用Base的析构函数&#x2F;Parent析构函数&#x2F;Child析构函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h1><p>纯虚函数是一个在基类中说明的虚函数，在基类中没有定义，要求派生类必须实现纯虚函数。<br>纯虚函数形式：<br>  virtual 类型 函数名(参数表)=0;<br>在C++中没有接口的概念，纯虚函数就类似于Java的接口。Java派生类可以继承多个接口，不允许继承多个类。<br>C++中可以继承多个接口，也可以继承多个类，但是继承多个类会产生”钻石问题”，故C++摈弃继承多个类这种理念。<br>在C++中具有纯虚函数的基类称为抽象类。</p>
<ul>
<li>abstractClass.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 抽象类</span><br><span class="line">class Figure</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    double x, y;</span><br><span class="line">public:</span><br><span class="line">    void setDim(double i, double j&#x3D;0)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;x &#x3D; i;</span><br><span class="line">        this-&gt;y &#x3D; j;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void showArea() &#x3D; 0;    &#x2F;&#x2F; 纯虚函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Triangle : public Figure</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void showArea()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Triangle Area &#x3D; &quot; &lt;&lt; 0.5*x*y &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Square : public Figure</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void showArea()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Triangle Area &#x3D; &quot; &lt;&lt; x*y &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Circle : public Figure</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void showArea()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Circle Area &#x3D; &quot; &lt;&lt; 3.14*x*x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    Figure* pf;   &#x2F;&#x2F; 抽象类可以定义指针&#x2F;引用,不可以定义对象</span><br><span class="line">    Triangle t;</span><br><span class="line">    Square s;</span><br><span class="line">    Circle c;</span><br><span class="line"></span><br><span class="line">    pf &#x3D; &amp;t;</span><br><span class="line">    pf-&gt;setDim(10.0, 6.0);</span><br><span class="line">    pf-&gt;showArea();</span><br><span class="line"></span><br><span class="line">    pf &#x3D; &amp;s;</span><br><span class="line">    pf-&gt;setDim(10.0, 6.0);</span><br><span class="line">    pf-&gt;showArea();</span><br><span class="line"></span><br><span class="line">    pf &#x3D; &amp;c;</span><br><span class="line">    pf-&gt;setDim(10.0, 6.0);</span><br><span class="line">    pf-&gt;showArea();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象类模拟接口"><a href="#抽象类模拟接口" class="headerlink" title="抽象类模拟接口"></a>抽象类模拟接口</h2><p>接口就是可以看作只有纯虚函数的类。在C++和Java中继承多个接口都是可以的。</p>
<ul>
<li>interface.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class interface1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void print() &#x3D; 0;</span><br><span class="line">    virtual int add(int a, int b) &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;    virtual int add(int a, int b, int c) &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class interface2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void print() &#x3D; 0;</span><br><span class="line">    virtual int add(int a, int b) &#x3D; 0;</span><br><span class="line">    virtual int minus(int a, int b) &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Child : public interface1, interface2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Child::print()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 重载不以返回值为标准</span><br><span class="line">&#x2F;&#x2F;    void add(int a, int b)</span><br><span class="line">&#x2F;&#x2F;    &#123;</span><br><span class="line">&#x2F;&#x2F;        return a+b;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;    int add(int a, int b, int c)</span><br><span class="line">&#x2F;&#x2F;    &#123;</span><br><span class="line">&#x2F;&#x2F;        return a+b;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line"></span><br><span class="line">    int add(int a, int b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int minus(int a, int b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a-b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    Child c;</span><br><span class="line">    c.print();</span><br><span class="line">    cout &lt;&lt; c.add(1, 1) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c.minus(1, 1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当多继承出现”钻石模型”时，可以使用virtual关键字避免二义性问题。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>面向接口编程时项目开发中非常重要的技能。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>25-cpp-模板</title>
    <url>/2020/02/15/25-cpp-%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a>
<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><p>函数模板，就是建立一个通用函数，其形参类型和返回值类型都可以不具体指定，用虚拟类型来代表。这个通用函数就称为函数模板。在调用函数时系统可以通过自动类型推导或者用户显式指定类型的方式来取代模板中的虚拟类型，从而实现不同函数的功能。用函数模板生成的函数叫做模板函数。  </p>
<ul>
<li>函数模板定义有模板说明和函数定义组成</li>
<li>函数参数表中可以使用类属(类型参数化)类型参数，也可以使用一般类型参数</li>
<li>返回值也可以使用类属类型参数，此时类型必须显示指定</li>
<li>编译器编译代码时，会根据代码从函数模板产生具体类型的函数</li>
<li>函数模板不能简单的声明和定义分开</li>
<li>函数模板可以像普通函数一样被重载</li>
<li>函数模板形式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;类型形式参数表&gt;       &#x2F;&#x2F; 类型形式参数的形式为：typename T1, typename T2, ... , typename Tn</span><br><span class="line">类型 函数名(形式参数表)</span><br><span class="line">&#123;</span><br><span class="line">    语句序列</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void bubbleSort(vector&lt;T&gt;&amp; nums)&#123;</span><br><span class="line">    for(int i&#x3D;0; i&lt;nums.size()-1; i++)&#123;</span><br><span class="line">        bool flag &#x3D; false;</span><br><span class="line"></span><br><span class="line">        for(int j&#x3D;i+1; j&lt;nums.size(); j++)</span><br><span class="line">            if(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                swap&lt;T&gt;(nums[i], nums[j]);</span><br><span class="line">                flag &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        if(!flag)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bubbleSort()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;bubbleSort重载&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void print_vec(vector&lt;T&gt;&amp; matrix)&#123;</span><br><span class="line">    for(T e : matrix)&#123;</span><br><span class="line">        cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; inums &#x3D; &#123; 4, 1, 6, 0, 5, 2, 3 &#125;;</span><br><span class="line">    vector&lt;char&gt; cnums &#x3D; &#123;&#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;d&#39;&#125;;</span><br><span class="line">    vector&lt;string&gt; snums &#x3D; &#123; &quot;string&quot;, &quot;apple&quot;, &quot;world&quot;, &quot;hello&quot;, &quot;cpp&quot; &#125;;</span><br><span class="line"></span><br><span class="line">    bubbleSort&lt;int&gt;(inums);   &#x2F;&#x2F; 显式类型调用</span><br><span class="line">    bubbleSort(cnums);        &#x2F;&#x2F; 隐式类型推导</span><br><span class="line">    bubbleSort&lt;string&gt;(snums);</span><br><span class="line">    bubbleSort();             &#x2F;&#x2F; 函数模板可以重载</span><br><span class="line"></span><br><span class="line">    print_vec(inums);</span><br><span class="line">    print_vec(cnums);</span><br><span class="line">    print_vec(snums);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="c-函数模板声明与定义相分离"><a href="#c-函数模板声明与定义相分离" class="headerlink" title="c++函数模板声明与定义相分离"></a><a href="https://www.cnblogs.com/tonychen-tobeTopCoder/p/5199655.html" target="_blank" rel="noopener">c++函数模板声明与定义相分离</a></h2><p><img src="/images/29-cpp-重载/01-编译流程图.png" alt="&quot;01-编译流程图&quot;"></p>
<p>由编译流程图可知，编译器先对 每一个源文件进行 预处理、编译、汇编 生成 .o 文件。然后将 整个工程中的 所有 .o文件和其他库文件 链接<br>成可执行文件。如果将 c++函数模板声明与定义相分离，则在编译这个过程中，只有声明无法具现 函数模板 而报错。</p>
<h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><h2 id="类模板定义与使用"><a href="#类模板定义与使用" class="headerlink" title="类模板定义与使用"></a>类模板定义与使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;类型形式参数表&gt;       &#x2F;&#x2F; 类型形式参数的形式为：typename T1, typename T2, ... , typename Tn</span><br><span class="line">class 类名</span><br><span class="line">&#123;</span><br><span class="line">    成员函数</span><br><span class="line">    成员变量</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类模板使用时,必须显式指定类型。</p>
<ul>
<li>classTemplateGrammar.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class Parent&#123;</span><br><span class="line">public:</span><br><span class="line">    Parent(T a)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;a &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;a&#x3D;&quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    T a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 模板类做普通函数参数,需要指定类型</span><br><span class="line">void normalUseParent(Parent&lt;int&gt; &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    p.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 模板类做函数模板参数,不需要指定类型</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void templateUseParent(Parent&lt;T&gt; &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    p.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 类模板必须要指定类型，否则编译器不知道按照什么类型处理</span><br><span class="line">    Parent&lt;int&gt; p(10);</span><br><span class="line">&#x2F;&#x2F;    Parent p(10); &#x2F;&#x2F; error</span><br><span class="line">    p.print();</span><br><span class="line"> </span><br><span class="line">    normalUseParent(p);</span><br><span class="line">    templateUseParent&lt;int&gt;(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>复数类</p>
</li>
<li><p>templateClassComplex.hpp</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class Complex</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 友元函数用于重载 &lt;&lt; &gt;&gt;, 其他的最好用成员函数</span><br><span class="line">	friend ostream&amp; operator&lt;&lt; &lt;T&gt;(ostream&amp; out, Complex&amp; c);</span><br><span class="line">public:</span><br><span class="line">	Complex(T a, T b);</span><br><span class="line">	Complex operator+(Complex&amp; c);</span><br><span class="line">	void print();</span><br><span class="line">private:</span><br><span class="line">	T a;</span><br><span class="line">	T b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">Complex&lt;T&gt;::Complex(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;a &#x3D; a;</span><br><span class="line">	this-&gt;b &#x3D; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">Complex&lt;T&gt; Complex&lt;T&gt;::operator+(Complex&lt;T&gt;&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">	Complex&lt;T&gt; tmp(this-&gt;a + c.a, this-&gt;b + c.b);</span><br><span class="line"></span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void Complex&lt;T&gt;::print()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;a&#x3D;&quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; &quot;b&#x3D;&quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 友元函数不属于类</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; out, Complex&lt;T&gt;&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">	out &lt;&lt; c.a &lt;&lt; &quot;+&quot; &lt;&lt; c.b &lt;&lt; &quot;i&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">	Complex&lt;int&gt; c1(1, 2), c2(3, 4);</span><br><span class="line">	Complex&lt;int&gt; c3 &#x3D; c1 + c2;</span><br><span class="line">	c3.print();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板类只能写在同一个.h/.hpp或者.cpp中，不能分开写。具体原因还需要研究。</p>
<h2 id="类模板继承"><a href="#类模板继承" class="headerlink" title="类模板继承"></a>类模板继承</h2><ul>
<li>classTemplateWithInherit.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class Parent&#123;</span><br><span class="line">public:</span><br><span class="line">    Parent(T a)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;a &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;a&#x3D;&quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    T a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class normalChild : public Parent&lt;int&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    normalChild(int a, int b):Parent&lt;int&gt;(a)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;b &#x3D; b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        Parent&lt;int&gt;::print();</span><br><span class="line">        cout &lt;&lt; &quot;b&#x3D;&quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class templateChild : public Parent&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    templateChild(T a , int b) : Parent&lt;T&gt;(a)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        this-&gt;b &#x3D; b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        Parent&lt;T&gt;::print();</span><br><span class="line">        cout &lt;&lt; &quot;b&#x3D;&quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    normalChild nc(10, 20);</span><br><span class="line">    nc.print();</span><br><span class="line"></span><br><span class="line">    templateChild&lt;int&gt; tc(10, 20);</span><br><span class="line">    tc.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类模板static关键字"><a href="#类模板static关键字" class="headerlink" title="类模板static关键字"></a>类模板static关键字</h2><p>从类模板实例化的每个模板类有自己的类模板数据成员，该模板类的所有对象共享一个static数据成员。</p>
<ul>
<li>classTemplateWithStatic.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class Parent&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static T a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">T Parent&lt;T&gt;::a &#x3D; 0; &#x2F;&#x2F; 初始化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    Parent&lt;int&gt; p1, p2, p3; &#x2F;&#x2F; int实例化的模板类共享一个static变量</span><br><span class="line"></span><br><span class="line">    p1.a++;</span><br><span class="line">    p2.a++;</span><br><span class="line">    p3.a++;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; p1.a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Parent&lt;char&gt; c1, c2, c3;    &#x2F;&#x2F; char实例化的模板类共享一个static变量</span><br><span class="line">    c1.a &#x3D; 97;</span><br><span class="line">    c2.a++;</span><br><span class="line">    c3.a++;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; c1.a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>类属参数可用于函数的参数类型、返回类型和声明函数中的变量。<br>模板由编译器根据实际数据实例化，生成可执行代码。实例化的函数，模板称为模板函数，实例化的类模板称为模板类。<br>函数模板可以重载。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>27-linux-内存管理</title>
    <url>/2020/02/18/27-linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a>
<h1 id="linux虚拟地址空间"><a href="#linux虚拟地址空间" class="headerlink" title="linux虚拟地址空间"></a>linux虚拟地址空间</h1><p>linux中每一个运行的程序就是一个进程。程序是由若干条具有一定功能的指令所组成的解题顺序和步骤(磁盘中)。进程是计算机中程序关于某个数据集合上的一次运行活动(内存中)，是操作系统进行资源分配和调度的基本单元。<br>对于32位的linux操作系统，每一个进程都认为其拥有0~4G的虚拟地址空间，如图1所示。虚拟地址空间可以分为内核空间和用户空间。内核空间地址为3G~4G，用户空间为0~3G。<br><strong>内核空间</strong>功能包括：内存管理、进程管理(如进程间通信)、设备驱动管理和VFS虚拟文件系统等。<br><strong>用户空间</strong>自下往上看依次包括：受保护地址(0~4k)、.text代码段、.rodata段、.data段、.bss段、heap空间(向上增长)、内存映射段(映射可执行文件的动态链接库)、栈空间(向下增长)、命令行参数、环境变量。</p>
<p><img src="/images/27-linux-内存管理/01-linux下C程序内存映像.jpg" alt="&quot;01-linux下C程序内存映像&quot;"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"><b>图1</b></div>
    <br>
</center>

<p>证明：</p>
<ul>
<li>hello.c</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	printf(&quot;Hello World!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在linux下使用，gcc hello.c -o hello 编译出 hello 可执行文件。在命令行下输入：size hello。结果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">text</th>
<th style="text-align:center">data</th>
<th style="text-align:center">bss</th>
<th style="text-align:center">dec</th>
<th style="text-align:center">hex</th>
<th style="text-align:center">filename</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1517</td>
<td style="text-align:center">600</td>
<td style="text-align:center">8</td>
<td style="text-align:center">2125</td>
<td style="text-align:center">84d</td>
<td style="text-align:center">hello</td>
</tr>
</tbody>
</table>
</div>
<p>即，在硬盘上加载，可执行文件分为：.text段、.data段、bss段;加载到内存时，可执行文件分为：.text段、.data段、.bss段、heap、stack。如图2所示。</p>
<p><img src="/images/27-linux-内存管理/02-可执行代码存储时结构和运行时结构的对照图.png" alt="&quot;02-可执行代码存储时结构和运行时结构的对照图&quot;"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"><b>图2</b></div>
    <br>
</center>

<h2 id="保留区"><a href="#保留区" class="headerlink" title="保留区"></a>保留区</h2><p>位于虚拟地址空间的最低部分，未赋予物理地址。任何对它的引用都是非法的，用于捕捉使用空指针和小整型值指针引用内存的异常情况。<br>它并不是一个单一的内存区域，而是对地址空间中受到操作系统保护而禁止用户进程访问的地址区域的总称。大多数操作系统中，极小的地址通常都是不允许访问的，如NULL。C语言将无效指针赋值为0也是出于这种考虑，因为0地址上正常情况下不会存放有效的可访问数据。</p>
<h2 id="代码区-text段"><a href="#代码区-text段" class="headerlink" title="代码区(.text段)"></a>代码区(.text段)</h2><p>存放代码(如函数)，不允许修改(类似常量存储区)，但可以执行(不同于常量存储区)。代码区是可共享的，对于频繁执行的程序，只需要在内存中有一份代码即可。代码段通常属于只读，以防止其他程序意外地修改其指令(对该段的写操作将导致段错误)。某些架构也允许代码段为可写，即允许修改程序。</p>
<h2 id="常量存储区-rodata段"><a href="#常量存储区-rodata段" class="headerlink" title="常量存储区(.rodata段)"></a>常量存储区(.rodata段)</h2><p>可以存放常量，不允许修改。注意不是所有常量都在常量存储区中。在C语言中，常量通过指针是可以间接修改的。C++中常量不可以通过指针间接修改，但是通过volatile关键字也是可以修改的。</p>
<h2 id="全局-静态存储区-data段和-bss段"><a href="#全局-静态存储区-data段和-bss段" class="headerlink" title="全局/静态存储区(.data段和.bss段)"></a>全局/静态存储区(.data段和.bss段)</h2><p>C语言中，.data段(数据段)存放被初始化为非0的全局变量、静态全局变量、静态局部变量。.bss段存放未被初始化的全局变量(初始化为0的全局变量);未被初始化的静态局部变量。<br>C++中，对以上两者不进行区分。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆用于存放进程运行时动态分配的内存段，可动态扩张或缩减。堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问。当进程调用malloc(C)/new(C++)等函数分配内存时，新分配的内存动态添加到堆上(扩张)；当调用free(C)/delete(C++)等函数释放内存时，被释放的内存从堆中剔除(缩减) 。<br>堆内存空间由程序员自行管理，如果程序员申请了内存空间，但是不释放，就会造成内存泄漏。 </p>
<h2 id="内存映射段"><a href="#内存映射段" class="headerlink" title="内存映射段"></a>内存映射段</h2><p>内核将硬盘文件的内容直接映射到内存, 应用程序可以通过Linux的mmap()系统调用请求这种映射。内存映射是一种方便高效的文件I/O方式， 因而被用于装载动态共享库。用户也可创建匿名内存映射，该映射没有对应的文件, 可用于存放程序数据。</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈内存空间由系统管理，运行时分配。存储函数的形参、局部变量等。注意：一般函数返回不返回局部变量的地址，会造成访问错误。栈的增长方向向下，即向着内存地址减小的方向；堆的增长方向向上，即向着内存地址增加的方向。  </p>
<p>函数调用过程中，需要保存现场(寄存器的值、返回地址等)。函数调用过程中，主调函数 在栈上分配的内存、堆上分配的内存、全局区分配的内存 被调函数都是可以使用的。被调函数 堆上分配的内存、全局区分配的内存 可以被 主调函数使用，但是 栈上分配的内存 不可以被主调函数使用。因为 被调函数执行完成之后，栈上有关 被调函数的内存空间被析构了。</p>
<ul>
<li>函数调用过程分析</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void funcB()&#123;</span><br><span class="line"></span><br><span class="line">	printf(&quot;Hello World\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void funcA(int *p)&#123;</span><br><span class="line">	*p &#x3D; 10;</span><br><span class="line"></span><br><span class="line">	funcB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; main函数中的 a 变量对应的内存空间可以在 被调函数中访问。</span><br><span class="line">&#x2F;&#x2F; main函数调用 funcA() 时：先将 main 函数的运行状态入栈，然后 main 函数的返回地址入栈，</span><br><span class="line">&#x2F;&#x2F; 最后 funcA(p) 中 p 是局部变量首先入栈。之后程序运行完成后。弹出 main 函数返回地址，</span><br><span class="line">&#x2F;&#x2F; 弹出 main 函数运行状态。</span><br><span class="line">int main()&#123;</span><br><span class="line">	int a &#x3D; 0;</span><br><span class="line">	int *p &#x3D; &amp;a;</span><br><span class="line"></span><br><span class="line">	printf(&quot;%d\n&quot;, a);  &#x2F;&#x2F; 0</span><br><span class="line"></span><br><span class="line">	funcA(p);</span><br><span class="line"></span><br><span class="line">	printf(&quot;%d\n&quot;, a);  &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境变量，是指在操作系统中用来指定操作系统运行环境的一些参数。通常具备以下特征：<br>本质上是字符串；有统一的格式：name-value；值用来描述进程环境信息。<br>存储形式：char <em>[]数组，数组名environ，内部存储字符串，NULL作为哨兵结尾。引入环境变量表：须声明环境变量。extern char *</em> environ;    </p>
<ul>
<li>environ.c</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">extern char **environ;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	for(i &#x3D; 0; environ[i] !&#x3D; NULL; i++)&#123;  &#x2F;&#x2F; NULL作为哨兵结尾</span><br><span class="line">		printf(&quot;%s\n&quot;, environ[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a>PATH</h3><p>可执行文件的搜索路径。shell下ls等命令是/bin/下的一个可执行程序，因为在PATH环境变量的值里面包含了这些命令所在的目录/bin。PATH环境变量的值可以包含多个目录，用:号隔开。在Shell中用echo命令可以查看这个环境变量的值：<code>echo $PATH</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char *getenv(const char *name);   &#x2F;&#x2F; 获取环境变量</span><br><span class="line">int setenv(const char *name, const char *value, int overwrite); &#x2F;&#x2F; 设置环境变量</span><br><span class="line">int unsetenv(const char *name);   &#x2F;&#x2F; 删除环境变量</span><br></pre></td></tr></table></figure>
<h1 id="C库函数和linux系统函数"><a href="#C库函数和linux系统函数" class="headerlink" title="C库函数和linux系统函数"></a>C库函数和linux系统函数</h1><p><a href="https://www.cnblogs.com/haore147/p/3648395.html" target="_blank" rel="noopener">c语言<em>文件操作_FILE结构体解释</em>涉及对操作系统文件FCB操作的解释_</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man man</span><br><span class="line">       1   可执行程序或 shell 命令</span><br><span class="line">       2   系统调用(内核提供的函数)</span><br><span class="line">       3   库调用(程序库中的函数)</span><br><span class="line">       4   特殊文件(通常位于 &#x2F;dev)</span><br><span class="line">       5   文件格式和规范，如 &#x2F;etc&#x2F;passwd</span><br><span class="line">       6   游戏</span><br><span class="line">       7   杂项(包括宏包和规范，如 man(7)，groff(7))</span><br><span class="line">       8   系统管理命令(通常只针对 root 用户)</span><br><span class="line">       9   内核例程 [非标准]</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/27-linux-内存管理/03-C语言文件操作库函数.png" alt="&quot;03-C语言文件操作库函数&quot;"></p>
<p>C程序用不同的FILE结构体管理每个文件。程序员可以使用文件，但是不需要知道FILE结构的细节。实际上，FILE结构是间接地操作系统的文件控制块(FCB)来实现对文件的操作的。C库函数和系统函数的区别在于缓冲。</p>
<p><strong>缓存文件系统</strong>：<br>缓冲文件系统的特点是：在内存开辟一个“缓冲区”，为程序中的每一个文件使用；当执行读文件的操作时，从磁盘文件将数据先读入内存“缓冲区”，装满后再从内存“缓冲区”依此读出需要的数据。执行写文件的操作时，先将数据写入内存“缓冲区”，待内存“缓冲区”装满后再写入文件。由此可以看出，内存“缓冲区”的大小，影响着实际操作外存的次数，内存“缓冲区”越大，则操作外存的次数就少，执行速度就快、效率高。一般来说，文件“缓冲区”的大小随机器而定。fopen, fclose, fread, fwrite, fgetc, fgets, fputc, fputs, freopen, fseek, ftell, rewind等。<strong>预读入缓输出机制</strong></p>
<p><strong>非缓冲文件系统</strong>：<br>缓冲文件系统是借助文件结构体指针来对文件进行管理，通过文件指针来对文件进行访问，既可以读写字符、字符串、格式化数据，也可以读写二进制数据。非缓冲文件系统依赖于操作系统，通过操作系统的功能对文件进行读写，是系统级的输入输出，它不设文件结构体指针，只能读写二进制文件，但效率高、速度快，由于ANSI标准不再包括非缓冲文件系统，因此建议大家最好不要选择它。open, close, read, write, getc, getchar, putc, putchar等。</p>
<p>一句话总结一下，就是open无缓冲，fopen有缓冲。前者与read, write等配合使用， 后者与fread,fwrite等配合使用。</p>
<p>使用fopen函数，由于在用户态下就有了缓冲，因此进行文件读写操作的时候就减少了用户态和内核态的切换（切换到内核态调用还是需要调用系统调用API:read，write）；而使用open函数，在文件读写时则每次都需要进行内核态和用户态的切换。</p>
<p>比如：使用fwrite和write循环1000次，每次写入一个字节。此时fwrite由于有缓冲(4096字节)，减少了用户态和内核态的切换，速度快；而write用于要不停的切换用户态和内核态，速度慢。strace命令查看。</p>
<p><img src="/images/27-linux-内存管理/06-FILE结构体.png" alt="&quot;06-FILE结构体&quot;"><br><img src="/images/27-linux-内存管理/04-pcb和文件描述符.png" alt="&quot;04-pcb和文件描述符&quot;"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"><b>图3</b></div>
    <br>
</center>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct task_struct &#123;</span><br><span class="line">...</span><br><span class="line">struct files_struct *files;	&#x2F;&#x2F; 打开文件信息</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体PCB 的成员变量file_struct *file 指向文件描述符表。<br>   从应用程序使用角度，该指针可理解记忆成一个字符指针数组，下标0/1/2/3/4…找到文件结构体。<br>   本质是一个键值对0、1、2…都分别对应具体地址。但键值对使用的特性是自动映射，我们只操作键不直接使用值。<br>新打开文件返回文件描述符表中未使用的最小文件描述符。</p>
<p>STDIN_FILENO      0<br>STDOUT_FILENO      1<br>STDERR_FILENO    2</p>
<p><img src="/images/27-linux-内存管理/07-库函数和系统函数的关系.png" alt="&quot;07-库函数和系统函数的关系&quot;"></p>
<p><center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"><b>图4</b></div>
    <br>
</center><br>从<a href="https://www.cnblogs.com/joey-hua/p/5570691.html" target="_blank" rel="noopener">Linux0.11内核—系统调用机制分析</a>可知，用户区到内核区的转换是通过中断实现的。</p>
<h1 id="链接地址"><a href="#链接地址" class="headerlink" title="链接地址"></a>链接地址</h1><p><a href="https://blog.csdn.net/sunweixiang1002/article/details/80407886" target="_blank" rel="noopener">深入理解C语言内存管理</a><br><a href="https://blog.csdn.net/laiqun_ai/article/details/8528366" target="_blank" rel="noopener">bss、data和rodata区别与联系</a><br><a href="https://www.cnblogs.com/clover-toeic/p/3754433.html" target="_blank" rel="noopener">Linux虚拟地址空间布局</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>28-leetcode-滑动窗口</title>
    <url>/2020/02/19/28-leetcode-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a>
<h1 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">长度最小的子数组</a></h1><ul>
<li><p>写法一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int left&#x3D;0, right&#x3D;-1;   &#x2F;&#x2F; nums[left...right]为滑动窗口，初始为空</span><br><span class="line">        int sum&#x3D;0;</span><br><span class="line">        int minLen&#x3D;nums.size()+1;  &#x2F;&#x2F; 设置连续子数组为一个不可能的最大值</span><br><span class="line">        while(left&lt;nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(right+1&lt;nums.size() &amp;&amp; sum&lt;s)</span><br><span class="line">                sum +&#x3D; nums[++right];</span><br><span class="line">            else</span><br><span class="line">                sum -&#x3D; nums[left++];</span><br><span class="line"></span><br><span class="line">            if(sum&gt;&#x3D;s)</span><br><span class="line">                minLen &#x3D; min(minLen, right-left+1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(minLen &#x3D;&#x3D; nums.size()+1)</span><br><span class="line">            return 0;</span><br><span class="line">        return minLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>写法二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int left&#x3D;0, right&#x3D;-1;   &#x2F;&#x2F; nums[left...right]为滑动窗口，初始为空</span><br><span class="line">        int sum&#x3D;0;</span><br><span class="line">        int res&#x3D;nums.size()+1;  &#x2F;&#x2F; 设置连续子数组为一个不可能的最大值</span><br><span class="line">        while(left&lt;nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(sum&gt;&#x3D;s)</span><br><span class="line">            &#123;</span><br><span class="line">                res &#x3D; min(res, right-left+1);</span><br><span class="line">                sum -&#x3D; nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            else if(right+1&lt;nums.size() &amp;&amp; sum &lt; s)</span><br><span class="line">                sum +&#x3D; nums[++right];</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(res &#x3D;&#x3D; nums.size()+1)</span><br><span class="line">            return 0;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="无重复字符的最长子串-https-leetcode-cn-com-problems-longest-substring-without-repeating-characters"><a href="#无重复字符的最长子串-https-leetcode-cn-com-problems-longest-substring-without-repeating-characters" class="headerlink" title="[无重复字符的最长子串]{https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/}"></a>[无重复字符的最长子串]{<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/}" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/}</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        int freq[256] &#x3D; &#123;0&#125;;</span><br><span class="line">        int left&#x3D;0, right&#x3D;-1;</span><br><span class="line">        int maxLen&#x3D;0;</span><br><span class="line">        while(left&lt;s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(right+1&lt;s.size() &amp;&amp; freq[s[right+1]]&#x3D;&#x3D;0)</span><br><span class="line">                freq[s[++right]]++;</span><br><span class="line">            else</span><br><span class="line">                freq[s[left++]]--;</span><br><span class="line"></span><br><span class="line">            maxLen &#x3D; max(maxLen, right-left+1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">找到字符串中所有字母异位词</a></h1><ul>
<li><p>暴力解法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; findAnagrams(string s, string p) &#123;</span><br><span class="line">        int left&#x3D;0;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        while(left&lt;s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(left+p.size()-1&lt;s.size() &amp;&amp; anagram(s, left, p)) &#x2F;&#x2F; 没有重用</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool anagram(string s, int left, string p)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s.size()-left &lt; p.size())</span><br><span class="line">            return false;</span><br><span class="line">        int freq[256] &#x3D; &#123;0&#125;;</span><br><span class="line">        for(char c : p)</span><br><span class="line">            freq[c]++;</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;left; i&lt;left+p.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(freq[s[i]] &#x3D;&#x3D; 0)</span><br><span class="line">                return false;</span><br><span class="line">            else</span><br><span class="line">                freq[s[i]]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>滑动窗口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; findAnagrams(string s, string p) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line"></span><br><span class="line">        if(s.size() &lt; p.size())</span><br><span class="line">            return res;</span><br><span class="line"></span><br><span class="line">        int left&#x3D;0, right&#x3D;-1;</span><br><span class="line">        vector&lt;int&gt; freq_p(26, 0);</span><br><span class="line">        for(char c : p)</span><br><span class="line">            freq_p[c-&#39;a&#39;]++;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; freq_s(26, 0);</span><br><span class="line"></span><br><span class="line">        while(left&lt;s.size())    &#x2F;&#x2F; 重用</span><br><span class="line">        &#123;</span><br><span class="line">            if((right-left+1) &#x3D;&#x3D; p.size() &amp;&amp; same(freq_p, freq_s))</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(left);</span><br><span class="line">                freq_s[s[left++]-&#39;a&#39;]--;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(right+1&lt;s.size() &amp;&amp; (right-left+1)&lt;p.size())    </span><br><span class="line">            &#123;</span><br><span class="line">                freq_s[s[++right]-&#39;a&#39;]++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                freq_s[s[left++]-&#39;a&#39;]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool same(const vector&lt;int&gt;&amp; freq_p, const vector&lt;int&gt;&amp; freq_s)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;26; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(freq_p[i] !&#x3D; freq_s[i])</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">最小覆盖子串</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string minWindow(string s, string t) &#123;</span><br><span class="line">        int left&#x3D;0, right&#x3D;-1;</span><br><span class="line">        int minLen &#x3D; s.size()+1;</span><br><span class="line">        string mins;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; freq_t(256, 0);</span><br><span class="line">        for(char c : t)</span><br><span class="line">            freq_t[c]++;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; freq_s(256, 0);</span><br><span class="line"></span><br><span class="line">        while(left&lt;s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            bool b &#x3D; contain(freq_s, freq_t);</span><br><span class="line">            if(right+1&lt;s.size() &amp;&amp; !b)</span><br><span class="line">                freq_s[s[++right]]++;</span><br><span class="line">            else if(b)</span><br><span class="line">            &#123;</span><br><span class="line">                if(((minLen&gt;right-left+1)))</span><br><span class="line">                &#123;</span><br><span class="line">                    minLen &#x3D; right-left+1;</span><br><span class="line">                    mins.assign(s, left, right-left+1);</span><br><span class="line">                &#125;</span><br><span class="line">                freq_s[s[left++]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return mins;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool contain(const vector&lt;int&gt;&amp; freq_s, const vector&lt;int&gt;&amp; freq_t)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;256; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if((freq_s[i]-freq_t[i])&lt;0)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>滑动窗口的起始条件：left=0,right=-1;<br>滑动窗口的循环条件：left&lt;nums.size()<br>滑动窗口的right条件：right+1&lt;nums.size()<br>注意：防止left和right指针不动导致循环停止的情况。</p>
]]></content>
      <categories>
        <category>刷题</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>29-tools-vscode的使用</title>
    <url>/2020/02/23/29-tools-vscode%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://code.visualstudio.com/docs" target="_blank" rel="noopener">vscode官方文档</a><br><a id="more"></a></p>
<h1 id="vscode-install"><a href="#vscode-install" class="headerlink" title="vscode-install"></a>vscode-install</h1><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><p>下载<a href="https://go.microsoft.com/fwlink/?LinkID=760868" target="_blank" rel="noopener">.deb package (64-bit)</a>。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install .&#x2F;&lt;file&gt;.deb</span><br></pre></td></tr></table></figure></p>
<h1 id="vscode-C"><a href="#vscode-C" class="headerlink" title="vscode-C++"></a>vscode-C++</h1><h2 id="GCC-on-Linux"><a href="#GCC-on-Linux" class="headerlink" title="GCC on Linux"></a>GCC on Linux</h2><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><ol>
<li>安装VSCode</li>
<li>安装C/C++ extension for VS Code。在Extensions视图(Ctrl+Shift+X)中搜索’c++’来安装。<br><img src="/images/29-tools-vscode的使用/1.cpp-extension.png" alt="&quot;1.cpp-extension&quot;"></li>
</ol>
<p><strong>确保GCC已经安装</strong>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gcc</span><br><span class="line">sudo apt-get install build-essential gdb</span><br></pre></td></tr></table></figure></p>
<h3 id="创建Hello-World"><a href="#创建Hello-World" class="headerlink" title="创建Hello World"></a>创建Hello World</h3><p>在终端下，创建一个名为projects的空文件夹，可以在其中放置所有VS代码项目。然后创建一个名为helloworld的子文件夹，导航到其中，通过输入以下命令在该文件夹中打开VS代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir projects</span><br><span class="line">cd projects</span><br><span class="line">mkdir helloworld</span><br><span class="line">cd helloworld</span><br><span class="line">code .</span><br></pre></td></tr></table></figure><br><code>code .</code>命令打开当前工作文件夹中的VS代码，这将成为您的“工作区”。在你浏览教程的过程中，你会看到在工作区的.vscode文件夹中创建的三个文件:</p>
<ul>
<li>tasks.json(构建指令)</li>
<li>launch.json(调试器设置)</li>
<li>c_cpp_properties.json(编译器路径和智能提示)</li>
</ul>
<h3 id="添加源代码文件"><a href="#添加源代码文件" class="headerlink" title="添加源代码文件"></a>添加源代码文件</h3><p>在菜单栏选择File-&gt;New File并命名为helloworld.cpp。<br><img src="/images/29-tools-vscode的使用/2.file-explorer-mingw.png" alt="&quot;2.file-explorer-mingw&quot;"><br>添加源代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;string&gt; msg &#123;&quot;Hello&quot;, &quot;C++&quot;, &quot;World&quot;, &quot;from&quot;, &quot;VS Code&quot;, &quot;and the C++ extension!&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    for (const string&amp; word : msg)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; word &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="编译helloworld-cpp"><a href="#编译helloworld-cpp" class="headerlink" title="编译helloworld.cpp"></a>编译helloworld.cpp</h3><p>编译需要创建一个tasks.json文件来告诉VS Code如何编译程序。这个任务调用g++编译器来基于源代码创建一个可执行文件。<br>从菜单栏选择 Terminal-&gt;Configure Default Build Task(配置默认生成任务)。在下拉列表会列出c++编译器的各种预定义构建任务。选择g++ build active file。这将会在.vscode文件夹下创建tasks.json文件，并在编辑器中打开。tasks.json的文件内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">	&quot;tasks&quot;: [</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">			&quot;label&quot;: &quot;C&#x2F;C++: g++ build active file&quot;,</span><br><span class="line">			&quot;command&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;g++&quot;,</span><br><span class="line">			&quot;args&quot;: [</span><br><span class="line">				&quot;-g&quot;,</span><br><span class="line">				&quot;$&#123;file&#125;&quot;,</span><br><span class="line">				&quot;-o&quot;,</span><br><span class="line">				&quot;$&#123;fileDirname&#125;&#x2F;$&#123;fileBasenameNoExtension&#125;&quot;</span><br><span class="line">			],</span><br><span class="line">			&quot;options&quot;: &#123;</span><br><span class="line">				&quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;problemMatcher&quot;: [</span><br><span class="line">				&quot;$gcc&quot;</span><br><span class="line">			],</span><br><span class="line">			&quot;group&quot;: &#123;</span><br><span class="line">				&quot;kind&quot;: &quot;build&quot;,</span><br><span class="line">				&quot;isDefault&quot;: true</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>command</code>设置指定要运行的程序，这里是g++。<br><code>args</code>数组指定将传递给g++的命令行参数。这些参数必须按照编译器期望的顺序指定。这个任务告诉g++获取活动文件(${file})，编译它，并在当前目录(${fileDirname})中创建一个与活动文件同名但扩展名的可执行文件，在这个示例中生成helloworld。<br><code>label</code>值是你将在任务列表中看到的值；你可以给它起任何你喜欢的名字。<br><code>isDefault</code>：组对象中的true值指定当你按Ctrl+Shift+B时该任务将会运行。这个属性只是为了方便；如果设置为false，仍然可以在Terminal菜单中运行任务：Run Build Task。</p>
<p>注意：更多关于task.json的变量信息可以在<a href="https://code.visualstudio.com/docs/editor/variables-reference" target="_blank" rel="noopener">变量引用</a>中查看</p>
<p><strong>运行构建</strong>:</p>
<ol>
<li>回到 helloworld.cpp。</li>
<li>运行在tasks.json中定义的生成任务，按Ctrl+Shift+B或从菜单栏选择Terminal-&gt;Run Build Task。</li>
<li>当任务开始时，您应该会看到集成的终端面板出现在源代码编辑器的下面。任务完成后，终端显示编译器的输出，指示构建是成功还是失败。对于一个成功的g++构建，输出如下所示:<br><img src="/images/29-tools-vscode的使用/7.wsl-task-in-terminal.png" alt="&quot;7.wsl-task-in-terminal&quot;"></li>
<li>使用 + button创建一个新的终端。运行<code>ls</code>就可以看到可执行文件helloworld。<br><img src="/images/29-tools-vscode的使用/8.wsl-bash-terminal.png" alt="&quot;8.wsl-bash-terminal&quot;"></li>
</ol>
<h3 id="调试helloworld-cpp"><a href="#调试helloworld-cpp" class="headerlink" title="调试helloworld.cpp"></a>调试helloworld.cpp</h3><p>调试程序(F5)需要创建一个launch.json文件来配置VS Code启动GDB调试器。从菜单栏中选择 Run-&gt;Add Configuration…(添加配置…)，然后选择C++(GDB/LLDB)。<br>然后您将看到各种预定义调试配置的下拉列表。选择g++-build and debug active file。<br><img src="/images/29-tools-vscode的使用/5.build-and-debug-active-file.png" alt="&quot;5.build-and-debug-active-file&quot;"></p>
<p>VS Code创建一个launch.json文件，在编辑器中打开，构建并运行’helloworld’。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 使用 IntelliSense 了解相关属性。 </span><br><span class="line">    &#x2F;&#x2F; 悬停以查看现有属性的描述。</span><br><span class="line">    &#x2F;&#x2F; 欲了解更多信息，请访问: https:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?linkid&#x3D;830387</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;g++ - 生成和调试活动文件&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;fileDirname&#125;&#x2F;$&#123;fileBasenameNoExtension&#125;&quot;,</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;stopAtEntry&quot;: false,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: false,</span><br><span class="line">            &quot;MIMode&quot;: &quot;gdb&quot;,</span><br><span class="line">            &quot;setupCommands&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;,</span><br><span class="line">                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class="line">                    &quot;ignoreFailures&quot;: true</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;preLaunchTask&quot;: &quot;C&#x2F;C++: g++ build active file&quot;,</span><br><span class="line">            &quot;miDebuggerPath&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;gdb&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>program</code>设置指定要调试的程序。在这里它被设置为活动文件夹${fileDirname}和无扩展名的活动文件名${fileBasenameNoExtension}。如果helloworld.cpp是活动文件，它将是helloworld。<br>默认情况下，c++扩展不会向源代码添加任何断点，并且stopAtEntry值设置为false。将stopAtEntry值更改为true，以便在开始调试时使调试器在主方法上停止。</p>
<p><strong>启动调试会话</strong>：</p>
<ol>
<li>回到helloworld.cpp，使其成为活动文件。</li>
<li>按F5或从主菜单中选择 run&gt;Start Debugging。</li>
</ol>
<h3 id="C-C-配置"><a href="#C-C-配置" class="headerlink" title="C/C++配置"></a>C/C++配置</h3><p>如果想对C/C++扩展进行更多的控制，可以创建一个c_cpp_properties.json文件。这个文件允许你修改如编译器路径，包括路径、c++标准(默认c++17)等设置。可以通过从命令面板(Ctrl+Shift+P)运行命令：C/C++ Edit Configurations(UI)来查看C/C++配置。<br><img src="/images/29-tools-vscode的使用/6.command-palette.png" alt="&quot;6.command-palette&quot;">。<br>这会打开C/C++ Configuration页面。当你修改这个文件，VS Code会将这些内容写入.vscode文件夹下的c_cpp_properties.json。</p>
<p><img src="/images/29-tools-vscode的使用/9.intellisense-configurations-wsl.png" alt="&quot;9.intellisense-configurations-wsl.&quot;"><br>如果你的程序包含不在你的工作区或者标准库路径下的头文件，你只需要修改<strong>include path</strong>设置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Linux&quot;,</span><br><span class="line">            &quot;includePath&quot;: [</span><br><span class="line">                &quot;$&#123;workspaceFolder&#125;&#x2F;**&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;defines&quot;: [],</span><br><span class="line">            &quot;compilerPath&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;clang&quot;,</span><br><span class="line">            &quot;cStandard&quot;: &quot;c11&quot;,</span><br><span class="line">            &quot;cppStandard&quot;: &quot;c++14&quot;,</span><br><span class="line">            &quot;intelliSenseMode&quot;: &quot;clang-x64&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>VS代码现在配置为在Linux上使用gcc。配置应用于当前工作区。要重用配置，只需将JSON文件复制到新项目文件夹(工作区)中的.vscode文件夹中，并根据需要更改源文件和可执行文件的名称。</p>
<h2 id="GCC-on-Windows"><a href="#GCC-on-Windows" class="headerlink" title="GCC on Windows"></a>GCC on Windows</h2><p>配置VSCode使用Mingw-64中的GCC C++编译器和GDB调试器在Windows上运行程序。</p>
<h3 id="先决条件-1"><a href="#先决条件-1" class="headerlink" title="先决条件"></a>先决条件</h3><ol>
<li>安装VSCode</li>
<li>安装C/C++ extension for VS Code。在Extensions视图(Ctrl+Shift+X)中搜索’c++’来安装。<br><img src="/images/29-tools-vscode的使用/1.cpp-extension.png" alt="&quot;1.cpp-extension&quot;"></li>
<li>通过Source Forge安装Mingw-64。单击<a href="https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/installer/mingw-w64-install.exe/download" target="_blank" rel="noopener">Mingw-64</a>开始下载在线安装程序。注意，在线安装的方法需要VPN。如果无法在线安装，可以到Source Forge的<a href="https://sourceforge.net/projects/mingw-w64/files/" target="_blank" rel="noopener">Mingw页面</a>下载对应的离线安装包，然后将离线安装包解压。这里我将解压文件夹中的mingw64文件夹安装到C:\mingw-w64文件夹下。</li>
<li>将Mingw-w64 bin 文件夹添加到环境变量中<ul>
<li>在搜索栏输入 此电脑，右键属性。点击 高级系统设置，选择高级选项卡。</li>
<li>点击环境变量。选择系统变量-&gt;Path变量-&gt;编辑，添加mingw64的bin目录到环境变量。<br>比如：c:\mingw-w64\x86_64-8.1.0-win32-seh-rt_v6-rev0\mingw64\bin。</li>
</ul>
</li>
<li>检测MinGW的安装<br>打开cmd，输入：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ --version</span><br><span class="line">gdb --version</span><br></pre></td></tr></table></figure>
如果有输出，表示安装成功。</li>
</ol>
<h3 id="创建Hello-World-1"><a href="#创建Hello-World-1" class="headerlink" title="创建Hello World"></a>创建Hello World</h3><p>在Windows命令提示符下，创建一个名为projects的空文件夹，可以在其中放置所有VS代码项目。然后创建一个名为helloworld的子文件夹，导航到其中，通过输入以下命令在该文件夹中打开VS代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir projects</span><br><span class="line">cd projects</span><br><span class="line">mkdir helloworld</span><br><span class="line">cd helloworld</span><br><span class="line">code .</span><br></pre></td></tr></table></figure><br><code>code .</code>命令打开当前工作文件夹中的VS代码，这将成为您的“工作区”。在你浏览教程的过程中，你会看到在工作区的.vscode文件夹中创建的三个文件:</p>
<ul>
<li>tasks.json(构建指令)</li>
<li>launch.json(调试器设置)</li>
<li>c_cpp_properties.json(编译器路径和智能提示)</li>
</ul>
<h3 id="添加源代码文件-1"><a href="#添加源代码文件-1" class="headerlink" title="添加源代码文件"></a>添加源代码文件</h3><p>在菜单栏选择File-&gt;New File并命名为helloworld.cpp。<br><img src="/images/29-tools-vscode的使用/2.file-explorer-mingw.png" alt="&quot;2.file-explorer-mingw&quot;"><br>添加源代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;string&gt; msg &#123;&quot;Hello&quot;, &quot;C++&quot;, &quot;World&quot;, &quot;from&quot;, &quot;VS Code&quot;, &quot;and the C++ extension!&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    for (const string&amp; word : msg)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; word &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="编译helloworld-cpp-1"><a href="#编译helloworld-cpp-1" class="headerlink" title="编译helloworld.cpp"></a>编译helloworld.cpp</h3><p>编译需要创建一个tasks.json文件来告诉VS Code如何编译程序。这个任务调用g++编译器来基于源代码创建一个可执行文件。<br>从菜单栏选择 Terminal-&gt;Configure Default Build Task。在下拉列表会列出c++编译器的各种预定义构建任务。选择g++.exe build active file。这将会在.vscode文件夹下创建tasks.json文件，并在编辑器中打开。tasks.json的文件内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">	&quot;tasks&quot;: [</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">			&quot;label&quot;: &quot;C&#x2F;C++: g++.exe build active file&quot;,</span><br><span class="line">			&quot;command&quot;: &quot;C:\\mingw-w64\\x86_64-8.1.0-release-posix-sjlj-rt_v6-rev0\\mingw64\\bin\\g++.exe&quot;,</span><br><span class="line">			&quot;args&quot;: [</span><br><span class="line">				&quot;-g&quot;,</span><br><span class="line">				&quot;$&#123;file&#125;&quot;,</span><br><span class="line">				&quot;-o&quot;,</span><br><span class="line">				&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><br><span class="line">			],</span><br><span class="line">			&quot;options&quot;: &#123;</span><br><span class="line">				&quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;problemMatcher&quot;: [</span><br><span class="line">				&quot;$gcc&quot;</span><br><span class="line">			],</span><br><span class="line">			&quot;group&quot;: &#123;</span><br><span class="line">				&quot;kind&quot;: &quot;build&quot;,</span><br><span class="line">				&quot;isDefault&quot;: true</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>command</code>设置指定要运行的程序，这里是g++。<br><code>args</code>数组指定将传递给g++的命令行参数。这些参数必须按照编译器期望的顺序指定。这个任务告诉g++获取活动文件(${file})，编译它，并在当前目录(${fileDirname})中创建一个与活动文件同名但扩展名为.exe的可执行文件，在这个示例中生成helloworld.exe。<br><code>label</code>值是你将在任务列表中看到的值；你可以给它起任何你喜欢的名字。<br><code>isDefault</code>：组对象中的true值指定当你按Ctrl+Shift+B时该任务将会运行。这个属性只是为了方便；如果设置为false，仍然可以在Terminal菜单中运行任务：Run Build Task。</p>
<p>注意：更多关于task.json的变量信息可以在<a href="https://code.visualstudio.com/docs/editor/variables-reference" target="_blank" rel="noopener">变量引用</a>中查看</p>
<p><strong>运行构建</strong>:</p>
<ol>
<li>回到 helloworld.cpp。</li>
<li>运行在tasks.json中定义的生成任务，按Ctrl+Shift+B或从菜单栏选择Terminal-&gt;Run Build Task。</li>
<li>当任务开始时，您应该会看到集成的终端面板出现在源代码编辑器的下面。任务完成后，终端显示编译器的输出，指示构建是成功还是失败。对于一个成功的g++构建，输出如下所示:<br><img src="/images/29-tools-vscode的使用/3.build-output-in-terminal.png" alt="&quot;3.build-output-in-terminal&quot;"></li>
<li>使用 + button创建一个新的终端。运行<code>dir</code>就可以看到可执行文件helloworld.exe。<br><img src="/images/29-tools-vscode的使用/4.helloworld-in-terminal.png" alt="&quot;4.helloworld-in-terminal&quot;"></li>
</ol>
<p>注意：运行时可能没有输出。原因在于g++编译运行时出现：无法定位程序输入点__gxx_personality_v0 问题。<br><a href="https://blog.csdn.net/lushuchengsky/article/details/78002565" target="_blank" rel="noopener">解决方法</a></p>
<p><strong>4种解决方法</strong>：</p>
<ol>
<li>使用-static 编译[g++ -static file.cpp]</li>
<li>删除掉其他含有libstdc++-6.dll 的PATH环境变量，只留下mingw的</li>
<li>将 libstdc++-6.dll 文件与代码放置同一文件编译</li>
<li>将 libstdc++-6.dll 文件放到System32(博主尝试这个有效)或SysWOW64文件夹下。  [这个比较方便]</li>
</ol>
<h3 id="调试helloworld-cpp-1"><a href="#调试helloworld-cpp-1" class="headerlink" title="调试helloworld.cpp"></a>调试helloworld.cpp</h3><p>调试程序(F5)需要创建一个launch.json文件来配置VS Code启动GDB调试器。从菜单栏中选择 Run-&gt;Add Configuration…，然后选择C++(GDB/LLDB)。<br>然后您将看到各种预定义调试配置的下拉列表。选择g++.exe-生成和调试活动文件。<br><img src="/images/29-tools-vscode的使用/5.build-and-debug-active-file.png" alt="&quot;5.build-and-debug-active-file&quot;"></p>
<p>VS Code创建一个launch.json文件，在编辑器中打开，构建并运行’helloworld’。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Use IntelliSense to learn about possible attributes.</span><br><span class="line">    &#x2F;&#x2F; Hover to view descriptions of existing attributes.</span><br><span class="line">    &#x2F;&#x2F; For more information, visit: https:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?linkid&#x3D;830387</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;g++.exe - 生成和调试活动文件&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;,</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;stopAtEntry&quot;: false,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: false,</span><br><span class="line">            &quot;MIMode&quot;: &quot;gdb&quot;,</span><br><span class="line">            &quot;miDebuggerPath&quot;: &quot;C:\\mingw-w64\\x86_64-8.1.0-release-posix-sjlj-rt_v6-rev0\\mingw64\\bin\\gdb.exe&quot;,</span><br><span class="line">            &quot;setupCommands&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;,</span><br><span class="line">                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class="line">                    &quot;ignoreFailures&quot;: true</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;preLaunchTask&quot;: &quot;C&#x2F;C++: g++.exe build active file&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>program</code>设置指定要调试的程序。在这里它被设置为活动文件夹${fileDirname}和扩展名为.exe的活动文件名${fileBasenameNoExtension}。如果helloworld.cpp是活动文件，它将是helloworld.exe。<br>默认情况下，c++扩展不会向源代码添加任何断点，并且stopAtEntry值设置为false。将stopAtEntry值更改为true，以便在开始调试时使调试器在主方法上停止。</p>
<p><strong>启动调试会话</strong>：</p>
<ol>
<li>回到helloworld.cpp，使其成为活动文件。</li>
<li>按F5或从主菜单中选择 run&gt;Start Debugging。</li>
</ol>
<h3 id="C-C-配置-1"><a href="#C-C-配置-1" class="headerlink" title="C/C++配置"></a>C/C++配置</h3><p>如果想对C/C++扩展进行更多的控制，可以创建一个c_cpp_properties.json文件。这个文件允许你修改如编译器路径，包括路径、c++标准(默认c++17)等设置。可以通过从命令面板(Ctrl+Shift+P)运行命令：C/C++ Edit Configurations(UI)来查看C/C++配置。<br><img src="/images/29-tools-vscode的使用/6.command-palette.png" alt="&quot;6.command-palette&quot;">。<br>这会打开C/C++ Configuration页面。当你修改这个文件，VS Code会将这些内容写入.vscode文件夹下的c_cpp_properties.json。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Win32&quot;,</span><br><span class="line">            &quot;includePath&quot;: [</span><br><span class="line">                &quot;$&#123;workspaceFolder&#125;&#x2F;**&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;defines&quot;: [</span><br><span class="line">                &quot;_DEBUG&quot;,</span><br><span class="line">                &quot;UNICODE&quot;,</span><br><span class="line">                &quot;_UNICODE&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;windowsSdkVersion&quot;: &quot;10.0.17763.0&quot;,</span><br><span class="line">            &quot;compilerPath&quot;: &quot;C:&#x2F;mingw-w64&#x2F;x86_64-8.1.0-release-posix-sjlj-rt_v6-rev0&#x2F;mingw64&#x2F;bin&#x2F;g++.exe&quot;,</span><br><span class="line">            &quot;cStandard&quot;: &quot;c11&quot;,</span><br><span class="line">            &quot;cppStandard&quot;: &quot;c++17&quot;,</span><br><span class="line">            &quot;intelliSenseMode&quot;: &quot;clang-x86&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>只有当程序包含的头文件不在工作区或在标准库路径中时，才需要添加到Include path数组设置中。</p>
<p>compilerPath设置是配置中的一个重要设置。扩展使用它来推断c++标准库头文件的路径。当扩展知道在哪里找到这些文件时，它可以提供像智能补全这样的有用特性，并进入定义导航。</p>
<p>C/C++扩展尝试根据在系统上找到的默认编译器来填充compilerPath。该扩展在几个常见的编译器位置查找。<br>compilerPath搜索顺序为：</p>
<ul>
<li>首先检查Microsoft Visual C++编译器</li>
<li>然后在Windows Linux子系统(WSL)上寻找g++</li>
<li>然后Mingw-w64 g++</li>
</ul>
<p>如果你安装了Visual Studio或WSL，你可能需要更改compilerPath以匹配项目的首选编译器。例如，如果您在C:\ Mingw-w64下安装Mingw-w64版本8.1.0，使用Win32线程和SEH异常处理选项，路径将是这样的:C: Mingw-w64 \x86_64-8.1.0-win32-seh-rt_v6-rev0\mingw64\bin\g++.exe。注意：此时intelliSenseMode要修改为：”clang-x86”。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文略去了调试的部分内容，详细查看VS Code原文。</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>30-tools-sourceInsight的使用</title>
    <url>/2020/02/24/30-tools-sourceInsight%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a>
<h1 id="Source-Insight的基本使用"><a href="#Source-Insight的基本使用" class="headerlink" title="Source Insight的基本使用"></a>Source Insight的基本使用</h1><h2 id="安装Source-Insight4096"><a href="#安装Source-Insight4096" class="headerlink" title="安装Source Insight4096"></a>安装Source Insight4096</h2><p>链接：<a href="https://pan.baidu.com/s/1MhjXbHnP8MuX6tSHDuVz6w" target="_blank" rel="noopener">https://pan.baidu.com/s/1MhjXbHnP8MuX6tSHDuVz6w</a><br>提取码：9ovr</p>
<h2 id="建立工程及添加文件"><a href="#建立工程及添加文件" class="headerlink" title="建立工程及添加文件"></a>建立工程及添加文件</h2><ol>
<li>选择菜单栏Project-&gt;New Project，如图1：<br><img src="/images/30-tools-sourceInsight的使用/1.创建工程.png" alt="&quot;1.创建工程&quot;"><center>
 <div style="color:orange; border-bottom: 1px solid #d9d9d9;
 display: inline-block;
 color: #999;
 padding: 2px;"><b>图1</b></div>
 <br>
</center>


</li>
</ol>
<ol>
<li><p>创建SI项目，注意最好把SI项目单独放在一个文件夹下，如图2。<br><img src="/images/30-tools-sourceInsight的使用/2.项目文件位置.png" alt="&quot;2.项目文件位置&quot;"></p>
<center>
 <div style="color:orange; border-bottom: 1px solid #d9d9d9;
 display: inline-block;
 color: #999;
 padding: 2px;"><b>图2</b></div>
 <br>
</center>
</li>
<li><p>创建好项目后，需要添加项目文件。注意SI中，默认支持一些文件类型。但有一些文件类型(如:.s)不支持。此时可以不勾选 Show only known file types将其添加。也可以在菜单栏 OptionS-&gt;File Type Options中添加SI不支持解析的文件类型。<br><img src="/images/30-tools-sourceInsight的使用/3.添加源代码.png" alt="&quot;3.添加源代码&quot;"></p>
<center>
 <div style="color:orange; border-bottom: 1px solid #d9d9d9;
 display: inline-block;
 color: #999;
 padding: 2px;"><b>图3</b></div>
 <br>
</center>

</li>
</ol>
<p><img src="/images/30-tools-sourceInsight的使用/4.SI支持的文件类型.png" alt="&quot;4.SI支持的文件类型&quot;"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"><b>图4</b></div>
    <br>
</center>

<ol>
<li>同步解析源代码文件。菜单栏 Project-&gt;Sychronize Files…<br><img src="/images/30-tools-sourceInsight的使用/5.同步操作.png" alt="&quot;5.同步操作&quot;"><center>
 <div style="color:orange; border-bottom: 1px solid #d9d9d9;
 display: inline-block;
 color: #999;
 padding: 2px;"><b>图5</b></div>
 <br>
</center>

</li>
</ol>
<p><img src="/images/30-tools-sourceInsight的使用/6.勾选.png" alt="&quot;6.勾选&quot;"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"><b>图6</b></div>
    <br>
</center>

<ol>
<li>项目解析完成<br><img src="/images/30-tools-sourceInsight的使用/7.项目文件.png" alt="&quot;7.项目文件&quot;"><center>
 <div style="color:orange; border-bottom: 1px solid #d9d9d9;
 display: inline-block;
 color: #999;
 padding: 2px;"><b>图7</b></div>
 <br>
</center></li>
</ol>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>34-linux-进程</title>
    <url>/2020/03/29/34-linux-%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>linux中每一个运行的程序就是一个进程。程序是由若干条具有一定功能的指令所组成的解题顺序和步骤(磁盘中)。进程是计算机中程序关于某个数据集合上的一次运行活动(内存中)，是操作系统进行资源分配和调度的基本单元。对于32位的linux操作系统，每一个进程都认为其拥有0~4G的虚拟地址空间。虚拟地址空间可以分为内核空间和用户空间。内核空间地址为3G~4G，用户空间为0~3G。</p>
<p>由上可知，每个进程都认为自己有4G的虚拟地址空间。实际上，内核空间是所有进程共享的，用户空间是各个进程独享的。简单理解，如果两个进程间要进行通信必须要有一个桥梁，而每个进程的用户空间都是独享的，只有通过内核空间才能进行进程间通信。并且对于所有进程必须要进行统一的管理，故内核空间中必然使用类似数组的方式对每个进程的信息进行管理。在内核中，每个进程都有一个进程控制块(PCB, Processing Control Block)来维护进程相关的信息，linux内核的进程控制块是task_struct结构体。<br>博主使用Ubuntu18.04，在/usr/src/linux-headers-5.3.0-53/include/linux/sched.h中可以找到task_struct结构体。</p>
<p><a href="https://www.kernel.org/pub/linux/kernel/v2.6/" target="_blank" rel="noopener">linux 2.6版本</a></p>
<p>进程之间共享的数据：代码段、文件描述符(管道、fifo、套接字)、内存映射区<br>线程之间共享的数据：代码段、堆、全局变量、内存映射区。栈不共享。</p>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p><img src="/images/34-linux-进程/1.进程状态.png" alt="&quot;1.进程状态&quot;"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"><b>图1</b></div>
    <br>
</center>

<p>创建状态：进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态<br>就绪状态：进程已经准备好，已分配到所需资源，只要分配到CPU就能够立即运行<br>执行状态：进程处于就绪状态被调度后，进程进入执行状态<br>阻塞状态：正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用<br>终止状态：进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pid_t fork(void);	&#x2F;&#x2F; 失败返回-1；成功返回：父进程返回子进程的ID(非负)；子进程返回 0 </span><br><span class="line">&#x2F;&#x2F; 注意：fork函数不是返回两个值，而是fork之后就存在两个进程。每个进程有不同的返回值。</span><br><span class="line">&#x2F;&#x2F; 父子进程执行的顺序随机。fork后父子进程从相同的程序位置开始执行。</span><br><span class="line">pid_t getpid(void);	  &#x2F;&#x2F; 获取当前进程ID</span><br><span class="line">pid_t getppid(void);  &#x2F;&#x2F; 获取当前进程的父进程ID</span><br><span class="line">uid_t getuid(void);   &#x2F;&#x2F; 获取当前进程实际用户ID</span><br><span class="line">uid_t geteuid(void);  &#x2F;&#x2F; 获取当前进程有效用户ID</span><br><span class="line">gid_t getgid(void);   &#x2F;&#x2F; 获取当前进程使用用户组ID</span><br><span class="line">gid_t getegid(void);  &#x2F;&#x2F; 获取当前进程有效用户组ID</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1个父进程循环创建n个子进程</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int n &#x3D; 5, i;				    &#x2F;&#x2F;一个父进程默认创建5个子进程</span><br><span class="line">	pid_t pid;</span><br><span class="line"></span><br><span class="line">	if (argc &#x3D;&#x3D; 2) &#123;	</span><br><span class="line">		n &#x3D; atoi(argv[1]);		&#x2F;&#x2F;字符串转整数</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pid &#x3D; fork();			&#x2F;&#x2F;出口1,父进程专用出口</span><br><span class="line">		if (pid &#x3D;&#x3D; 0)</span><br><span class="line">			break;				&#x2F;&#x2F;出口2,子进程出口,i不自增</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (n &#x3D;&#x3D; i) &#123;</span><br><span class="line">		sleep(n);</span><br><span class="line">		printf(&quot;I am parent, pid &#x3D; %d\n&quot;, getpid());</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		sleep(i);</span><br><span class="line">		printf(&quot;I&#39;m %dth child, pid &#x3D; %d\n&quot;, i+1, getpid());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父子进程fork之后，简单来看，子进程复制了父进程0~3G用户空间内容以及父进程的PCB，但是pid不同。故子进程执行的代码位置和父进程执行的代码位置相同。之后，根据对<br>fork()返回值的判断，父子进程可以执行不同的代码。</p>
<p><strong>注意</strong>：</p>
<ol>
<li>父子进程执行顺序不定</li>
<li>根据fork返回值判断父子进程</li>
<li>在实际使用过程父子进程间遵循<strong>读时共享写时复制</strong>的原则，这样可以节省内存开销。<br>同时也说明父子进程之间数据是不关联的(父子进程之间不共享全局变量)。</li>
</ol>
<h3 id="exce函数族"><a href="#exce函数族" class="headerlink" title="exce函数族"></a>exce函数族</h3><p>当进程调用exec函数时，当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程ID不变，换核不换壳。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int execl(const char *path, const char *arg, ...);  &#x2F;&#x2F; 加载一个进程，通过路径+程序名来加载</span><br><span class="line">&#x2F;&#x2F; path:要执行程序的绝对路径</span><br><span class="line">&#x2F;&#x2F; 变参arg:要执行程序需要的参数</span><br><span class="line">&#x2F;&#x2F; 第一个arg:占位</span><br><span class="line">&#x2F;&#x2F; 后边的arg:命令的参数</span><br><span class="line">&#x2F;&#x2F; 哨兵：NULL</span><br><span class="line">int execlp(const char *file, const char *arg, ...); &#x2F;&#x2F; 借助环境变量PATH加载一个进程,该函数用来调用系统程序</span><br><span class="line">&#x2F;&#x2F; file:执行命令的名字</span><br><span class="line">&#x2F;&#x2F; 第一个arg:占位</span><br><span class="line">&#x2F;&#x2F; 后边的arg:命令的参数</span><br><span class="line">&#x2F;&#x2F; 哨兵：NULL</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>execl.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    execl(&quot;&#x2F;bin&#x2F;ls&quot;, &quot;ls&quot;, &quot;-lah&quot;, NULL);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>execlp.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;-aux&quot;, NULL);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="孤儿进程和僵尸进程"><a href="#孤儿进程和僵尸进程" class="headerlink" title="孤儿进程和僵尸进程"></a>孤儿进程和僵尸进程</h3><p>孤儿进程: 父进程先于子进程结束，则子进程成为孤儿进程。子进程的父进程变为init进程，称init进程领养孤儿进程。进程结束之后，能够释放用户空间的资源，而内核空间<br>的PCB必须由父进程释放。<br>僵尸进程: 进程终止，父进程尚未回收子进程残留资源(PCB)，则变成僵尸（Zombie）进程。<br>僵尸进程是不能使用kill命令清除掉的。因为kill命令只是用来终止进程的，而僵尸进程已经终止。此时，如果需要释放僵尸进程的残留资源，就需要结束父进程。父进程结束<br>就会自动回收僵尸进程的资源。</p>
<h3 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h3><p>进程终止时会关闭所有的文件描述符，释放在用户空间分配的内存，但PCB是保留的，内核在其中保留了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。父进程可以调用wait或waitpid得到子进程的退出状态同时彻底清除掉这个进程。</p>
<p>父进程调用wait函数可以回收子进程终止信息。该函数有三个功能：</p>
<ul>
<li>阻塞等待子进程退出 </li>
<li>回收子进程残留资源 </li>
<li>获取子进程结束状态(退出原因)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pid_t wait(int *status); 	&#x2F;&#x2F; 一次只能回收一个子进程</span><br><span class="line">&#x2F;&#x2F; status是wait的传出参数，保存进程的结束状态(正常退出还是异常终止)。借助宏函数可以进一步判断进程终止的具体原因。</span><br><span class="line">&#x2F;&#x2F; 正常退出：return 0； exit(0) 此时WEXITSTATUS(staus)可以获取return或exit的返回参数</span><br><span class="line">&#x2F;&#x2F; 第一组：</span><br><span class="line">WIFEXITED(status)     为非0	→ 进程正常结束</span><br><span class="line">WEXITSTATUS(status)   如上宏为真，使用此宏 → 获取进程退出状态 (exit的参数)</span><br><span class="line">&#x2F;&#x2F; 第二组：</span><br><span class="line">WIFSIGNALED(status)   为非0 → 进程异常终止</span><br><span class="line">WTERMSIG(status)      如上宏为真，使用此宏 → 取得使进程终止的那个信号的编号</span><br><span class="line">&#x2F;&#x2F; 第三组：</span><br><span class="line">WIFSTOPPED(status)    为非0 → 进程处于暂停状态</span><br><span class="line">WSTOPSIG(status)      如上宏为真，使用此宏 → 取得使进程暂停的那个信号的编号</span><br><span class="line">WIFCONTINUED(status)  为真 → 进程暂停后已经继续运行</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回值：&gt;0 回收子进程ID；-1 回收失败(没有可回收的子进程)</span><br></pre></td></tr></table></figure>
<ul>
<li>abnor.c</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  int a &#x3D; 5&#x2F;0;  &#x2F;&#x2F; 除0错误 进程执行时linux发送SIGFPE信号终止进程</span><br><span class="line"></span><br><span class="line">	return 56;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait.c</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid, wpid;</span><br><span class="line">	int status;</span><br><span class="line"></span><br><span class="line">	pid &#x3D; fork();</span><br><span class="line"></span><br><span class="line">	if(pid &#x3D;&#x3D; -1)&#123;</span><br><span class="line">		perror(&quot;fork error&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125; else if(pid &#x3D;&#x3D; 0)&#123;		</span><br><span class="line">		printf(&quot;I&#39;m process child, pid &#x3D; %d\n&quot;, getpid());</span><br><span class="line">#if 0</span><br><span class="line">		execl(&quot;.&#x2F;abnor&quot;, &quot;abnor&quot;, NULL);  &#x2F;&#x2F; 子进程异常终止</span><br><span class="line">		perror(&quot;execl error&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">#endif</span><br><span class="line">		sleep(1);				</span><br><span class="line">		exit(10);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		wpid &#x3D; wait(&amp;status);	    &#x2F;&#x2F; 传出参数</span><br><span class="line"></span><br><span class="line">		if(WIFEXITED(status))&#123;	  &#x2F;&#x2F; 正常退出</span><br><span class="line">			printf(&quot;I&#39;m parent, The child process &quot;</span><br><span class="line">					&quot;%d exit normally\n&quot;, wpid);</span><br><span class="line">			printf(&quot;return value:%d\n&quot;, WEXITSTATUS(status));</span><br><span class="line"></span><br><span class="line">		&#125; else if (WIFSIGNALED(status)) &#123;	&#x2F;&#x2F; 异常退出</span><br><span class="line">			printf(&quot;The child process exit abnormally, &quot;</span><br><span class="line">					&quot;killed by signal %d\n&quot;, WTERMSIG(status));</span><br><span class="line">										&#x2F;&#x2F; 获取信号编号</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			printf(&quot;other...\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父进程调用waitpid可指定pid进程清理,可以不阻塞</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pid_t waitpid(pid_t pid, int *status, in options);	&#x2F;&#x2F; 一次只能回收一个子进程</span><br><span class="line">特殊参数和返回情况：</span><br><span class="line">&#x2F;&#x2F; 参数pid： &gt;0:回收指定ID的子进程	&#x3D;0:回收当前进程组任意子进程</span><br><span class="line">&#x2F;&#x2F; -1:回收任意子进程(相当于wait)  &lt;-1:等待其组ID等于pid的绝对值的任一进程</span><br><span class="line">&#x2F;&#x2F; status:子进程的退出状态，与wait相同</span><br><span class="line">&#x2F;&#x2F; options:设置为WNOHANG是函数非阻塞；设置为0时函数阻塞</span><br><span class="line">&#x2F;&#x2F; 返回值：&gt;0 返回回收子进程ID；-1 回收失败(没有可回收的子进程)；&#x3D;0 只有在options为WNOHANG有效，表示子进程正在运行</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid &#x3D; fork();</span><br><span class="line"></span><br><span class="line">    if (pid &lt; 0) &#123;</span><br><span class="line">        perror(&quot;fork failed&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (pid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        int i;</span><br><span class="line">        for (i &#x3D; 3; i &gt; 0; i--) &#123;</span><br><span class="line">            printf(&quot;This is the child\n&quot;);</span><br><span class="line">            sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line">        exit(34);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int stat_val;</span><br><span class="line">        waitpid(pid, &amp;stat_val, 0);     &#x2F;&#x2F; 阻塞</span><br><span class="line"></span><br><span class="line">        if (WIFEXITED(stat_val))</span><br><span class="line">            printf(&quot;Child exited with code %d\n&quot;, WEXITSTATUS(stat_val));</span><br><span class="line">        else if (WIFSIGNALED(stat_val))</span><br><span class="line">            printf(&quot;Child terminated abnormally, signal %d\n&quot;, WTERMSIG(stat_val));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int n &#x3D; 5, i;				</span><br><span class="line">	pid_t p, q;</span><br><span class="line"></span><br><span class="line">	if(argc &#x3D;&#x3D; 2)&#123;	</span><br><span class="line">		n &#x3D; atoi(argv[1]);</span><br><span class="line">	&#125;</span><br><span class="line">    q &#x3D; getpid();</span><br><span class="line"></span><br><span class="line">	for(i&#x3D;0; i&lt;n; i++)	 &#123;</span><br><span class="line">        p &#x3D; fork();</span><br><span class="line">		if(p &#x3D;&#x3D; 0)</span><br><span class="line">			break;			</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	if(n &#x3D;&#x3D; i)&#123;  		&#x2F;&#x2F; 父进程</span><br><span class="line">		sleep(n);</span><br><span class="line">		printf(&quot;I am parent, pid &#x3D; %d\n&quot;, getpid());</span><br><span class="line">        for (i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            p &#x3D; waitpid(0, NULL, WNOHANG);	&#x2F;&#x2F; fork出的进程属于一个进程组</span><br><span class="line">            printf(&quot;wait  pid &#x3D; %d\n&quot;, p);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		sleep(i);</span><br><span class="line">		printf(&quot;I&#39;m %dth child, pid &#x3D; %d\n&quot;, i+1, getpid());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重定向dup和dup2"><a href="#重定向dup和dup2" class="headerlink" title="重定向dup和dup2"></a>重定向dup和dup2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int dup(int oldfd); 	&#x2F;&#x2F; 成功：返回一个新文件描述符；失败：-1设置errno为相应值</span><br><span class="line">int dup2(int oldfd, int newfd); 	&#x2F;&#x2F; 将oldfd复制给newfd</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int fd, save_fd;</span><br><span class="line">	char msg[] &#x3D; &quot;It&#39;s just a test!\n&quot;;</span><br><span class="line"></span><br><span class="line">	fd &#x3D; open(&quot;test.txt&quot;, O_RDWR|O_CREAT|O_TRUNC, 0644);	&#x2F;&#x2F; fd&#x3D;3</span><br><span class="line">	if(fd &lt; 0)&#123;</span><br><span class="line">		perror(&quot;open error&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	save_fd &#x3D; dup(STDOUT_FILENO);			&#x2F;&#x2F; save_fd 指向 STDOUT</span><br><span class="line">	printf(&quot;save_fd &#x3D; %d\n&quot;, save_fd);</span><br><span class="line">	write(save_fd, msg, strlen(msg));		&#x2F;&#x2F; 打印到标准输出</span><br><span class="line">#if 1</span><br><span class="line">	dup2(STDOUT_FILENO, fd);	&#x2F;&#x2F; 把STDOUT_FILENO复制给fd</span><br><span class="line">	write(fd, msg, strlen(msg));</span><br><span class="line">#else</span><br><span class="line">	dup2(fd, STDOUT_FILENO);	&#x2F;&#x2F; 把fd复制给STDOUT_FILENO</span><br><span class="line">	&#x2F;&#x2F;puts(msg);				&#x2F;&#x2F; 向标准输出设备输出字符串换行	&#x2F;&#x2F; 重定向标准输出到fd，输出到test.txt文件							</span><br><span class="line">	write(fd, msg, strlen(msg));	</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	close(fd);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/34-linux-进程/3.重定向.png" alt="&quot;3.重定向&quot;"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重定向就是对文件设置新的文件描述符。旧文件描述符关闭，新文件描述符还是可以访问。</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int fd;</span><br><span class="line">	char *str &#x3D; &quot;hello dup2\n&quot;;</span><br><span class="line"></span><br><span class="line">	fd &#x3D; open(&quot;test.txt&quot;, O_WRONLY|O_TRUNC|O_CREAT, 0644);</span><br><span class="line">	if(fd &lt; 0)&#123;</span><br><span class="line">		perror(&quot;open test1 error&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	dup2(fd, STDOUT_FILENO);</span><br><span class="line"></span><br><span class="line">	close(fd);	&#x2F;&#x2F; 关闭fd依然可以访问对应文件</span><br><span class="line"></span><br><span class="line">	int n &#x3D; write(fd, str, strlen(str));		</span><br><span class="line">	printf(&quot;--------|%d\n&quot;, n);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信(IPC)"></a>进程间通信(IPC)</h1><p>Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。进程和进程之间数据相互独立，要交换数据必须通过内核。在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信(IPC，InterProcess Communication)。</p>
<h2 id="文件方式"><a href="#文件方式" class="headerlink" title="文件方式"></a>文件方式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line"></span><br><span class="line">void sys_err(const char *str)</span><br><span class="line">&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int fd &#x3D; open(&quot;testFile.txt&quot;, O_RDWR | O_TRUNC | O_CREAT, 0664);</span><br><span class="line">    if (fd &#x3D;&#x3D; -1)</span><br><span class="line">        sys_err(&quot;open err&quot;);</span><br><span class="line">    int ret;</span><br><span class="line">    char buf[1024];</span><br><span class="line"></span><br><span class="line">    pid_t pid &#x3D; fork();</span><br><span class="line">    if (pid &#x3D;&#x3D; -1)</span><br><span class="line">        sys_err(&quot;fork err&quot;);</span><br><span class="line"></span><br><span class="line">    if (pid &gt; 0) &#123;</span><br><span class="line">        write(fd, &quot;file IPC\n&quot;, strlen(&quot;file IPC\n&quot;));</span><br><span class="line">        printf(&quot;----write finish ----\n&quot;);</span><br><span class="line">        wait(NULL);</span><br><span class="line">    &#125; else if (pid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        lseek(fd, 0, SEEK_SET);</span><br><span class="line">        ret &#x3D; read(fd, buf, sizeof(buf));</span><br><span class="line">        write(STDOUT_FILENO, buf, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="管道方式-进程之间有血缘关系"><a href="#管道方式-进程之间有血缘关系" class="headerlink" title="管道方式(进程之间有血缘关系)"></a>管道方式(进程之间有血缘关系)</h2><p>管道本质上是一个内存缓冲区，可以以文件的方式对齐进行操作。在linux中可以使用<code>ulimit -a</code>命令查看当前系统中创建管道文件所对应的缓冲区的大小。也可以使用<br><code>fpathconf</code>函数来查看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int pipe(int pipefd[2]);		&#x2F;&#x2F; 成功：0；失败：-1，设置errno</span><br><span class="line">&#x2F;&#x2F; pipefd是传出参数，返回r&#x2F;w两个文件描述符。规定：fd[0]对应读端，fd[1]对应写端。如果进程中没有打开其他文件，则fd[0]&#x3D;3，fd[1]&#x3D;4。</span><br></pre></td></tr></table></figure>
<p>管道创建成功后，创建该管道的进程同时掌握着管道的读端和写端。此时，父进程可以fork出子进程，这样子进程也会掌握管道的读端和写端。由图2可知，如果两个进程同时<br>对管道进行读写，必然造成冲突。因此，管道的使用中一方需要关闭读端，而另一方需要关闭写端。即一个管道只能实现半双工通信，如果要实现全双工通信，必须采用两个管道。</p>
<p><img src="/images/34-linux-进程/2.管道.png" alt="&quot;2.管道&quot;"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"><b>图2</b></div>
    <br>
</center>

<p>父子进程通信过程：</p>
<ol>
<li>父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。</li>
<li>父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。</li>
<li>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</li>
</ol>
<p>管道的读写行为：</p>
<ol>
<li>如果所有指向管道写端的文件描述符都关闭了（管道写端引用计数为0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。</li>
<li>如果有指向管道写端的文件描述符没关闭（管道写端引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。</li>
<li>如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端写数据，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然也可以对SIGPIPE信号实施捕捉，不终止进程。</li>
<li>如果有指向管道读端的文件描述符没关闭（管道读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。</li>
</ol>
<ul>
<li>读管道：    </li>
</ul>
<ol>
<li>管道中有数据，read返回实际读到的字节数。</li>
<li>管道中无数据：管道写端被全部关闭，read返回0；写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)</li>
</ol>
<ul>
<li>写管道：    </li>
</ul>
<ol>
<li>管道读端全部被关闭，进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止)，管道破裂。</li>
<li>管道读端没有全部关闭：管道已满，write阻塞；管道未满，write将数据写入，并返回实际写入的字节数。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 父子进程之间通信</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid;</span><br><span class="line">	int fd[2];</span><br><span class="line"></span><br><span class="line">	pipe(fd);</span><br><span class="line">	pid &#x3D; fork();</span><br><span class="line"></span><br><span class="line">	if (pid &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F;child</span><br><span class="line">		close(fd[1]);	                &#x2F;&#x2F;子进程从管道中读数据，关闭写端</span><br><span class="line">		dup2(fd[0], STDIN_FILENO);		&#x2F;&#x2F;让wc从管道中读取数据</span><br><span class="line">		execlp(&quot;wc&quot;, &quot;wc&quot;, &quot;-l&quot;, NULL);	&#x2F;&#x2F;wc命令默认从标准读入取数据</span><br><span class="line"></span><br><span class="line">	&#125; else &#123;</span><br><span class="line"></span><br><span class="line">		close(fd[0]);	&#x2F;&#x2F;父进程向管道中写数据，关闭读端</span><br><span class="line">		dup2(fd[1], STDOUT_FILENO);		&#x2F;&#x2F;将ls的结果写入管道中</span><br><span class="line">		execlp(&quot;ls&quot;, &quot;ls&quot;, NULL);		&#x2F;&#x2F;ls输出结果默认对应屏幕</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 兄弟进程之间通信</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid;</span><br><span class="line">	int fd[2], i;</span><br><span class="line">	</span><br><span class="line">	pipe(fd);</span><br><span class="line"></span><br><span class="line">	for (i &#x3D; 0; i &lt; 2; i++) &#123;</span><br><span class="line">		if((pid &#x3D; fork()) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">			break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	if (i &#x3D;&#x3D; 0) &#123;			&#x2F;&#x2F; 兄</span><br><span class="line">		close(fd[0]);				&#x2F;&#x2F; 写,关闭读端</span><br><span class="line">		dup2(fd[1], STDOUT_FILENO);		</span><br><span class="line">		execlp(&quot;ls&quot;, &quot;ls&quot;, NULL);	</span><br><span class="line">	&#125; else if (i &#x3D;&#x3D; 1) &#123;	&#x2F;&#x2F; 弟</span><br><span class="line">		close(fd[1]);				&#x2F;&#x2F; 读，关闭写端</span><br><span class="line">		dup2(fd[0], STDIN_FILENO);		</span><br><span class="line">		execlp(&quot;wc&quot;, &quot;wc&quot;, &quot;-l&quot;, NULL);		</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">        close(fd[0]);</span><br><span class="line">        close(fd[1]);</span><br><span class="line">		for(i &#x3D; 0; i &lt; 2; i++)		&#x2F;&#x2F;两个儿子wait两次</span><br><span class="line">			wait(NULL);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>管道默认是阻塞的，如果需要设置管道非阻塞。可以使用fcntl函数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int flags &#x3D; fcntl(fd[0], F_GETFL);</span><br><span class="line">flag |&#x3D; O_NONBLOCK;</span><br><span class="line">fcntl(fd[0], F_SETFL, flags);</span><br></pre></td></tr></table></figure></p>
<h2 id="fifo方式-进程之间无血缘关系"><a href="#fifo方式-进程之间无血缘关系" class="headerlink" title="fifo方式(进程之间无血缘关系)"></a>fifo方式(进程之间无血缘关系)</h2><p>FIFO被称为有名管道。FIFO是Linux基础文件类型中的一种。但FIFO文件在磁盘上大小永远为0，仅仅用来标识内核中一条管道(缓冲区)。各进程可以打开这个文件进行read/write，实际上是在读写内核通道，这样就实现了进程间通信。</p>
<p>创建方式：</p>
<ol>
<li>命令：mkfifo 管道名    ls命令查看：prw-r—r— 1    p表示管道</li>
<li>库函数：int mkfifo(const char *pathname,  mode_t mode);      // 成功：0； 失败：-1<br>一旦使用mkfifo创建了一个FIFO，就可以使用open打开它，常见的文件I/O函数都可用于fifo。如：close、read、write、unlink等。</li>
</ol>
<ul>
<li>fifo_write.c</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void sys_err(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    exit(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int fd, i;</span><br><span class="line">    char buf[4096];</span><br><span class="line"></span><br><span class="line">    if (argc &lt; 2) &#123;</span><br><span class="line">        printf(&quot;Enter like this: .&#x2F;a.out fifoname\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int ret &#x3D; access(argv[1], F_OK);	&#x2F;&#x2F; 判断文件是否存在</span><br><span class="line">    if (ret !&#x3D; 0) &#123;</span><br><span class="line">        mkfifo(argv[1], 0664);			&#x2F;&#x2F; 如果管道文件不存在，用mkfifo创建管道</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fd &#x3D; open(argv[1], O_WRONLY);		</span><br><span class="line">    if (fd &lt; 0) </span><br><span class="line">        sys_err(&quot;open&quot;);</span><br><span class="line"></span><br><span class="line">    i &#x3D; 0;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        sprintf(buf, &quot;hello world %d\n&quot;, i++);</span><br><span class="line">        write(fd, buf, strlen(buf));</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>fifo_read.c</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void sys_err(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int fd, len;</span><br><span class="line">    char buf[4096];</span><br><span class="line"></span><br><span class="line">    if (argc &lt; 2) &#123;</span><br><span class="line">        printf(&quot;.&#x2F;a.out fifoname\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    fd &#x3D; open(argv[1], O_RDONLY);</span><br><span class="line">    if (fd &lt; 0) </span><br><span class="line">        sys_err(&quot;open&quot;);</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        len &#x3D;read(fd, buf, sizeof(buf));	&#x2F;&#x2F; 管道默认阻塞</span><br><span class="line">        write(STDOUT_FILENO, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>内存映射对于有血缘关系和无血缘关系的进程间都可以通信。内存映射使一个磁盘文件与存储空间中的一个缓冲区相映射。当从缓冲区中取数据，就相当于读文件中的相应字节；将数据存入缓冲区，则相应的字节就自动写入文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void *mmap(void *adrr, size_t length, int prot, int flags, int fd, off_t offset); </span><br><span class="line">参数：	</span><br><span class="line">	addr: 建立映射区的首地址，由Linux内核指定。使用时，直接传递NULL</span><br><span class="line">	length: 欲创建映射区的大小(默认分配4k的整数倍,不能为0)</span><br><span class="line">	prot: 映射区权限PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE </span><br><span class="line">	flags: 标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区)</span><br><span class="line">		MAP_SHARED:  映射区所做的操作同步到磁盘。注意：mmap的映射区权限小于等于open打开时文件的权限</span><br><span class="line">		MAP_PRIVATE: 映射区所做的操作不会同步到磁盘。</span><br><span class="line">	fd: 用来建立映射区的文件描述符(创建映射区后可以关闭文件描述符)</span><br><span class="line">	offset: 映射文件的偏移(4k的整数倍)，否则返回无效参数</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">	成功：返回创建的映射区首地址(不能越界操作)；失败：MAP_FAILED宏</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用munmap释放映射区空间</span><br><span class="line">int munmap(void *addr, size_t length);	</span><br><span class="line"></span><br><span class="line">返回值：成功：0； 失败：-1</span><br></pre></td></tr></table></figure>
<p>如果mmap对应的磁盘文件不存在，使用open函数的O_CREAT创建一个新文件时必须指定文件大小。应该使用lseek或truncate做文件拓展。</p>
<ul>
<li>lseek函数<br>lseek函数可以用来修改文件偏移量。每个打开的文件都记录这当前读写位置，打开文件时读写位置为0，表示文件开头，通常读写多少个字节就会将读写位置往后移多少个字节。<br>如果以O_APPEND方式打开，每次写操作都会在文件末尾追加数据，然后将读写位置移到新的文件末尾。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">off_t lseek(int fd, off_t offset, int whence); </span><br><span class="line">参数：</span><br><span class="line">offset 的含义取决于参数 whence：</span><br><span class="line">    1. 如果 whence 是 SEEK_SET，文件偏移量将被设置为 offset。</span><br><span class="line">    2. 如果 whence 是 SEEK_CUR，文件偏移量将被设置为当前文件偏移量 + offset，offset 可正可负</span><br><span class="line">    3. 如果 whence 是 SEEK_END，文件偏移量将被设置为文件长度 + offset，offset 可正可负</span><br><span class="line"></span><br><span class="line">在Unix文件操作中，文件偏移量可以大于当前文件的长度，在这种情况下对文件的下一次 写 将延长该文件，并在文件中构成一个空洞。位于文件中但没有写过的</span><br><span class="line">字节都设为0。</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">	失败返回-1；成功：返回值是较文件起始位置向后的偏移量。</span><br><span class="line">lseek(fd, 0, SEEK_END);	&#x2F;&#x2F; 获取文件大小	</span><br><span class="line">&#x2F;&#x2F; lseek允许超过文件结尾设置偏移量，文件会因此被拓展。</span><br></pre></td></tr></table></figure>
<ul>
<li>mmap.c</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;mman.h&gt;</span><br><span class="line"></span><br><span class="line">void sys_err(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char *mem;</span><br><span class="line">    int len &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    int fd &#x3D; open(&quot;mmap.txt&quot;, O_RDWR|O_CREAT|O_TRUNC, 0644);	&#x2F;&#x2F; 创建文件，或者将文件指针指向SEEK_SET</span><br><span class="line">    if (fd &lt; 0)</span><br><span class="line">        sys_err(&quot;open error&quot;);</span><br><span class="line"></span><br><span class="line">    len &#x3D; lseek(fd, 3, SEEK_SET);   &#x2F;&#x2F; 将文件指针指向SEEK_SET + 3的位置</span><br><span class="line">    write(fd, &quot;\0&quot;, 1);             &#x2F;&#x2F; 空洞文件文件拓展，必须进行一次写操作</span><br><span class="line">    len &#x3D; lseek(fd, 0, SEEK_END);	&#x2F;&#x2F; SEEK_END指向文件最后一个字符</span><br><span class="line">    </span><br><span class="line">    printf(&quot;The length of file &#x3D; %d\n&quot;, len);	&#x2F;&#x2F; len &#x3D; 4</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; mem &#x3D; mmap(NULL, len, PROT_WRITE, MAP_PRIVATE, fd, 0);	&#x2F;&#x2F; MAP_PRIVATE:对映射空间写入不影响磁盘文件</span><br><span class="line">	mem &#x3D; mmap(NULL, len, PROT_WRITE, MAP_SHARED, fd, 0);		&#x2F;&#x2F; 映射文件长度为4，实际系统分配4K</span><br><span class="line">    if (mem &#x3D;&#x3D; MAP_FAILED)</span><br><span class="line">        sys_err(&quot;mmap err: &quot;);</span><br><span class="line">    close(fd);	&#x2F;&#x2F; 关闭文件描述符对将缓冲区中内容写入文件无影响</span><br><span class="line"></span><br><span class="line">    strcpy(mem, &quot;hello&quot;);</span><br><span class="line">    printf(&quot;%s\n&quot;, mem);	&#x2F;&#x2F; hello MAP_SHARED写入的字符不超过文件大小,文件大小为4,故写入4字节</span><br><span class="line"></span><br><span class="line">    if (munmap(mem,  len) &lt; 0)</span><br><span class="line">        sys_err(&quot;munmap&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mmap父子间通信"><a href="#mmap父子间通信" class="headerlink" title="mmap父子间通信"></a>mmap父子间通信</h3><p><img src="/images/34-linux-进程/4.虚拟文件系统.png" alt="&quot;4.虚拟文件系统&quot;"></p>
<p>Linux允许多个dentry共享一个inode，即共享盘块。mv命令只修改了dentry(dentry包括文件名)，不修改inode。<br>Linux下删除文件是将与inode对应的硬连接数减为0，这样在文件系统中就没有对应的dentry了。磁盘上的文件实际是没有擦除的。如果重新建立了dentry，文件<br>还是可以读取的。类似于windows下格式化磁盘只是把索引去除了，但是磁盘内容还是存在的。要想真的删除磁盘内容，就需要对要删除的空间进行覆盖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 截断文件长度成指定长度，常用来拓展文件大小。</span><br><span class="line">int truncate(const char *path, off_t length);	成功：0；失败：-1设置errno为相应值</span><br><span class="line">int ftruncate(int fd, off_t length);	</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; link函数创建硬连接。硬连接全部删除时才会删除文件，软连接如果文件删除，软连接指向的文件错误。</span><br><span class="line">int link(const char *oldpath,  const char *newpath);	成功：0；失败：-1设置errno为相应值</span><br><span class="line">int unlink(const char *pathname);	成功：0；失败：-1设置errno为相应值</span><br><span class="line">int symlink(const char *oldpath, const char *newpath);	成功：0；失败：-1设置errno为相应值</span><br></pre></td></tr></table></figure>
<p>在进程中使用ulink删除文件只是让文件具备了被释放的条件。只有所有打开该文件的进程关闭该文件，系统才会择机释放该文件。<br>当进程结束运行时，所有该进程打开的文件都会被关闭，申请的内存空间会被释放。系统这一特性成为隐式回收。</p>
<ul>
<li>创建文件进行父子进程通信</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;mman.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line"></span><br><span class="line">int var &#x3D; 100;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int *p;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    int fd;</span><br><span class="line">    fd &#x3D; open(&quot;temp&quot;, O_RDWR|O_CREAT|O_TRUNC, 0644);</span><br><span class="line">    if(fd &lt; 0)&#123;</span><br><span class="line">        perror(&quot;open error&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    unlink(&quot;temp&quot;);				&#x2F;&#x2F; 删除临时文件目录项,使之具备被释放条件</span><br><span class="line">    ftruncate(fd, 4);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;p &#x3D; (int *)mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);		&#x2F;&#x2F; 父子进程共享映射区</span><br><span class="line">    p &#x3D; (int *)mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);	&#x2F;&#x2F; 父子进程各自独占映射区</span><br><span class="line">    if(p &#x3D;&#x3D; MAP_FAILED)&#123;		</span><br><span class="line">        perror(&quot;mmap error&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);					&#x2F;&#x2F; 映射区建立完毕,即可关闭文件</span><br><span class="line"></span><br><span class="line">    pid &#x3D; fork();				&#x2F;&#x2F; 创建子进程</span><br><span class="line">    if(pid &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        *p &#x3D; 2000;</span><br><span class="line">        var &#x3D; 1000;</span><br><span class="line">        printf(&quot;child, *p &#x3D; %d, var &#x3D; %d\n&quot;, *p, var);	&#x2F;&#x2F; 2000 1000</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        printf(&quot;parent, *p &#x3D; %d, var &#x3D; %d\n&quot;, *p, var);	&#x2F;&#x2F; 2000 100</span><br><span class="line">        wait(NULL);</span><br><span class="line"></span><br><span class="line">        int ret &#x3D; munmap(p, 4);				&#x2F;&#x2F; 释放映射区</span><br><span class="line">        if (ret &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            perror(&quot;munmap error&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不创建文件进行父子进程通信(匿名映射)<br>每次创建映射区要依赖一个文件来实现太麻烦，可以直接使用匿名映射(宏：MAP_ANONYMOUS和MAP_ANON)的方式替代。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;mman.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int *p;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    p &#x3D; mmap(NULL, 400, PROT_READ|PROT_WRITE, MAP_SHARED | MAP_ANON, -1, 0);</span><br><span class="line">    if(p &#x3D;&#x3D; MAP_FAILED)&#123;</span><br><span class="line">        perror(&quot;mmap error&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid &#x3D; fork();               &#x2F;&#x2F;创建子进程</span><br><span class="line">    if(pid &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        *p &#x3D; 2000;</span><br><span class="line">        printf(&quot;child, *p &#x3D; %d\n&quot;, *p);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        printf(&quot;parent, *p &#x3D; %d\n&quot;, *p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    munmap(p, 400);             &#x2F;&#x2F;释放映射区</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mmap无血缘关系通信"><a href="#mmap无血缘关系通信" class="headerlink" title="mmap无血缘关系通信"></a>mmap无血缘关系通信</h3><p>无血缘关系的进程之间通信，必须要建立磁盘文件才能创建映射区。</p>
<ul>
<li>读进程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;mman.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">struct Student &#123;</span><br><span class="line">    int id;</span><br><span class="line">    char name[20];</span><br><span class="line">    char sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void sys_err(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    exit(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    struct Student stu;</span><br><span class="line">    struct Student *maddr;</span><br><span class="line"></span><br><span class="line">    if (argc &lt; 2) &#123;</span><br><span class="line">        printf(&quot;.&#x2F;a.out file_shared\n&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd &#x3D; open(argv[1], O_RDONLY);</span><br><span class="line">    if (fd &#x3D;&#x3D; -1)</span><br><span class="line">        sys_err(&quot;open error&quot;);</span><br><span class="line"></span><br><span class="line">    maddr &#x3D; mmap(NULL, sizeof(stu), PROT_READ, MAP_SHARED, fd, 0);</span><br><span class="line">    if (maddr &#x3D;&#x3D; MAP_FAILED)</span><br><span class="line">        sys_err(&quot;mmap error&quot;);</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        printf(&quot;id&#x3D;%d\tname&#x3D;%s\t%c\n&quot;, maddr-&gt;id, maddr-&gt;name, maddr-&gt;sex);</span><br><span class="line">        usleep(10000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    munmap(maddr, sizeof(stu));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>写进程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;mman.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">struct Student &#123;</span><br><span class="line">    int id;</span><br><span class="line">    char name[20];</span><br><span class="line">    char sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void sys_err(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    struct Student stu &#x3D; &#123;10, &quot;xiaoming&quot;, &#39;m&#39;&#125;;</span><br><span class="line">    char *maddr;</span><br><span class="line"></span><br><span class="line">    if (argc &lt; 2) &#123;</span><br><span class="line">        printf(&quot;.&#x2F;a.out file_shared\n&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd &#x3D; open(argv[1], O_RDWR | O_CREAT, 0664);</span><br><span class="line">    ftruncate(fd, sizeof(stu));</span><br><span class="line"></span><br><span class="line">    maddr &#x3D; mmap(NULL, sizeof(stu), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</span><br><span class="line">    if (maddr &#x3D;&#x3D; MAP_FAILED)</span><br><span class="line">        sys_err(&quot;mmap&quot;);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        memcpy(maddr, &amp;stu, sizeof(stu));</span><br><span class="line">        stu.id++;</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    munmap(maddr, sizeof(stu));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>进程A可以向进程B发送信号。进程B收到信号之前执行自己的代码，收到信号后，不管程序执行到什么位置，都要暂停运行去处理信号，处理完毕再继续执行。每个进程收到的所有信号都由内核负责发送。linux中可以使用kill -l命令查看当前系统中可使用的信号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1</span><br><span class="line">11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM</span><br><span class="line">16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP</span><br><span class="line">21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR</span><br><span class="line">31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1	64) SIGRTMAX</span><br></pre></td></tr></table></figure>
<p>可以通过类似<code>man 7 signal</code>的方式查看信号对应的信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Signal     Value     Action   Comment</span><br><span class="line">──────────────────────────────────────────────────────────────────────</span><br><span class="line">SIGHUP        1       Term    Hangup detected on controlling terminal   &#x2F;&#x2F; 当用户退出shell时，由该shell启动的所有进程将收到这个信号</span><br><span class="line">                                or death of controlling process         &#x2F;&#x2F; 默认动作终止进程</span><br><span class="line">SIGINT        2       Term    Interrupt from keyboard                   &#x2F;&#x2F; Ctrl+C组合键发出该信号，终止进程</span><br><span class="line">SIGQUIT       3       Core    Quit from keyboard                        &#x2F;&#x2F; Ctrl+\组合键发出该信号，终止进程</span><br><span class="line">SIGILL        4       Core    Illegal Instruction</span><br><span class="line">SIGABRT       6       Core    Abort signal from abort(3)                &#x2F;&#x2F; 调用abort函数发出该信号，终止进程并产生core文件</span><br><span class="line">SIGFPE        8       Core    Floating-point exception                  &#x2F;&#x2F; 非法算术操作</span><br><span class="line">SIGKILL       9       Term    Kill signal                               &#x2F;&#x2F; 无条件终止进程。信号不能被捕捉、阻塞和忽略</span><br><span class="line">SIGSEGV      11       Core    Invalid memory reference                  &#x2F;&#x2F; 无效内存访问，终止进程并生成core文件</span><br><span class="line">SIGPIPE      13       Term    Broken pipe: write to pipe with no        &#x2F;&#x2F; 向一个没有读端的管道写数据，管道破裂</span><br><span class="line">                                readers; see pipe(7)</span><br><span class="line">SIGALRM      14       Term    Timer signal from alarm(2)                &#x2F;&#x2F; 定时器超时</span><br><span class="line">SIGTERM      15       Term    Termination signal</span><br><span class="line">SIGUSR1   30,10,16    Term    User-defined signal 1</span><br><span class="line">SIGUSR2   31,12,17    Term    User-defined signal 2</span><br><span class="line">SIGCHLD   20,17,18    Ign     Child stopped or terminated               &#x2F;&#x2F; 子进程结束，父进程会收到这个信号，默认忽略。</span><br><span class="line">SIGCONT   19,18,25    Cont    Continue if stopped                       &#x2F;&#x2F; 进程暂停使用这个信号通知进程继续执行</span><br><span class="line">SIGSTOP   17,19,23    Stop    Stop process                              &#x2F;&#x2F; 停止进程运行。信号不能被捕捉、阻塞和忽略</span><br><span class="line">SIGTSTP   18,20,24    Stop    Stop typed at terminal                    &#x2F;&#x2F; Ctrl+Z暂停进程</span><br><span class="line">SIGTTIN   21,21,26    Stop    Terminal input for background process</span><br><span class="line">SIGTTOU   22,22,27    Stop    Terminal output for background process</span><br><span class="line"></span><br><span class="line">The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.</span><br></pre></td></tr></table></figure>
<p>SIGKILL和SIGSTOP信号不能被捕捉、阻塞和忽略。<br>默认动作包括：    Term:终止进程   Ign:忽略信号 (默认即时对该种信号忽略操作)<br>        Core:终止进程，生成Core文件。(查验进程死亡原因， 用于gdb调试)<br>        Stop：停止（暂停）进程  Cont：继续运行进程</p>
<p>kill命令产生信号：kill 信号宏名/编号 进程ID</p>
<ul>
<li>kill系统函数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int kill(pid_t pid, int sig);</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    pid &gt; 0:  发送信号给指定的进程。</span><br><span class="line">	pid &#x3D; 0:  发送信号给与调用kill函数进程属于同一进程组的所有进程。</span><br><span class="line">	pid &lt; -1: 取|pid|发给对应进程组。</span><br><span class="line">	pid &#x3D; -1：发送给进程有权限发送的系统中所有进程。</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    成功：0；失败：-1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">#define N 5</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 任一子进程发送信号杀死父进程</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;				    &#x2F;&#x2F; 默认创建5个子进程</span><br><span class="line"></span><br><span class="line">	for(i &#x3D; 0; i &lt; N; i++)	</span><br><span class="line">		if(fork() &#x3D;&#x3D; 0)</span><br><span class="line">			break;			</span><br><span class="line"></span><br><span class="line">    if (i &#x3D;&#x3D; 3) &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        printf(&quot;-----------child ---pid &#x3D; %d, ppid &#x3D; %d\n&quot;, getpid(), getppid());</span><br><span class="line">        kill(getppid(), SIGKILL);</span><br><span class="line"></span><br><span class="line">    &#125; else if (i &#x3D;&#x3D; N) &#123;</span><br><span class="line">        printf(&quot;I am parent, pid &#x3D; %d\n&quot;, getpid());</span><br><span class="line">        while(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>abort系统函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        printf(&quot;pid &#x3D; %d\n&quot;, getpid());</span><br><span class="line">        sleep(1);</span><br><span class="line">        abort();    &#x2F;&#x2F; 给当前进程发送指定信号SIGABRT(自己发给自己)</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>raise 函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int raise(int sig); 成功：0，失败非0值</span><br></pre></td></tr></table></figure>
</li>
<li><p>软件条件产生信号</p>
</li>
</ul>
<p>alarm函数设置定时器，在指定seconds后，内核会给当前进程发送SIGALARM信号。进程收到该信号，默认动作终止。每个进程都有且只有唯一的一个定时器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned int alarm(unsigned int seconds); </span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    0或剩余的秒数。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定时1s看能打印多少个数</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	alarm(1);</span><br><span class="line"></span><br><span class="line">	for(i &#x3D; 0; ; i++)</span><br><span class="line">		printf(&quot;%d\n&quot;, i);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);	成功：0；失败：-1，设置errno</span><br><span class="line">参数：which：指定定时方式</span><br><span class="line">    自然定时：ITIMER_REAL → 14）SIGLARM                        计算自然时间</span><br><span class="line">    虚拟空间计时(用户空间)：ITIMER_VIRTUAL → 26）SIGVTALRM      只计算进程占用cpu的时间</span><br><span class="line">    运行时计时(用户+内核)：ITIMER_PROF → 27）SIGPROF            计算占用cpu及执行系统调用的时间</span><br></pre></td></tr></table></figure>
<h3 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h3><p>在进程控制块PCB中，有两个非常重要的信号集：阻塞信号集和未决信号集。执行信号的处理动作成为信号递达，信号从产生到递达之间的状态，成为信号未决。<br>如果不设置阻塞信号集，信号只会短暂的在未决信号集中从0-&gt;1-&gt;0，0-&gt;1表示信号未决，1-&gt;0表示信号递达。</p>
<p><img src="/images/34-linux-进程/5.信号集.png" alt="&quot;5.信号集&quot;"></p>
<p>block集（阻塞集、屏蔽集）：一个进程所要屏蔽的信号，在对应要屏蔽的信号位置1<br>pending集（未决信号集）：如果某个信号在进程的阻塞集中，则也在未决集中对应位置1，表示该信号不能被递达，不会被处理<br>handler（信号处理函数集）：表示每个信号所对应的信号处理函数，当信号不在未决集中时，将被调用</p>
<p>用户可以修改阻塞集，不能修改未决信号集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sigemptyset(sigset_t *set);			    &#x2F;&#x2F; 将某个信号集清0 成功：0；失败：-1，设置errno</span><br><span class="line">int sigfillset(sigset_t *set);				&#x2F;&#x2F; 将某个信号集置1 成功：0；失败：-1，设置errno</span><br><span class="line">int sigaddset(sigset_t *set, int signum);	&#x2F;&#x2F; 将阻塞信号集中的某个信号置1   成功：0；失败：-1，设置errno</span><br><span class="line">int sigdelset(sigset_t *set, int signum);	&#x2F;&#x2F; 将阻塞信号集中某个信号置0   成功：0；失败：-1，设置errno</span><br><span class="line">int sigismember(const sigset_t *set, int signum);   &#x2F;&#x2F; 判断某个信号是否在信号集中：在：1；不在：0；出错：-1，设置errno</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 屏蔽信号或解除屏蔽</span><br><span class="line">int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);	成功：0；失败：-1，设置errno</span><br><span class="line">参数：</span><br><span class="line">    how参数取值：假设当前的信号屏蔽字为mask</span><br><span class="line">        1.SIG_BLOCK: 当how设置为此值，set表示需要屏蔽的信号。相当于 mask &#x3D; mask|set</span><br><span class="line">        2.SIG_UNBLOCK: 当how设置为此，set表示需要解除屏蔽的信号。相当于 mask &#x3D; mask &amp; ~set</span><br><span class="line">        3.SIG_SETMASK: 当how设置为此，set表示用于替代原始屏蔽及的新屏蔽集。</span><br><span class="line">	set：传入参数，是一个自定义信号集合。由参数how来指示如何修改当前信号屏蔽字。</span><br><span class="line">	oldset：传出参数，保存旧的信号屏蔽字。</span><br><span class="line">		</span><br><span class="line">&#x2F;&#x2F; 读取当前进程的未决信号集</span><br><span class="line">int sigpending(sigset_t *set);	set传出参数。   返回值：成功：0；失败：-1，设置errno</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">void sys_err(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_set(sigset_t* set)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i&#x3D;1; i&lt;32; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(sigismember(set, i))</span><br><span class="line">            putchar(&#39;1&#39;);</span><br><span class="line">        else</span><br><span class="line">            putchar(&#39;0&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打印未决信号集</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    sigset_t set, oldset, pendset;</span><br><span class="line"></span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    sigemptyset(&amp;set);</span><br><span class="line">    sigaddset(&amp;set, SIGQUIT);   &#x2F;&#x2F; 阻塞信号集SIGQUIT信号置1,当有SIGQUIT信号发出时，未决信号集相应位置1</span><br><span class="line"></span><br><span class="line">    ret &#x3D; sigprocmask(SIG_BLOCK, &amp;set, &amp;oldset);</span><br><span class="line">    if(ret &#x3D;&#x3D; -1)</span><br><span class="line">        sys_err(&quot;sigprocmask error&quot;);</span><br><span class="line"></span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        ret &#x3D; sigpending(&amp;pendset);</span><br><span class="line">        if(ret &#x3D;&#x3D; -1)</span><br><span class="line">            sys_err(&quot;sigpending error&quot;);</span><br><span class="line"></span><br><span class="line">        print_set(&amp;pendset);</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信号屏蔽集在进程执行期间都是生效的。</p>
<h3 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一种：signal函数，不推荐使用</span><br><span class="line">typedef void (*sighandler_t)(int);  &#x2F;&#x2F; 注册一个信号捕捉函数</span><br><span class="line">sighandler_t signal(int signum, sighandler_t handler); &#x2F;&#x2F; 成功：返回函数指针；失败：返回SIG_ERR，设置errno</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第二种: sigaction函数，推荐使用</span><br><span class="line">int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);  &#x2F;&#x2F; 成功：0；失败：-1，设置errno</span><br><span class="line">参数：</span><br><span class="line">    act：传入参数，新的处理方式。</span><br><span class="line">	oldact：传出参数，旧的处理方式。	</span><br><span class="line"></span><br><span class="line">struct sigaction &#123;</span><br><span class="line">        void     (*sa_handler)(int);</span><br><span class="line">        void     (*sa_sigaction)(int, siginfo_t *, void *);</span><br><span class="line">        sigset_t   sa_mask;</span><br><span class="line">        int       sa_flags;</span><br><span class="line">        void     (*sa_restorer)(void);</span><br><span class="line">    &#125;;</span><br><span class="line">sa_handler：指定信号捕捉后的处理函数名(即注册函数)。也可赋值为SIG_IGN表忽略或SIG_DFL表执行默认动作</span><br><span class="line">sa_sigaction：很少使用  </span><br><span class="line">sa_mask: 调用信号处理函数时，所要屏蔽的信号集合(信号屏蔽字)。注意：仅在处理函数被调用期间屏蔽生效，是临时性设置。</span><br><span class="line">sa_flags：通常设置为0，表使用默认属性。默认sa_flags为0，表示屏蔽本信号。即比如SIGINT信号对应函数执行期间，屏蔽SIGINT信号。  </span><br><span class="line">sa_restorer：过时弃用</span><br></pre></td></tr></table></figure>
<p>sa_mask只工作于信号处理函数执行期间。PCB中的屏蔽信号集可以决定进程屏蔽哪些信号，执行信号捕捉函数时的屏蔽信号集由sa_mask指定。<br>一个信号执行信号捕捉函数时，该信号被屏蔽。只有等待信号捕捉函数执行完成，被屏蔽的信号才能执行(相当于阻塞)。阻塞的信号不支持排队，多次<br>发出信号只记录一次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void sig_handle(int signo)</span><br><span class="line">&#123;</span><br><span class="line">	if(signo &#x3D;&#x3D; SIGQUIT)</span><br><span class="line">		printf(&quot;catch signal %d\n&quot;, signo);</span><br><span class="line"></span><br><span class="line">	sleep(5);			&#x2F;&#x2F; 模拟信号处理函数执行很长时间</span><br><span class="line">	printf(&quot;end of handle\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct sigaction act, oldact;		</span><br><span class="line"></span><br><span class="line">	act.sa_handler &#x3D; sig_handle;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);		</span><br><span class="line">	sigaddset(&amp;act.sa_mask, SIGINT);	</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 将SIGINT加入信号屏蔽集</span><br><span class="line">	&#x2F;&#x2F; 在调用信号处理函数期间:不响应SIGQUIT信号本身,也不响应SIGINT(当信号处理函数执行完才响应)</span><br><span class="line">	act.sa_flags &#x3D; 0;	</span><br><span class="line"></span><br><span class="line">	sigaction(SIGQUIT, &amp;act, &amp;oldact);		&#x2F;&#x2F; 注册信号SIGINT捕捉函数</span><br><span class="line"></span><br><span class="line">	while(1);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="借助SIGCHLD信号回收子进程"><a href="#借助SIGCHLD信号回收子进程" class="headerlink" title="借助SIGCHLD信号回收子进程"></a>借助SIGCHLD信号回收子进程</h3><p>SIGCHLD产生的条件：子进程终止；子进程接收到SIGSTOP信号停止；子进程处于停止态，接收到SIGCONT后唤醒。<br>父进程fork子进程后，如果父进程使用execl函数族，则父进程不能回收子进程。此时，可以使用信号的方式进行回调回收子进程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">void sys_err(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void do_sig_child(int signo)</span><br><span class="line">&#123;</span><br><span class="line">    int status;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    if ((pid &#x3D; waitpid(0, &amp;status, WNOHANG)) &gt; 0) &#123; &#x2F;&#x2F; 如果一次有多个进程终止，则由于回调函数一次只能回收一个，且多个进程信号只保留一个</span><br><span class="line">                                                    &#x2F;&#x2F; 这样会有子进程不被父进程回收的情况，造成僵尸进程</span><br><span class="line">    &#x2F;&#x2F;    while ((pid &#x3D; waitpid(0, &amp;status, WNOHANG)) &gt; 0) &#123;    &#x2F;&#x2F; 应该改成循环</span><br><span class="line">        if (WIFEXITED(status))</span><br><span class="line">            printf(&quot;child %d exit %d\n&quot;, pid, WEXITSTATUS(status));</span><br><span class="line">        else if (WIFSIGNALED(status))</span><br><span class="line">            printf(&quot;child %d cancel signal %d\n&quot;, pid, WTERMSIG(status));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    int i;</span><br><span class="line">    &#x2F;&#x2F;阻塞SIGCHLD，防止父进程回调函数还没注册，子进程就终止。</span><br><span class="line">    sigset_t set;</span><br><span class="line">    sigemptyset(&amp;set);</span><br><span class="line">    sigaddset(&amp;set, SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;set, NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for (i&#x3D;0; i&lt;5; i++) &#123;</span><br><span class="line">        if ((pid &#x3D; fork()) &#x3D;&#x3D; 0)</span><br><span class="line">            break;</span><br><span class="line">        else if (pid &lt; 0)</span><br><span class="line">            sys_err(&quot;fork&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	if(5 &#x3D;&#x3D; i)</span><br><span class="line">	&#123;</span><br><span class="line">        &#x2F;&#x2F; 先设置捕捉, 再解除对SIGCHLD的阻塞</span><br><span class="line">        struct sigaction act;</span><br><span class="line"></span><br><span class="line">        act.sa_handler &#x3D; do_sig_child;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags &#x3D; 0;</span><br><span class="line">        sigaction(SIGCHLD, &amp;act, NULL);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 回调函数注册后解除阻塞</span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;set, NULL);</span><br><span class="line">        </span><br><span class="line">        while (1) &#123;</span><br><span class="line">            printf(&quot;Parent ID %d\n&quot;, getpid());</span><br><span class="line">            sleep(1);</span><br><span class="line">        &#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;child ID %d\n&quot;, getpid());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="守护进程-Daemon"><a href="#守护进程-Daemon" class="headerlink" title="守护进程(Daemon)"></a>守护进程(Daemon)</h1><p>守护进程是后台运行，独立于控制终端、不与用户直接交互且周期性执行某种任务或等待处理发生事件的进程。守护进程不受用户登陆和注销影响。<br>进程组是一组相关进程的集合，会话是一组相关进程组的集合，一个进程会有如下ID:PID、PPID、PGID(进程组ID)、SID(会话ID)。<br>当父进程创建子进程的时候，默认子进程与父进程属于同一进程组。进程组ID等于第一个进程ID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 返回调用者的进程组ID</span><br><span class="line">pid_t getpgrp(void);    </span><br><span class="line">&#x2F;&#x2F; 返回指定进程的进程组ID</span><br><span class="line">pid_t getpgid(pid_t pid);   &#x2F;&#x2F; 成功：0；失败：-1，设置errno</span><br><span class="line">&#x2F;&#x2F; 改变进程默认所属的进程组,将pid对应的进程加入pgid对应的进程组</span><br><span class="line">int setpgid(pid_t pid, pid_t pgid); 	&#x2F;&#x2F; 成功：0；失败：-1，设置errno</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    if ((pid &#x3D; fork())&lt;0) &#123;</span><br><span class="line">        perror(&quot;fork&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125; else if (pid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        printf(&quot;child process PID is %d\n&quot;, getpid());</span><br><span class="line">        printf(&quot;Group ID of child is %d\n&quot;, getpgid(0));</span><br><span class="line">        printf(&quot;Session ID of child is %d\n&quot;, getsid(0));</span><br><span class="line"></span><br><span class="line">        sleep(5);</span><br><span class="line">        setsid();       &#x2F;&#x2F; 子进程非组长进程，故其成为新会话首进程，且成为组长进程。该进程组id即为会话进程</span><br><span class="line"></span><br><span class="line">        printf(&quot;Changed:\n&quot;);</span><br><span class="line">        printf(&quot;child process PID is %d\n&quot;, getpid());</span><br><span class="line">        printf(&quot;Group ID of child is %d\n&quot;, getpgid(0));</span><br><span class="line">        printf(&quot;Session ID of child is %d\n&quot;, getsid(0));</span><br><span class="line">        sleep(5);</span><br><span class="line"></span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在UNIX系统中，用户通过终端登录系统后得到一个Shell进程，这个终端成为Shell进程的控制终端（Controlling Terminal）.进程中，控制终端是保存在PCB中的信息，而fork会复制PCB中的信息，因此由Shell进程启动的其它进程的控制终端也是这个终端。默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。</p>
<ul>
<li>创建会话</li>
</ul>
<ol>
<li>调用进程不能是进程组组长。如果调用进程是进程组组长，则进程组组长会成为新进程组的组长，同时是新会话的会长。但是原进程组的其他成员<br>仍然在老的会话中，就会出现同一个进程组的进程分属于不同会话的情况。这破坏了进程组和会话之间的严格层次关系。</li>
<li>该进程成为一个新进程组的组长进程。</li>
<li>需有root权限(ubuntu不需要)</li>
<li>新会话丢弃原有的控制终端，该会话没有控制终端</li>
<li>建立新会话时，先调用fork, 父进程终止，子进程调用setsid</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取进程所属的会话ID</span><br><span class="line">pid_t getsid(pid_t pid); 成功：返回调用进程的会话ID；失败：-1，设置errno</span><br><span class="line">&#x2F;&#x2F; 创建一个会话，并以自己的ID设置进程组ID，同时也是新会话的ID</span><br><span class="line">pid_t setsid(void);  成功：返回调用进程的会话ID；失败：-1，设置errno</span><br></pre></td></tr></table></figure>
<ul>
<li>创建守护进程过程</li>
</ul>
<ol>
<li>创建子进程，父进程退出，所有工作在子进程中进行形式上脱离了控制终端</li>
<li>在子进程中创建新会话，setsid()函数，使子进程完全独立出来，脱离控制</li>
<li>改变当前目录为根目录，chdir()函数，防止占用可卸载的文件系统，也可以换成其它路径</li>
<li>重设文件权限掩码，umask()函数，防止继承的文件创建屏蔽字拒绝某些权限，增加守护进程灵活性</li>
<li>关闭文件描述符，继承的打开文件不会用到，浪费系统资源，无法卸载</li>
<li>开始执行守护进程核心工作</li>
<li>守护进程退出处理程序模型    </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line"></span><br><span class="line">void daemonize(void)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     *  成为一个新会话的首进程，失去控制终端</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if ((pid &#x3D; fork()) &lt; 0) &#123;</span><br><span class="line">        perror(&quot;fork&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125; else if (pid !&#x3D; 0) &#x2F;* parent *&#x2F;</span><br><span class="line">        exit(0);</span><br><span class="line">    setsid();</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 改变当前工作目录到&#x2F;目录下.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if (chdir(&quot;&#x2F;&quot;) &lt; 0) &#123;</span><br><span class="line">        perror(&quot;chdir&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* 设置umask为0 *&#x2F;</span><br><span class="line">    umask(0);</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 重定向0，1，2文件描述符到 &#x2F;dev&#x2F;null，因为已经失去控制终端，再操作0，1，2没有意义.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    close(0);</span><br><span class="line">    open(&quot;&#x2F;dev&#x2F;null&quot;, O_RDWR);	&#x2F;&#x2F; 保证0，1，2不会在守护进程open的时候被分配</span><br><span class="line">    dup2(0, 1);</span><br><span class="line">    dup2(0, 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    daemonize();</span><br><span class="line">    while(1);       &#x2F;* 在此循环中可以实现守护进程的核心工作 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h1><blockquote>
<p>如果某个系统支持两个或者多个动作（Action）同时存在，那么这个系统就是一个并发系统。如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个并行系统。并发系统与并行系统这两个定义之间的关键差异在于“存在”这个词。在并发程序中可以同时拥有两个或者多个线程。这意味着，如果程序在单核处理器上运行，那么这两个线程将交替地换入或者换出内存。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。我相信你已经能够得出结论——“并行”概念是“并发”概念的一个子集。也就是说，你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码。因此，凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。<br><a href="https://www.zhihu.com/question/33515481/answer/105348019" target="_blank" rel="noopener">作者链接</a></p>
<p>并发：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。<br>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。<br>并行（Parallel），当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。<br><a href="https://www.cnblogs.com/xc-chejj/p/10813692.html" target="_blank" rel="noopener">并行和并发的区别</a></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>并发是在一段时间内宏观上多个程序同时运行(宏观并行，微观串行)；并行是在某一时刻，真正有多个程序在运行。</p>
<p>并行和并发的区别：</p>
<p>并发，指的是多个事情，在同一时间段内同时发生了。<br>并行，指的是多个事情，在同一时间点上同时发生了。</p>
<p>并发的多个任务之间是互相抢占资源的。<br>并行的多个任务之间是不互相抢占资源的、</p>
<p>只有在多CPU或者一个CPU多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。</p>
<h1 id="链接地址"><a href="#链接地址" class="headerlink" title="链接地址"></a>链接地址</h1><p><a href="https://www.cnblogs.com/zengyiwen/p/5755191.html" target="_blank" rel="noopener">linux内核之进程的基本概念(进程，进程组，会话关系)</a><br><a href="https://blog.csdn.net/mijichui2153/article/details/81394387" target="_blank" rel="noopener">创建守护进程的步骤</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>31-虚拟机-Ubuntu-Mac</title>
    <url>/2020/02/29/31-%E8%99%9A%E6%8B%9F%E6%9C%BA-Ubuntu-Mac/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a>
<h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><h1 id="VMware-Workstation"><a href="#VMware-Workstation" class="headerlink" title="VMware Workstation"></a>VMware Workstation</h1><p><a href="https://blog.csdn.net/qq_39135287/article/details/82924547?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">VMware Workstation 14中文破解版 下载与安装(附密钥)</a></p>
<h2 id="Ubuntu-18-04"><a href="#Ubuntu-18-04" class="headerlink" title="Ubuntu 18.04"></a>Ubuntu 18.04</h2><h3 id="安装百度输入法"><a href="#安装百度输入法" class="headerlink" title="安装百度输入法"></a>安装百度输入法</h3><ol>
<li>Ubuntu下百度输入法需要安装fcitx。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt-get install aptitude</span><br><span class="line">sudo aptitude install fcitx-bin fcitx-table fcitx-config-gtk fcitx-config-gtk2 fcitx-frontend-all</span><br><span class="line">sudo aptitude install qt5-default qtcreator qml-module-qtquick-controls2</span><br></pre></td></tr></table></figure>
<ol>
<li><p>设置键盘输入法系统<br>左下角-&gt;设置-&gt;区域和语言-&gt;管理已安装的语言-&gt;添加或删除语言-&gt;勾选<strong>中文简体</strong>-&gt;点击<strong>应用</strong>。<br>左下角-&gt;设置-&gt;区域和语言-&gt;管理已安装的语言-&gt;键盘输入法系统-&gt;选择<strong>fcitx</strong>-&gt;点击<strong>应用到整个系统</strong>。</p>
<p><img src="/images/31-虚拟机-Ubuntu-Mac/1.fcitx.png" alt="1.fcitx"></p>
</li>
</ol>
<p>在<a href="https://srf.baidu.com/site/guanwang_linux/index.html" target="_blank" rel="noopener">百度输入法</a>下载linux版本的百度输入法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装</span><br><span class="line">sudo dpkg –i fcitx-baidupinyin.deb</span><br><span class="line"># 卸载</span><br><span class="line">sudo dpkg --purge remove fcitx-baidupinyin:amd64</span><br></pre></td></tr></table></figure>
<h2 id="Mac-OS-10-13"><a href="#Mac-OS-10-13" class="headerlink" title="Mac OS 10.13"></a>Mac OS 10.13</h2><p><a href="https://jingyan.baidu.com/article/ca2d939d79c9e3eb6c31ce32.html" target="_blank" rel="noopener">VMWare14 安装 Mac OS 系统</a></p>
]]></content>
  </entry>
  <entry>
    <title>36-密码学原理</title>
    <url>/2020/04/15/36-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a>
<h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h1><h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>  在对称加密算法中，加密和解密使用的密钥是相同的。因此，对称加密算法要保证安全性的话，密钥必须保管好。一旦密钥泄露，加密信息就会泄露。就如谍战片中护送密码本的<br>桥段所描述的那样，中央和地方情报人员通信采用发电报的形式，发送的信息时经过密码本加密的。地方情报人员接收到中央的指令后，需要密码本进行解密。而就像电视剧里所演<br>绎的那样，敌人会监听电报，也能得到加密后的指令。此时，敌人和同志都想得到密码本，就产生了护送密码本的情节。</p>
<h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><p>非对称加密算法采用公私钥对进行加密。公私钥对具有如下性质：</p>
<ul>
<li>密钥有公钥和私钥，一一对应，有一把公钥就必然有一把与之对应的、独一无二的私钥，反之亦成立。</li>
<li>所有的（公钥, 私钥）对都是不同的。</li>
<li>用公钥可以解开私钥加密的信息，反之亦成立。</li>
<li>同时生成公钥和私钥应该相对比较容易，但是从公钥推算出私钥，应该是很困难或者是不可能的。</li>
</ul>
<p>公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：</p>
<ul>
<li>加密：通过加密算法和公钥对内容(或者说明文)进行加密，得到密文。加密过程需要用到公钥。</li>
<li>解密：通过解密算法和私钥对密文进行解密，得到明文。解密过程需要用到解密算法和私钥。</li>
</ul>
<p>公钥密码体制的公钥和算法都是公开的，私钥是保密的。如果回到中央和地方情报人员通信的过程，地方情报人员和中央各有一对公私钥对。地方情报人员和中央可以直接通过电<br>报的形式交换公钥，即使在这过程中公钥被敌人窃取也没有关系。如果中央要向地方情报人员发送指令，就用地方情报人员的公钥加密，敌人得到了加密信息，但是却没有地方情报<br>人员的私钥，所以无法解开加密信息，从而得到指令。也就不会用护送密码本的问题了。</p>
<h2 id="加密与签名"><a href="#加密与签名" class="headerlink" title="加密与签名"></a>加密与签名</h2><p>加密指对某个内容进行加密，加密后的内容可以通过解密进行还原。一般来说，同志A向同志B发送信息，需要用同志B的公钥加密，这样加密后的信息只能同志B的私钥解开。签名的主要作用是让信息接收者验证，信息是否被修改过。男生A向女生A写信，希望女生A借5000元钱给男生A，并附上了男生A的支付宝账号。在投递过程中，如果男生B把这封信截胡了，并将这封信中支付宝账号修改了，然后投递给女生A。如果女生A无法验证这封信是否被修改过。此时女生A将会把5000元转给男生B，同时男生A没得到钱，反而背了5000元的黑锅。因此，这封信就需要男生A进行签名，保证这封信没有被篡改过。<br>  签名就是在信的后面加上一段内容，可以证明信息没有被修改过。过程如下：</p>
<ul>
<li>对信的信息做hash计算，得到信息摘要。hash计算可以采用如SHA256等哈希算法。哈希算法的特点：由原数据可以得到唯一哈希值；由哈希值无法推出原数据。</li>
<li>将信息摘要和男生A的私钥加密后做成签名，向女生A写的信就包括信的内容和签名。此时，女生A拥有男生A的公钥，可以解开签名得到哈希值1,然后把信的内容通过SHA256<br>函数计算哈希值2，如果哈希值1=哈希值2。则表示信的内容没有被篡改过；这个签名是男生A的；这个签名是针对这条记录的。在此过程中，如果信被男生B截胡了。此时，男生B要修改支付宝账号，就必须修改信的原内容，信的签名。但是，签名用的是男生A的私钥，男生B是无法伪造签名的，所以保证了信无法篡改。<br>以上机制看起来保证了男生A发送给女生A的信没有被修改，但是女生A如何认定自己手里的公钥是男生A的公钥呢？如果在男生A给女生A发送男生A的公钥后，男生B将女生A处的<br>男生A的公钥替换成男生B的公钥。则男生A将借钱信发给女生A，女生A由于持有了”假冒的”男生A的公钥，而无法确认男生A的信。此时，男生A的信如果被男生B拿到，男生B将男生A<br>的信的支付宝账号修改成自己的账号，并且通过哈希算法重新计算消息摘要，并用自己的私钥与消息摘要形成数字签名。之后，男生B就可以冒用男生A的名义，获得女生A的钱，并<br>将锅甩给男生A。那么，如何保证男生A的公钥就是男生A的公钥呢？答案就是数字证书！</li>
</ul>
<p>如HTTPS中，公钥加密，私钥签名。加密是为了传输信息，签名是为了验证。</p>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>一个证书包含下面的具体内容：</p>
<ul>
<li>证书的发布机构</li>
<li>证书的有效期</li>
<li>公钥</li>
<li>证书所有者</li>
<li>签名所使用的算法</li>
<li>指纹以及指纹算法</li>
</ul>
<p>数字证书可以保证数字证书里的公钥确实是这个证书的所有者的，或者证书可以用来确认对方的身份。<br>数字证书由专门的证书中心——CA(certificate authority)认证颁发。男生A将自己的公钥放到证书中心去进行认证，证书中心用自己的私钥，将男生A的公钥和相关信息加密，生<br>成数字证书。男生A拿到数字证书之后，在写信给女生A的时候，先把自己的数字证书发送给女生A，女生A也到CA获取CA的公钥，对数字证书解密，拿到男生A的公钥。此时，女生A<br>就可以确定男生A发过来的公钥就是男生A的公钥了。</p>
<h1 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h1><h2 id="密码学原理"><a href="#密码学原理" class="headerlink" title="密码学原理"></a>密码学原理</h2><ul>
<li><p>哈希<br>collision resistance:哈希函数没有找到制造哈希碰撞的方法，如MD5已经知道如何认为制造哈希碰撞。<br>hiding:哈希函数的计算是单向的。从x可以推出H(x)，但是从H(x)无法高效推出x。<br>puzzle friendly:根据哈希值的输入无法预测输出范围<br>H(block header) &lt;= target block header包括：上一个哈希，随机数nounce，根哈希<br>diffcult to solve, but easy to verify<br>比特币中用的是SHA-256</p>
</li>
<li><p>签名<br>开户创立一个公钥和私钥对<br>发送者用接收者的公钥加密，接收方用自己的私钥解密。用的是同一个人的公钥和私钥。<br>签名用来保证交易是本人发出的，用私钥签名。</p>
</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><h3 id="merkle-tree"><a href="#merkle-tree" class="headerlink" title="merkle tree"></a>merkle tree</h3><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="双花攻击-double-spending"><a href="#双花攻击-double-spending" class="headerlink" title="双花攻击(double spending)"></a>双花攻击(double spending)</h3><p>区块链防止双花攻击。<br>谁有权利发行数字货币(挖矿);怎么验证交易的有效性</p>
<p>输入：说明币的来源，和支付人的公钥<br>输出：说明支付给到的人的公钥hash(类似于银行账号)</p>
<p>block header: version;hash of previous block header(Hahs(previous block header));Merkel root hash target nounce<br>merkel root hash保证了交易无法被篡改<br>full validating node:<br>light weighting node:无法独立验证交易的合法性<br>轻结点不参与区块链的构造和维护<br>区块链是去中心化的账本，账本的内容要取得分布式的共识。<br>不可能结论：FLP 异步系统，网络时延无上限，哪怕系统中有一个成员宕机也无法达成共识。<br>CAP : Consistency Availability Partition tolerance 三个性质只能满足两个<br>Paxos<br>共识协议：<br>女巫攻击<br>分叉攻击:<br>区块链是去中心化的账本<br>全结点：UTXO(unspent transation output)数据结构<br>一个交易可以有多个输入和输出<br>transaction-based ledger:<br>account-based ledger:<br>区块链是不可篡改的账本</p>
<p>10分钟出块 6个确认块<br>应用层 区块链<br>网络层 P2P网络 结点TCP通信<br>51% 攻击:分叉攻击 boycott 不可能盗币<br>矿池 </p>
<p>以太坊：account-based ledger<br>replay attack nounce(sequence number)<br>externally owned account ： balance nounce<br>smart contract account 不能主动发起一个交易 code storage<br>状态树<br>交易树<br>trie:<br>优点：<br>  保证了数据打乱顺序构成同一棵树<br>  更新操作的局部性<br>缺点：<br>  树的高度太高 内存访问次数太多<br>Patricia tree: 路径压缩的前缀树<br>  访问内存的次数减少</p>
<p>MPT:Merkle Patricia tree<br>  防止篡改<br>  可以证明 no membership</p>
<p>Modified MPT<br>Merkle tree<br>binary tree</p>
<p>RLP:Recursive Length Prefix 递归长度前缀编码<br>bloom filter：false positive </p>
<p>比较稀疏的时候时候路径压缩效果比较好</p>
<p>地址表示成40个16进制的数(160位) 经过公钥取哈希转换得来的<br>branching factor </p>
<p>genesis block 创世纪块<br>mining centralization<br>centralization bias<br>GHOST协议：uncle block<br>最多合并两个uncle block<br>7代以内的叔叔区块才有初块奖励:解决临时性分叉,最长合法链<br>软分叉和硬分叉<br>block reward<br>gas fee:uncle block can not get<br>只有分叉后第一个区块及时合并<br>Block chain is secured by mining<br>bug bounty<br>ASIC(算力强,内存访问性能上差距不大) resistance：memory hard mining puzzle<br>LiteCoin<br>time-memory trade off<br>冷启动<br>16M(轻结点) cache 1G(矿工) dataset 不断扩展<br>ethash算法<br>pre-mining </p>
<p>BIP: BitCoin Improvement proposal<br>EIP</p>
<p>Proof of stake:闭环 无法直接对货币系统造成攻击<br>Proof of work: 通过购买大量算力设备可以对加密货币造成51%攻击<br>Proof of Deposit:<br>DPOS: Delegated Proof of Stake</p>
<p>nothing at stake:</p>
<p>以太坊权益证明协议：Casper the Friendly Finally Gadget(FFG)<br>Validator:<br>epoch<br>Prepare message:<br>Commit Message:</p>
<p>外部账户才可以发布一个交易,没有代码<br>合约账户才有代码</p>
<h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><h2 id="SHA256"><a href="#SHA256" class="headerlink" title="SHA256"></a>SHA256</h2><p>SHA256是目前常用的哈希算法。对于任意长度的消息，SHA256会产生一个256bit长的哈希值，称作消息摘要(digest)。只要原始记录不变，SHA256的哈希值不变。如果原始记录发生变化，哈希值也会发生变化。实际上，哈希算法虽然存在哈希碰撞，但是应用中没有办法篡改内容而不被检测出来。<strong>哈希碰撞是指，两条不同的原始记录，经过SHA256算法可以得到相同的哈希值</strong>。数学表示：SHA256(“x”)=H(x)；SHA256(“y”)=H(y)；H(x)=H(y)，则为哈希碰撞。由于哈希算法的输入空间是无限大的，对于SHA256算法来说，输出的哈希值为256位，每一位的取值为0或1，也就是输出空间为2^256种可能。由鸽笼原理，可知必然有两个输入映射到同一个输出，即哈希碰撞是必然存在的。但是，实际中，没有什么高效的方法，人为的制造哈希碰撞。给定一个x，只能通过暴力求解(遍历)的方式找到一个y，使得H(x)=H(y)。因此，实际中为了保证传输消息没有被篡改，通常是对哈希值进行验证。哈希值和私钥结合，就形成了签名，从而保证了内容不会被篡改。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="http://www.ruanyifeng.com/blog/2006/12/notes_on_cryptography.html" target="_blank" rel="noopener">密码学笔记</a><br><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="noopener">数字签名是什么？</a><br><a href="https://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html" target="_blank" rel="noopener">数字证书原理</a><br><a href="https://blog.csdn.net/u011583927/article/details/80905740" target="_blank" rel="noopener">SHA256算法原理详解</a><br><a href="https://blog.csdn.net/dbs1215/article/details/48953589?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">带你彻底理解RSA算法原理</a><br><a href="https://blog.csdn.net/gulang03/article/details/81176133?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">RSA 加密算法原理简述</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>33-stl源码剖析(一)</title>
    <url>/2020/03/05/33-stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90(%E4%B8%80)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a>
<h1 id="STL模板"><a href="#STL模板" class="headerlink" title="STL模板"></a>STL模板</h1><p>STL(Standard Template Libray)标准模板库是惠普实验室开发的一系列软件的统称。STL从广义上将分为三类：algorithm(算法)、container(容器)和iterator(迭代器)。容器和算法通过迭代器可以进行无缝衔接。在C++标准中，STL被组织为下面的13个头文件：<algorithm>、<deque>、<functional>、<iterator>、<vector>、<list>、<map>、<memory>、<numeric>、<queue>、<set>、<stack> 和<utility>。</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p><font color="red">容器是用于存放数据的类模板</font>。可变长数组、链表、平衡二叉树等数据结构在STL中都被实现为容器。程序员使用容器时，即将容器类模板实例化为容器类，会指明容器中存放的元素是什么类型。容器中可以存放基本类型，也可以存放对象。对象或基本类型的变量被插入容器中，实际插入的是对象或变量的一个复制品。<br>STL中许多算法(即函数模板)，如排序、查找等算法，在执行过程中会对容器中的元素进行比较。这些算法在比较元素是否相等时通常用运算符进行，比较大小通常用 &lt; 运算符进行。因此，被放入容器的对象所属的类最好重载 == 和 &lt; 运算符，以使得 两个对象用 == 和 &lt; 进行比较是有定义的。</p>
<h3 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h3><p>顺序容器有以下三种：可变长动态数组 vector、双端队列 deque、双向链表 list。</p>
<p>它们之所以被称为顺序容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置（尾部、头部或中间某处）插入，元素就会位于什么位置。</p>
<ul>
<li>teacher.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Teacher   &#x2F;&#x2F; Teacher是类 类型</span><br><span class="line">&#123;</span><br><span class="line">    friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const Teacher&amp; obj);</span><br><span class="line">public:</span><br><span class="line">	Teacher(string name, int age, const char* p &#x3D; NULL);</span><br><span class="line">	Teacher(const Teacher&amp; obj);</span><br><span class="line">	Teacher&amp; operator&#x3D;(Teacher&amp; obj);</span><br><span class="line">	~Teacher();</span><br><span class="line"></span><br><span class="line">	char* getContent();</span><br><span class="line">	void setContent(const char* p);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	int age;</span><br><span class="line">	string name;</span><br><span class="line">	char* pContent;</span><br><span class="line">	int clen;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>teacher.cpp</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;teacher.h&quot;</span><br><span class="line"></span><br><span class="line">Teacher::Teacher()</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;name &#x3D; &quot;&quot;;</span><br><span class="line">    this-&gt;age &#x3D; -1;</span><br><span class="line">    this-&gt;pContent &#x3D; NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义中不设置默认参数</span><br><span class="line">Teacher::Teacher(string name, int age, const char* p)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;name &#x3D; name;</span><br><span class="line">	this-&gt;age &#x3D; age;</span><br><span class="line"></span><br><span class="line">    if (p &#x3D;&#x3D; NULL)</span><br><span class="line">		this-&gt;pContent &#x3D; NULL;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		clen &#x3D; strlen(p);</span><br><span class="line">		&#x2F;&#x2F; 堆中申请空间</span><br><span class="line">		this-&gt;pContent &#x3D; new char[clen + 1];</span><br><span class="line">		strcpy(this-&gt;pContent, p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Teacher::Teacher(const Teacher&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;name &#x3D; obj.name;</span><br><span class="line">	this-&gt;age &#x3D; obj.age;</span><br><span class="line"></span><br><span class="line">	if (obj.pContent &#x3D;&#x3D; NULL)</span><br><span class="line">		this-&gt;pContent &#x3D; NULL;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		clen &#x3D; strlen(obj.pContent);</span><br><span class="line">		&#x2F;&#x2F; 堆中申请空间</span><br><span class="line">		this-&gt;pContent &#x3D; new char[clen + 1];</span><br><span class="line">		strcpy(this-&gt;pContent, obj.pContent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;	cout &lt;&lt; &quot;Teacher:&quot; &lt;&lt; this-&gt;name &lt;&lt; &quot;的Teacher(const Teacher&amp; obj)拷贝构造函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Teacher&amp; Teacher::operator&#x3D;(Teacher&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;name &#x3D; obj.name;</span><br><span class="line">	this-&gt;age &#x3D; obj.age;</span><br><span class="line"></span><br><span class="line">    if (obj.pContent &#x3D;&#x3D; NULL)</span><br><span class="line">		this-&gt;pContent &#x3D; NULL;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		clen &#x3D; strlen(obj.pContent);</span><br><span class="line">		&#x2F;&#x2F; 堆中申请空间</span><br><span class="line">		this-&gt;pContent &#x3D; new char[clen + 1];</span><br><span class="line">		strcpy(this-&gt;pContent, obj.pContent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Teacher::~Teacher()</span><br><span class="line">&#123;</span><br><span class="line">    if(this-&gt;pContent !&#x3D; NULL)</span><br><span class="line">        delete[] this-&gt;pContent;    &#x2F;&#x2F; 析构动态分配的内存空间</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char* Teacher::getContent()</span><br><span class="line">&#123;</span><br><span class="line">    return this-&gt;pContent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Teacher::setContent(const char* p)</span><br><span class="line">&#123;</span><br><span class="line">    if (p &#x3D;&#x3D; NULL)</span><br><span class="line">		this-&gt;pContent &#x3D; NULL;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		clen &#x3D; strlen(p);</span><br><span class="line">		&#x2F;&#x2F; 堆中申请空间</span><br><span class="line">		this-&gt;pContent &#x3D; new char[clen + 1];</span><br><span class="line">		strcpy(this-&gt;pContent, p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; out, const Teacher&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; &quot;name&#x3D;&quot; &lt;&lt; obj.name &lt;&lt; &quot;,age&#x3D;&quot; &lt;&lt; obj.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>myVector.hpp</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;teacher.h&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 容器模板</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class MyVector</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    MyVector(int len&#x3D;2)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;len &#x3D; len;    &#x2F;&#x2F; 开辟默认空间</span><br><span class="line">        this-&gt;pSpace &#x3D; new T[len];</span><br><span class="line">        count &#x3D; -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyVector(const MyVector&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;len &#x3D; obj.len;</span><br><span class="line">        this-&gt;pSpace &#x3D; new T[this-&gt;len];</span><br><span class="line">        this-&gt;count &#x3D; obj.count;</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0; i&lt;obj.count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            this-&gt;pSpace[i] &#x3D; obj.pSpace[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void pushBack(T t)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        if(count &lt; this-&gt;len-1)</span><br><span class="line">        &#123;</span><br><span class="line">            pSpace[count] &#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            this-&gt;len +&#x3D; 10;</span><br><span class="line">            T* tmp &#x3D; new T[this-&gt;len];</span><br><span class="line"></span><br><span class="line">            for(int i&#x3D;0; i&lt;&#x3D;count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[i] &#x3D; pSpace[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            delete[] pSpace;</span><br><span class="line">            pSpace &#x3D; tmp;</span><br><span class="line"></span><br><span class="line">            pSpace[count] &#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~MyVector()</span><br><span class="line">    &#123;</span><br><span class="line">        if(pSpace !&#x3D; NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            delete[] pSpace;</span><br><span class="line">            pSpace &#x3D; NULL;</span><br><span class="line">            len &#x3D; 0;</span><br><span class="line">            count &#x3D; -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; operator[](int index)</span><br><span class="line">    &#123;</span><br><span class="line">        return pSpace[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyVector&amp; operator&#x3D;(const MyVector&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pSpace !&#x3D; NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            delete[] pSpace;</span><br><span class="line">            pSpace &#x3D; NULL;</span><br><span class="line">            len &#x3D; 0;</span><br><span class="line">            count &#x3D; -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        len &#x3D; obj.len;</span><br><span class="line">        pSpace &#x3D; new T[len];</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0; i&lt;len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pSpace[i] &#x3D; obj[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int size()</span><br><span class="line">    &#123;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int print()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;&#x3D;count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; pSpace[i] &lt;&lt; endl;  &#x2F;&#x2F; 类对象需要重载&lt;&lt;运算符</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T* pSpace;</span><br><span class="line">    int len;</span><br><span class="line">    int count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 容器类</span><br><span class="line">    MyVector&lt;int&gt; intVector;</span><br><span class="line">    intVector.pushBack(0);</span><br><span class="line">    intVector.pushBack(1);</span><br><span class="line">    intVector.pushBack(2);</span><br><span class="line">    intVector.pushBack(3);</span><br><span class="line"></span><br><span class="line">    intVector.print();</span><br><span class="line"></span><br><span class="line">    MyVector&lt;Teacher&gt; classVector;</span><br><span class="line">    Teacher t1(&quot;lucy&quot;, 25);</span><br><span class="line">    Teacher t2(&quot;bob&quot;, 26);</span><br><span class="line">    Teacher t3(&quot;selena&quot;, 27);</span><br><span class="line">    Teacher t4(&quot;tomas&quot;, 28);</span><br><span class="line"></span><br><span class="line">    classVector.pushBack(t1);</span><br><span class="line">    classVector.pushBack(t2);</span><br><span class="line">    classVector.pushBack(t3);</span><br><span class="line">    classVector.pushBack(t4);</span><br><span class="line">    classVector.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h3><p>关联容器有以下四种：set、multiset、map、multimap。关联容器内的元素是排序的。插入元素时，容器会按一定的排序规则将元素放到适当的位置上，因此插入元素时不能指定位置。</p>
<p>默认情况下，关联容器中的元素是从小到大排序（或按关键字从小到大排序）的，而且用&lt;运算符比较元素或关键字大小。因为是排好序的，所以关联容器在查找时具有非常好的性能。</p>
<p>除了以上两类容器外，STL 还在两类容器的基础上屏蔽一部分功能，突出或增加另一部分功能，实现了三种容器适配器：栈 stack、队列 queue、优先级队列 priority_queue。</p>
<p>容器都是类模板。它们实例化后就成为容器类。用容器类定义的对象称为容器对象。</p>
<p>所有容器都有以下两个成员函数：</p>
<ul>
<li>int size()：返回容器对象中元素的个数。</li>
<li>bool empty()：判断容器对象是否为空。</li>
</ul>
<p>顺序容器和关联容器还有以下成员函数：</p>
<ul>
<li>begin()：返回指向容器中第一个元素的迭代器。</li>
<li>end()：返回指向容器中最后一个元素后面的位置的迭代器。</li>
<li>rbegin()：返回容器中倒数第一个元素的反向迭代器。</li>
<li>rend()：返回容器中倒数最后一个元素之后的反向迭代器。</li>
<li>erase(…)：从容器中删除一个或几个元素。该函数参数较复杂，此处省略。</li>
<li>clear()：从容器中删除所有元素。</li>
</ul>
<p>如果一个容器是空的，则 begin() 和 end() 的返回值相等，rbegin() 和 rend() 的返回值也相等。</p>
<p>顺序容器还有以下常用成员函数：</p>
<ul>
<li>front()：返回容器中第一个元素的引用。</li>
<li>back()：返回容器中最后一个元素的引用。</li>
<li>push_back()：在容器末尾增加新元素。</li>
<li>pop_back()：删除容器末尾的元素。</li>
<li>insert(…)：插入一个或多个元素。该函数参数较复杂，此处省略。</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器在STL中用来将算法和容器联系起来，几乎STL提供的所有算法都是通过迭代器存取元素序列进行工作的，<strong>每一个容器都定义了其本身所专有的迭代器</strong>，用以存取容器中的元素。</p>
<h1 id="容器模板"><a href="#容器模板" class="headerlink" title="容器模板"></a>容器模板</h1><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>C语言：字符串的结尾带有’\0’，strlen(s)的结果不包括’\0’，sizeof(s)的结果包括’\0’<br>C++：string，s.size()的结果不包括’\s’。sizeof(s)是string类型的默认分配的内存空间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 默认构造函数：</span><br><span class="line">string();	   </span><br><span class="line"># 拷贝构造函数：</span><br><span class="line">string(const string &amp;str);	&#x2F;&#x2F; 构造一个与str一样的string</span><br><span class="line"># 带参数的构造函数</span><br><span class="line">string(const char *s);      &#x2F;&#x2F; 用字符串s初始化</span><br><span class="line">string(int n,char c);       &#x2F;&#x2F; 用n个字符c初始化</span><br><span class="line"></span><br><span class="line">const char &amp;operator[] (int n) const;</span><br><span class="line">const char &amp;at(int n) const;</span><br><span class="line">char &amp;operator[] (int n);</span><br><span class="line">char &amp;at(int n);</span><br><span class="line"></span><br><span class="line">const char *c_str() const;   &#x2F;&#x2F; 返回一个以&#39;\0&#39;结尾的字符串的首地址</span><br><span class="line">int copy(char *s, int n, int pos&#x3D;0) const;     &#x2F;&#x2F; 把当前串中以pos开始的n个字符拷贝到以s为起始的字符数组中，返回实际的拷贝的数目</span><br><span class="line">int length() const;     &#x2F;&#x2F; 返回当前字符串的长度。长度不包括字符串结尾的&#39;\0&#39;。</span><br><span class="line">bool empty() const;     &#x2F;&#x2F; 当前字符串是否为空</span><br><span class="line"></span><br><span class="line">string &amp;operator&#x3D;(const string &amp;s); &#x2F;&#x2F; 把字符串s赋给当前的字符串</span><br><span class="line">string &amp;assign(const char *s);      &#x2F;&#x2F; 把字符串s赋给当前的字符串</span><br><span class="line">string &amp;assign(const char *s, int n); &#x2F;&#x2F; 把字符串s的前n个字符赋给当前的字符串</span><br><span class="line">string &amp;assign(const string &amp;s);    &#x2F;&#x2F; 把字符串s赋给当前字符串</span><br><span class="line">string &amp;assign(int n, char c);       &#x2F;&#x2F; 用n个字符c赋给当前字符串</span><br><span class="line">string &amp;assign(const string &amp;s,int start, int n);  &#x2F;&#x2F; 把字符串s中从start开始的n个字符赋给当前字符串</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string &amp;operator+&#x3D;(const string &amp;s);    &#x2F;&#x2F; 把字符串s连接到当前字符串结尾</span><br><span class="line">string &amp;operator+&#x3D;(const char *s);      &#x2F;&#x2F; 把字符串s连接到当前字符串结尾</span><br><span class="line">string &amp;append(const char *s);          &#x2F;&#x2F; 把字符串s连接到当前字符串结尾</span><br><span class="line">string &amp;append(const char *s,int n);    &#x2F;&#x2F; 把字符串s的前n个字符连接到当前字符串结尾</span><br><span class="line">string &amp;append(const string &amp;s);        &#x2F;&#x2F; 同operator+&#x3D;()</span><br><span class="line">string &amp;append(const string &amp;s,int pos, int n); &#x2F;&#x2F; 把字符串s中从pos开始的n个字符连接到当前字符串结尾</span><br><span class="line">string &amp;append(int n, char c);          &#x2F;&#x2F; 在当前字符串结尾添加n个字符c</span><br><span class="line">string substr(int pos&#x3D;0, int n&#x3D;npos) const;    &#x2F;&#x2F; 返回由pos开始的n个字符组成的子字符串</span><br><span class="line"></span><br><span class="line">int compare(const string &amp;s) const;     &#x2F;&#x2F; 与字符串s比较</span><br><span class="line">int compare(const char *s) const;       &#x2F;&#x2F; 与字符串s比较</span><br><span class="line">&#x2F;&#x2F; compare函数在&gt;时返回 1，&lt;时返回 -1，&#x3D;&#x3D;时返回 0。比较区分大小写，比较时参考字典序，排越前面的越小。大写的A比小写的a小。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int find(char c, int pos&#x3D;0) const;              &#x2F;&#x2F; 从pos开始查找字符c在当前字符串的位置 </span><br><span class="line">int find(const char *s, int pos&#x3D;0) const;       &#x2F;&#x2F; 从pos开始查找字符串s在当前字符串的位置</span><br><span class="line">int find(const string &amp;s, int pos&#x3D;0) const;     &#x2F;&#x2F; 从pos开始查找字符串s在当前字符串中的位置 </span><br><span class="line">&#x2F;&#x2F; find函数如果查找不到，就返回-1</span><br><span class="line">int rfind(char c, int pos&#x3D;npos) const;          &#x2F;&#x2F; 从pos开始从后向前查找字符c在当前字符串中的位置 </span><br><span class="line">int rfind(const char *s, int pos&#x3D;npos) const;</span><br><span class="line">int rfind(const string &amp;s, int pos&#x3D;npos) const;</span><br><span class="line">&#x2F;&#x2F;rfind是反向查找的意思，如果查找不到， 返回-1</span><br><span class="line"></span><br><span class="line"># 替换</span><br><span class="line">string &amp;replace(int pos, int n, const char *s); &#x2F;&#x2F; 删除从pos开始的n个字符，然后在pos处插入串s</span><br><span class="line">string &amp;replace(int pos, int n, const string &amp;s);  &#x2F;&#x2F; 删除从pos开始的n个字符，然后在pos处插入串s</span><br><span class="line">void swap(string &amp;s2);                          &#x2F;&#x2F; 交换当前字符串与s2的值</span><br><span class="line"></span><br><span class="line">string &amp;insert(int pos, const char *s);</span><br><span class="line">string &amp;insert(int pos, const string &amp;s);</span><br><span class="line">&#x2F;&#x2F; 前两个函数在pos位置插入字符串s</span><br><span class="line">string &amp;insert(int pos, int n, char c);     &#x2F;&#x2F; 在pos位置 插入n个字符c</span><br><span class="line">string &amp;erase(int pos&#x3D;0, int n&#x3D;npos);       &#x2F;&#x2F; 删除pos开始的n个字符，返回修改后的字符串</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string to_string (int val);</span><br><span class="line">string to_string (long val);</span><br><span class="line">string to_string (long long val);</span><br><span class="line">string to_string (unsigned val);</span><br><span class="line">string to_string (unsigned long val);</span><br><span class="line">string to_string (unsigned long long val);</span><br><span class="line">string to_string (float val);</span><br><span class="line">string to_string (double val);</span><br><span class="line">string to_string (long double val);</span><br></pre></td></tr></table></figure>
<h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><p>头文件：<code>#include &lt;vector&gt;</code>。vector是可变长的动态数组，支持随机访问迭代器。vector容器中，用一个动态分配的数组来存放元素。动态分配的存储空间一般都大于存放元素所需的空间。例如，哪怕容器中只有一个元素，也会分配 32 个元素的存储空间。这样做的好处是，在尾部添加一个新元素时不必重新分配空间，直接将新元素写入适当位置即可。在这种情况下，添加新元素的时间也是常数。</p>
<p>但是，如果不断添加新元素，多出来的空间就会用完，此时再添加新元素，就不得不重新分配内存空间，把原有内容复制过去后再添加新的元素。碰到这种情况，添加新元素所花的时间就不是常数，而是和数组中的元素个数成正比。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector();       &#x2F;&#x2F; 容器初始化为空</span><br><span class="line">vector(int n);  &#x2F;&#x2F; 将容器初始化为有n个元素，初始值为0</span><br><span class="line">vector(int n, const T&amp; val);   &#x2F;&#x2F; 假定元素的类型是T,此构造函数将容器初始化为有n个元素，每个元素的值都是val</span><br><span class="line">vector(iterator begin, iterator end);   &#x2F;&#x2F; begin和end是其他容器的迭代器(或指针)。将本vector容器的内容变成与其他容器上的区间[begin, end)一致。</span><br><span class="line">vector(const vector&amp; obj);  &#x2F;&#x2F; 拷贝构造</span><br><span class="line"></span><br><span class="line">int size();   &#x2F;&#x2F; 返回容器中元素个数</span><br><span class="line">bool empty();     &#x2F;&#x2F; 判断容器是否为空</span><br><span class="line">void push_back(const T&amp; val); &#x2F;&#x2F; 将val添加到容器末尾</span><br><span class="line">void pop_back();  &#x2F;&#x2F; 删除容器末尾的元素</span><br><span class="line">T&amp; front();     &#x2F;&#x2F; 返回容器中第一个元素的引用</span><br><span class="line">T&amp; back();      &#x2F;&#x2F; 返回容器中最后一个元素的引用</span><br><span class="line"></span><br><span class="line">T&amp; at(index);   &#x2F;&#x2F; 返回索引index所指的数据 越界抛异常</span><br><span class="line">vector[index];      &#x2F;&#x2F; 返回索引index所指的数据 越界报错</span><br><span class="line"></span><br><span class="line">assign(begin, end); &#x2F;&#x2F; 将[begin, end)区间的数据拷贝赋值给本身</span><br><span class="line">assign(n, elem);    &#x2F;&#x2F; 将n个elem拷贝赋值给本身</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; vector转string</span><br><span class="line">vector&lt;int&gt; vec &#x3D; &#123;1, 2, 3, 4&#125;;</span><br><span class="line">string str;</span><br><span class="line">str.assign(vec.begin(), vec.end());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; string 转vector</span><br><span class="line">string str &#x3D; &quot;1234&quot;;</span><br><span class="line">vector vec(str.begin(), str.end());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void swap( vector &lt;T&gt; &amp; v); 	&#x2F;&#x2F; 将容器自身的内容和另一个同类型的容器 v 互换</span><br><span class="line">resize(num);        &#x2F;&#x2F; 重新指定容器的长度为num。若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line">resize(num, elem);  &#x2F;&#x2F; 重新指定容器的长度为num。若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line"></span><br><span class="line">iterator insert(iterator i, const T &amp; val); 	&#x2F;&#x2F; 将 val 插入迭代器 i 指向的位置，返回 i</span><br><span class="line">iterator insert( iterator i, iterator first, iterator last); 	&#x2F;&#x2F; 将其他容器上的区间 [first, last) 中的元素插入迭代器 i 指向的位置</span><br><span class="line">iterator erase(iterator i) ;	&#x2F;&#x2F; 删除迭代器 i 指向的元素，返回值是被删元素后面的元素的迭代器</span><br><span class="line">iterator erase(iterator first, iterator last); 	&#x2F;&#x2F; 删除容器中的区间 [first, last)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 正向遍历</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void printVector(const vector&lt;T&gt;&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">    typename vector&lt;T&gt;::const_iterator it;</span><br><span class="line">    for(it&#x3D;v.begin(); it!&#x3D;v.end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 反向遍历</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void printReverseVector(const vector&lt;T&gt;&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">    typename vector&lt;T&gt;::const_reverse_iterator it;</span><br><span class="line">    for(it&#x3D;v.rbegin(); it!&#x3D;v.rend(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    int a[5] &#x3D; &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">    vector&lt;int&gt; vec1(a, a+5); &#x2F;&#x2F; vector(iterator first, iterator last);</span><br><span class="line">    printVector&lt;int&gt;(vec1);   &#x2F;&#x2F; 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; vec2(10, -1);   &#x2F;&#x2F; -1 -1 -1 -1 -1 -1 -1 -1 -1 -1</span><br><span class="line">    printVector(vec2);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将vec1 [begin, end)区间中的数据拷贝赋值给本身</span><br><span class="line">    vec2.assign(vec1.begin(), vec1.begin()+3);  &#x2F;&#x2F; 1  2 3</span><br><span class="line">    printVector(vec2);</span><br><span class="line"></span><br><span class="line">    vec2.assign(8, 3);  &#x2F;&#x2F; 3 3 3 3 3 3 3 3</span><br><span class="line">    printVector(vec2);</span><br><span class="line"></span><br><span class="line">    vec2.swap(vec1);    &#x2F;&#x2F; 1 2 3 4 5</span><br><span class="line">    printVector(vec2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; vec2.front() &lt;&lt; endl;   &#x2F;&#x2F; 1</span><br><span class="line">    cout &lt;&lt; vec2.back() &lt;&lt; endl;    &#x2F;&#x2F; 5</span><br><span class="line"></span><br><span class="line">    vec2.front() &#x3D; -1;</span><br><span class="line">    vec2.back() &#x3D; -1;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取头部元素</span><br><span class="line">    cout &lt;&lt; vec2.front() &lt;&lt; endl;   &#x2F;&#x2F; -1</span><br><span class="line">    &#x2F;&#x2F; 获取尾部元素</span><br><span class="line">    cout &lt;&lt; vec2.back() &lt;&lt; endl;    &#x2F;&#x2F; -1</span><br><span class="line"></span><br><span class="line">    vec2.pop_back();</span><br><span class="line">    printVector(vec2);              &#x2F;&#x2F; -1 2 3 4</span><br><span class="line">    printReverseVector(vec2);       &#x2F;&#x2F; 4 3 2 -1</span><br><span class="line"></span><br><span class="line">    vec2.push_back(20);</span><br><span class="line">    printVector(vec2);              &#x2F;&#x2F; -1 2 3 4 20</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 在vec2.begin()+1处插入元素33</span><br><span class="line">    vec2.insert(vec2.begin()+1, 33);</span><br><span class="line">    printVector(vec2);              &#x2F;&#x2F; -1 33 2 3 4 20</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 删除[begin, end)的元素</span><br><span class="line">    vec2.erase(vec2.begin(), vec2.begin()+1);</span><br><span class="line">    printVector(vec2);              &#x2F;&#x2F; 33 2 3 4 20</span><br><span class="line">    cout &lt;&lt; vec2.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 33 2 3 4 20 0 0 0 0 0</span><br><span class="line">    vec2.resize(10);         &#x2F;&#x2F; 超出部分填充0</span><br><span class="line">    printVector(vec2);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 33 2 3 4 20 0 0 0</span><br><span class="line">    vec2.resize(8);          &#x2F;&#x2F; 容器变短,删除元素</span><br><span class="line">    printVector(vec2);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 33 2 3 4 20 0 -1 -1 -1 -1</span><br><span class="line">    vec2.resize(10, -1);    &#x2F;&#x2F; 超出部分填充-1</span><br><span class="line">    printVector(vec2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h2><p>头文件：<code>#include &lt;stack&gt;</code>。栈容器，栈是一种后进先出的元素序列，访问和删除都只能对栈顶元素进行，并且元素也只能被添加到栈顶。栈内元素不能访问。如果一定要访问栈内元素，只能将其上方的元素全部从栈中删除，使之变成栈顶元素才可以。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stack.push(element);  &#x2F;&#x2F; 压栈</span><br><span class="line">stack.pop();          &#x2F;&#x2F; 出栈</span><br><span class="line">stack.top();          &#x2F;&#x2F; 获取栈顶元素</span><br><span class="line">stack.empty();        &#x2F;&#x2F; 判断堆栈是否为空</span><br><span class="line">stack.size();         &#x2F;&#x2F; 返回堆栈大小</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">	stack&lt;int&gt; s;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 入栈</span><br><span class="line">	for (int i&#x3D;0; i&lt;10; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		s.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;size&#x3D;&quot; &lt;&lt; s.size() &lt;&lt; endl;    &#x2F;&#x2F; 返回栈的大小</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 出栈</span><br><span class="line">	while ( !s.empty() )    &#x2F;&#x2F; 判断栈是否为空</span><br><span class="line">	&#123;</span><br><span class="line">		int tmp &#x3D; s.top();  &#x2F;&#x2F; 获取栈顶元素</span><br><span class="line">		cout &lt;&lt;  tmp &lt;&lt; &quot; &quot;;</span><br><span class="line">		s.pop();            &#x2F;&#x2F; 弹出栈顶元素</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Deque容器"><a href="#Deque容器" class="headerlink" title="Deque容器"></a>Deque容器</h2><p>deque是双端数组，可以随机存取元素。deque头部和尾部添加或移除元素都非常快速。但是在中部安插元素或移除元素比较费时。<code>#include &lt;deque&gt;</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deque.push_back(elem);	&#x2F;&#x2F; 在容器尾部添加一个数据</span><br><span class="line">deque.push_front(elem);	&#x2F;&#x2F; 在容器头部插入一个数据</span><br><span class="line">deque.pop_back();    	&#x2F;&#x2F; 删除容器最后一个数据</span><br><span class="line">deque.pop_front();		&#x2F;&#x2F; 删除容器第一个数据</span><br><span class="line"></span><br><span class="line">deque.at(idx);      &#x2F;&#x2F; 返回索引idx所指的数据，如果idx越界，抛出out_of_range</span><br><span class="line">deque[idx];         &#x2F;&#x2F; 返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错</span><br><span class="line">deque.front();      &#x2F;&#x2F; 返回第一个数据</span><br><span class="line">deque.back();       &#x2F;&#x2F; 返回最后一个数据</span><br><span class="line"></span><br><span class="line">deque.begin();      &#x2F;&#x2F; 返回容器中第一个元素的迭代器。</span><br><span class="line">deque.end();        &#x2F;&#x2F; 返回容器中最后一个元素之后的迭代器。</span><br><span class="line">deque.rbegin();     &#x2F;&#x2F; 返回容器中倒数第一个元素的迭代器。</span><br><span class="line">deque.rend();       &#x2F;&#x2F; 返回容器中倒数最后一个元素之后的迭代器。</span><br><span class="line"></span><br><span class="line">deque(begin, end);      &#x2F;&#x2F; 构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间</span><br><span class="line">deque(n,elem);          &#x2F;&#x2F; 构造函数将n个elem拷贝给本身。</span><br><span class="line">deque(const deque &amp;deq);  &#x2F;&#x2F; 拷贝构造函数。</span><br><span class="line"></span><br><span class="line">deque.assign(beg,end);  &#x2F;&#x2F; 将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</span><br><span class="line">deque.assign(n,elem);   &#x2F;&#x2F; 将n个elem拷贝赋值给本身。</span><br><span class="line">deque&amp; operator&#x3D;(const deque &amp;deq);	    &#x2F;&#x2F; 重载等号操作符 </span><br><span class="line">deque.swap(deq);        &#x2F;&#x2F; 将vec与本身的元素互换</span><br><span class="line"></span><br><span class="line">deque.size();	        &#x2F;&#x2F; 返回容器中元素的个数</span><br><span class="line">deque.empty();	        &#x2F;&#x2F; 判断容器是否为空</span><br><span class="line">deque.resize(num);      &#x2F;&#x2F; 重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line">deque.resize(num, elem);  &#x2F;&#x2F; 重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line"></span><br><span class="line">deque.insert(pos,elem);     &#x2F;&#x2F; 在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span><br><span class="line">deque.insert(pos,n,elem);   &#x2F;&#x2F; 在pos位置插入n个elem数据，无返回值。</span><br><span class="line">deque.insert(pos,begin,end);  &#x2F;&#x2F; 在pos位置插入[begin,end)区间的数据，无返回值。</span><br><span class="line"></span><br><span class="line">deque.clear();	            &#x2F;&#x2F; 移除容器的所有数据</span><br><span class="line">deque.erase(beg,end);       &#x2F;&#x2F; 删除[beg,end)区间的数据，返回下一个数据的位置</span><br><span class="line">deque.erase(pos);           &#x2F;&#x2F; 删除pos位置的数据，返回下一个数据的位置</span><br></pre></td></tr></table></figure>
<h2 id="Queue容器"><a href="#Queue容器" class="headerlink" title="Queue容器"></a>Queue容器</h2><h1 id="include-。Queue是一种先进先出的队列容器"><a href="#include-。Queue是一种先进先出的队列容器" class="headerlink" title="include 。Queue是一种先进先出的队列容器"></a>include <queue>。Queue是一种先进先出的队列容器</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">queue.push(element);  &#x2F;&#x2F; 入队</span><br><span class="line">queue.pop();          &#x2F;&#x2F; 出队</span><br><span class="line">queue.empty();        &#x2F;&#x2F; 判断队列是否为空</span><br><span class="line">queue.size();         &#x2F;&#x2F; 返回队列大小</span><br><span class="line">queue.front();        &#x2F;&#x2F; 返回队首元素</span><br><span class="line">queue.back();         &#x2F;&#x2F; 返回队尾元素</span><br><span class="line"></span><br><span class="line">queue(const queue &amp;que);		        &#x2F;&#x2F; 拷贝构造函数</span><br><span class="line">queue&amp; operator&#x3D;(const queue &amp;que);	    &#x2F;&#x2F; 重载等号操作符</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 入栈</span><br><span class="line">	for (int i&#x3D;0; i&lt;10; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		q.push(i);  &#x2F;&#x2F; 向队尾添加元素</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;size&#x3D;&quot; &lt;&lt; q.size() &lt;&lt; endl;    &#x2F;&#x2F; 返回队列的大小</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 出栈</span><br><span class="line">	while ( !q.empty() )    &#x2F;&#x2F; 判断队列是否为空</span><br><span class="line">	&#123;</span><br><span class="line">		int first &#x3D; q.front();  &#x2F;&#x2F; 返回第一个元素</span><br><span class="line">		cout &lt;&lt;  first &lt;&lt; &quot; &quot;;</span><br><span class="line">		q.pop();                &#x2F;&#x2F; 弹出队头元素</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p>priority_queue是优先级队列，默认是最大值优先级队列。#include <queue></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">priority_queue.empty()</span><br><span class="line">priority_queue.size()</span><br><span class="line">priority_queue.top()</span><br><span class="line">priority_queue.pop()</span><br><span class="line">priority_queue.push(item)</span><br><span class="line"></span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; p1;    &#x2F;&#x2F; 最大值优先级队列</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; p2;  &#x2F;&#x2F; 最小值优先级队列</span><br></pre></td></tr></table></figure>
<h2 id="set容器"><a href="#set容器" class="headerlink" title="set容器"></a>set容器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set.insert(elem);       &#x2F;&#x2F; 在容器中插入元素。</span><br><span class="line">set.begin();            &#x2F;&#x2F; 返回容器中第一个数据的迭代器。</span><br><span class="line">set.end();              &#x2F;&#x2F; 返回容器中最后一个数据之后的迭代器。</span><br><span class="line">set.rbegin();           &#x2F;&#x2F; 返回容器中倒数第一个元素的迭代器。</span><br><span class="line">set.rend();             &#x2F;&#x2F; 返回容器中倒数最后一个元素的后面的迭代器。</span><br><span class="line"></span><br><span class="line">set&lt; int, less&lt;int&gt; &gt;  setIntA;      &#x2F;&#x2F; 该容器是按升序方式排列元素 et&lt;int&gt; 相当于 set&lt;int,less&lt;int&gt;&gt;。</span><br><span class="line">set&lt; int, greater&lt;int&gt; &gt; setIntB;    &#x2F;&#x2F; 该容器是按降序方式排列元素</span><br><span class="line"></span><br><span class="line">set&lt;T&gt; s &#x3D; &#123;&#125;;</span><br><span class="line">set(begin, end);                    &#x2F;&#x2F; 构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间</span><br><span class="line">set(const set &amp;st);		            &#x2F;&#x2F; 拷贝构造函数</span><br><span class="line">set&amp; operator&#x3D;(const set &amp;st);	    &#x2F;&#x2F; 重载等号操作符</span><br><span class="line">set.swap(st);				        &#x2F;&#x2F; 交换两个集合容器</span><br><span class="line"></span><br><span class="line">set.size();	                        &#x2F;&#x2F; 返回容器中元素的数目</span><br><span class="line">set.empty();                        &#x2F;&#x2F; 判断容器是否为空</span><br><span class="line"></span><br><span class="line">set.clear();		                &#x2F;&#x2F; 清除所有元素</span><br><span class="line">set.erase(pos);	                    &#x2F;&#x2F; 删除pos迭代器所指的元素，返回下一个元素的迭代器。</span><br><span class="line">set.erase(beg,end);	                &#x2F;&#x2F; 删除区间[beg,end)的所有元素，返回下一个元素的迭代器。</span><br><span class="line">set.erase(elem);                    &#x2F;&#x2F; 删除容器中值为elem的元素。</span><br><span class="line"></span><br><span class="line">set.find(elem);                     &#x2F;&#x2F; 查找elem元素，返回指向elem元素的迭代器</span><br><span class="line">set.count(elem);                    &#x2F;&#x2F; 返回容器中值为elem的元素个数。对set来说，要么是0，要么是1。对multiset来说，值可能大于1</span><br><span class="line">set.lower_bound(elem);              &#x2F;&#x2F; 返回第一个&gt;&#x3D;elem元素的迭代器</span><br><span class="line">set.upper_bound(elem);	            &#x2F;&#x2F; 返回第一个&gt;elem元素的迭代器</span><br><span class="line">set.equal_range(elem);		        &#x2F;&#x2F; 返回容器中与elem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)</span><br><span class="line"></span><br><span class="line">pair&lt;T1,T2&gt;存放的两个值的类型，可以不一样，如T1为int，T2为float。T1,T2也可以是自定义类型。</span><br><span class="line">pair.first是pair里面的第一个值，是T1类型。</span><br><span class="line">pair.second是pair里面的第二个值，是T2类型。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lower_bound(begin, end， val);        &#x2F;&#x2F; 返回第一个&gt;&#x3D;elem元素的迭代器</span><br><span class="line">upper_bound(begin, end, val);         &#x2F;&#x2F; 返回第一个&gt;elem元素的迭代器</span><br><span class="line">auto bounds &#x3D; equal_range(begin, end, val); &#x2F;&#x2F; 返回容器中与elem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)</span><br></pre></td></tr></table></figure>
<h2 id="map容器"><a href="#map容器" class="headerlink" title="map容器"></a>map容器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map.insert(...);    &#x2F;&#x2F; 往容器插入元素，返回pair&lt;iterator,bool&gt;</span><br><span class="line"># 在map中插入元素的三种方式，假设map&lt;int, string&gt; mapStu;</span><br><span class="line"># 1. 通过pair的方式插入对象</span><br><span class="line">mapStu.insert( pair&lt;int,string&gt;(3,&quot;lana&quot;) );</span><br><span class="line"># 2. 通过pair的方式插入对象</span><br><span class="line">mapStu.insert( make_pair(3, “lana”) );</span><br><span class="line"># 3. 通过value_type的方式插入对象</span><br><span class="line">mapStu.insert(  map&lt;int,string&gt;::value_type( 3,&quot;lana&quot;)  );</span><br><span class="line"># 4. 通过数组的方式插入值</span><br><span class="line">mapStu[3] &#x3D; “lana&quot;;</span><br><span class="line"></span><br><span class="line"># 前三种方法，采用的是insert()方法，该方法返回值为pair&lt;iterator,bool&gt; </span><br><span class="line"># 第四种方法非常直观，但存在一个性能的问题。插入3时，先在mapStu中查找主键为3的项，若没发现，则将一个键为3，值为初始化值的对组插入到mapStu中，然后再将值修改成“小刘”。若发现已存在3这个键，则修改这个键对应的value。</span><br><span class="line"></span><br><span class="line">string strName &#x3D; mapStu[2];   &#x2F;&#x2F; 取操作或插入操作只有当mapStu存在2这个键时才是正确的取操作，否则会自动插入一个实例，键为2，值为初始化值(0)。</span><br><span class="line"></span><br><span class="line">for (map&lt;int,string&gt;::iterator it&#x3D;mapA.begin(); it!&#x3D;mapA.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">    pair&lt;int, string&gt; pr &#x3D; *it;</span><br><span class="line">    int iKey &#x3D; pr.first;</span><br><span class="line">    string strValue &#x3D; pr.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map&lt; T1, T2, less&lt;T1&gt; &gt;  mapA;      &#x2F;&#x2F; 该容器是按键的升序方式排列元素。未指定函数对象，默认采用less&lt;T1&gt;函数对象。</span><br><span class="line">map&lt; T1, T2, greater&lt;T1&gt; &gt; mapB;    &#x2F;&#x2F; 该容器是按键的降序方式排列元素。</span><br><span class="line"># less&lt;T1&gt;与greater&lt;T1&gt;  可以替换成其它的函数对象functor。</span><br><span class="line"># 可编写自定义函数对象以进行自定义类型的比较，使用方法与set构造时所用的函数对象一样。</span><br><span class="line">map.begin();        &#x2F;&#x2F; 返回容器中第一个数据的迭代器。</span><br><span class="line">map.end();          &#x2F;&#x2F; 返回容器中最后一个数据之后的迭代器。</span><br><span class="line">map.rbegin();       &#x2F;&#x2F; 返回容器中倒数第一个元素的迭代器。</span><br><span class="line">map.rend();         &#x2F;&#x2F; 返回容器中倒数最后一个元素的后面的迭代器。</span><br><span class="line"></span><br><span class="line">map(const map &amp;mp);		        &#x2F;&#x2F; 拷贝构造函数</span><br><span class="line">map&amp; operator&#x3D;(const map &amp;mp);	&#x2F;&#x2F; 重载等号操作符</span><br><span class="line">map.swap(mp);				    &#x2F;&#x2F; 交换两个集合容器</span><br><span class="line"></span><br><span class="line">map.size();	        &#x2F;&#x2F; 返回容器中元素的数目</span><br><span class="line">map.empty();        &#x2F;&#x2F; 判断容器是否为空</span><br><span class="line"></span><br><span class="line">map.clear();		&#x2F;&#x2F; 删除所有元素</span><br><span class="line">map.erase(pos);	    &#x2F;&#x2F; 删除pos迭代器所指的元素，返回下一个元素的迭代器</span><br><span class="line">map.erase(beg,end);	&#x2F;&#x2F; 删除区间[beg,end)的所有元素，返回下一个元素的迭代器    mapA.erase(mapA.begin());</span><br><span class="line">map.erase(keyElem); &#x2F;&#x2F; 删除容器中key为keyElem的对组 mapA.erase(5);  </span><br><span class="line"></span><br><span class="line">map.find(key);      &#x2F;&#x2F; 查找键key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回map.end();</span><br><span class="line">map.count(keyElem); &#x2F;&#x2F; 返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</span><br><span class="line">map.lower_bound(keyElem);       &#x2F;&#x2F; 返回第一个key&gt;&#x3D;keyElem元素的迭代器。</span><br><span class="line">map.upper_bound(keyElem);	    &#x2F;&#x2F; 返回第一个key&gt;keyElem元素的迭代器。</span><br><span class="line"></span><br><span class="line">map.equal_range(keyElem);		&#x2F;&#x2F; 返回容器中key与keyElem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[begin,end)。</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="http://c.biancheng.net/view/331.html" target="_blank" rel="noopener">C++容器（STL容器）</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>32-linux-网络编程</title>
    <url>/2020/03/03/32-linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>NAT映射：<br>打洞机制：</p>
<h2 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h2><p>IP地址：标识主机。端口号：表示主机中的一个进程。socket是linux的伪文件(不存储数据，不占任何空间)类型。在网络通信中，套接字是成对出现的。<br>每个套接字都有一个发送缓冲区和一个接收缓冲区。一端的发送缓冲区对应另一端的接收缓冲区。</p>
<p><img src="/images/32-linux-网络编程/5.套接字.png" alt="&quot;5.套接字&quot;"></p>
<ul>
<li>linux的7种文件类型：</li>
</ul>
<ol>
<li>普通文件类型(-)</li>
<li>目录文件(d)</li>
<li>块设备(b)和 字符设备(c)</li>
<li>套接字文件(s)</li>
<li>管道文件(p)</li>
<li>符号链接(l)</li>
</ol>
<h2 id="网络字节序和主机字节序的转换"><a href="#网络字节序和主机字节序的转换" class="headerlink" title="网络字节序和主机字节序的转换"></a>网络字节序和主机字节序的转换</h2><p>大端：低地址高字节<br>小端：低地址低字节<br>网络数据流采用大端字节序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;arpa&#x2F;inet.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; h表示host n表示network l表示32位长整数 2表示16位短整数</span><br><span class="line">uint32_t htonl(uint32_t hostlong);</span><br><span class="line">uint16_t htons(uint16_t hostshort);</span><br><span class="line">uint32_t ntohl(uint32_t netlong);</span><br><span class="line">uint16_t ntohs(uint16_t netshort);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;arpa&#x2F;inet.h&gt;</span><br><span class="line">int inet_pton(int af, const char *src, void *dst);  &#x2F;&#x2F; 点分十进制 字符串转网络字节序</span><br><span class="line">const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);  &#x2F;&#x2F; 网络字节序转点分十进制字符串</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct sockaddr &#123;</span><br><span class="line">	sa_family_t sa_family; 		&#x2F;* address family, AF_xxx *&#x2F;</span><br><span class="line">	char sa_data[14];			&#x2F;* 14 bytes of protocol address *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct sockaddr_in &#123;</span><br><span class="line">	__kernel_sa_family_t sin_family; 			&#x2F;* Address family *&#x2F;  	地址结构类型</span><br><span class="line">	__be16 sin_port;					 		        &#x2F;* Port number *&#x2F;		端口号</span><br><span class="line">	struct in_addr sin_addr;					    &#x2F;* Internet address *&#x2F;	IP地址</span><br><span class="line"></span><br><span class="line">	&#x2F;* Pad to size of &#96;struct sockaddr&#39;. *&#x2F;</span><br><span class="line">	unsigned char __pad[__SOCK_SIZE__ - sizeof(short int) -</span><br><span class="line">	sizeof(unsigned short int) - sizeof(struct in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct in_addr &#123;						&#x2F;* Internet address. *&#x2F;</span><br><span class="line">	__be32 s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="网络套接字函数"><a href="#网络套接字函数" class="headerlink" title="网络套接字函数"></a>网络套接字函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt; &#x2F;* See NOTES *&#x2F;</span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; socket()打开一个网络通讯端口，如果成功返回文件描述符(读写)</span><br><span class="line">int socket(int domain, int type, int protocol); </span><br><span class="line">domain:</span><br><span class="line">	AF_INET 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址</span><br><span class="line">	AF_INET6 与上面类似，不过是来用IPv6的地址</span><br><span class="line">type:</span><br><span class="line">	SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。</span><br><span class="line">	SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。</span><br><span class="line">protocol:</span><br><span class="line">	传0 表示使用默认协议。</span><br><span class="line">返回值：</span><br><span class="line">	成功：返回指向新创建的socket的文件描述符，失败：返回-1，设置errno</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt; &#x2F;* See NOTES *&#x2F;</span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 服务器绑定固定网络地址和端口号</span><br><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">参数：</span><br><span class="line">  sockfd：socket文件描述符</span><br><span class="line">  addr: 构造出IP地址加端口号</span><br><span class="line">  addrlen: sizeof(addr)长度</span><br><span class="line">返回值：</span><br><span class="line">	成功返回0，失败返回-1, 设置errno</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt; &#x2F;* See NOTES *&#x2F;</span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 同时允许多少个客户端建立连接</span><br><span class="line">int listen(int sockfd, int backlog);</span><br><span class="line">sockfd:</span><br><span class="line">	socket文件描述符</span><br><span class="line">backlog:</span><br><span class="line">	排队建立3次握手队列和刚刚建立3次握手队列的链接数和</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt; 		&#x2F;* See NOTES *&#x2F;</span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 三次握手完成后，服务器调用accept()接收连接，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。</span><br><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br><span class="line">sockdf:</span><br><span class="line">	socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">	传出参数，返回链接客户端地址信息，含IP地址和端口号</span><br><span class="line">addrlen:</span><br><span class="line">	传入传出参数（值-结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小</span><br><span class="line">返回值：</span><br><span class="line">	成功返回一个新的socket文件描述符，用于和客户端通信，失败返回-1，设置errno</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt; 					&#x2F;* See NOTES *&#x2F;</span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;</span><br><span class="line"></span><br><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">sockdf:</span><br><span class="line">	socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">	传入参数，指定服务器端地址信息，含IP地址和端口号</span><br><span class="line">addrlen:</span><br><span class="line">	传入参数,传入sizeof(addr)大小</span><br><span class="line">返回值：</span><br><span class="line">	成功返回0，失败返回-1，设置errno</span><br></pre></td></tr></table></figure>
<h1 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h1><p><img src="/images/32-linux-网络编程/1.网络体系结构.jpg" alt="&quot;1.网络体系结构&quot;"></p>
<p>TCP在不可靠的IP层上提供了一个可靠的传输层：传输方传递的数据报是需要接收方确认的。IP层将数据发送给接收方这一过程是不可靠的，因为可能存在数据丢失。一旦数据<br>丢失，接收方会要求传输方重传一份。这样传输方就进行超时重传，如果IP层成功把数据投递给接收方，就不在需要超时重传了。</p>
<p>TCP可靠：确认和重传机制；数据排序；流量控制；拥塞控制</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>TCP提供面向连接的、可靠的、基于字节流的传输层协议。面向连接的通信过程包括三个阶段：连接建立、数据传输和连接释放。连接建立在客户端和服务器之间需要进行三次握手。在socket编程中，三次握手过程由客户端执行connect来触发。<br><img src="/images/32-linux-网络编程/2.三次握手.png" alt="&quot;2.三次握手&quot;"></p>
<p><strong>三次握手过程</strong>：</p>
<ul>
<li>第一次握手：客户机的TCP首先向服务器的TCP发送一个连接请求报文段。这个特殊的报文段中<strong>不含应用层数据</strong>，其首部中的SYN同步位被置为1。另外客户机会随机选择一个起始序号seq=x(连接请求报文不携带数据，但要消耗掉一个序号)。[SYN=1，ACK=0，seq=x]</li>
<li>第二次握手：服务器TCP收到连接请求报文段后，如同意建立连接，就向客户机发回确认，<strong>并为该TCP连接分配TCP缓存和变量</strong>。在确认报文段中，SYN和ACK位都被置为1，确认号字段ack的值为x+1，并且服务器随机产生起始序号seq=y(确认报文不携带数据，但也要消耗掉一个序号)。[SYN=1，ACK=1，ack=x+1，seq=y]。通过服务器发过来的x+1确认号字段可以确认服务器收到了连接请求，因为只有收到了连接请求才知道客户机发送信息包含seq=x。</li>
<li>第三次握手：当客户机收到确认报文段后，还要向服务器给出确认，并且也要<strong>给该连接分配缓存和变量</strong>。这个报文段的ACK标志位被置为1，序号字段seq为x+1，确认号字段ack=y+1。该报文段可以携带数据，如果不携带数据则不消耗序号。[ACK=1，seq=x+1，ack=y+1]</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>序号字段seq：占4个字节。TCP是面向字节流的(也就是TCP传送时是按照一个一个字节来传送的)，所以TCP连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的编号。</li>
<li>确认号字段ack：占4个字节。确认号字段是期望收到对方的下一个报文段的数据的第一个字节的序号。若确认号=N，表示到序号N-1为止的所有数据都已正确收到。</li>
<li>确认位ACK：只有当ACK=1时确认好字段才有效。当ACK=0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1。</li>
<li>同步位SYN：同步SYN=1表示这是一个连接请求或连接接收报文。当SYN=1，ACK=0时，表示这是一个连接请求报文，对方若同意建立连接，则在响应报文中使用SYN=1，ACK=1。</li>
</ul>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="/images/32-linux-网络编程/3.四次挥手.png" alt="&quot;3.四次挥手&quot;"></p>
<p><strong>四次挥手过程</strong>：</p>
<ul>
<li>第一次挥手：客户机打算关闭连接，就向其TCP发送一个连接释放报文段，并停止再发送数据，主动关闭TCP连接，该报文段的FIN标志位被置1，seq=u，它等于前面已传送过的数据的最后一个字节的序号加1(FIN报文段即使不携带数据，也要消耗掉一个序号)。TCP是全双工的，即可以想象成一条TCP连接上有两条数据通路。当发送FIN报文时，发送FIN的一段就不能再发送数据，也就是关闭了其中一条数据通路，但对方还可以发送数据。</li>
<li>第二次挥手：服务器收到连接释放报文段后即发出确认，确认号ack=u+1，而这个报文段自己的序号是v，等于它前面已传送过的数据的最后一个字节的序号加1。此时，从客户机到服务器这个方向的连接就释放了，TCP连接处于半关闭状态。但服务器若发送数据，客户端仍要接收，即从服务器到客户机这个方向的连接并未关闭。</li>
<li>第三次挥手：若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时其发出FIN=1的连接释放报文段。</li>
<li>第四次挥手：客户机收到连接释放报文段后，必须发出确认。在确认报文段中，ACK字段被置为1，确认好ack=w+1，序号seq=u+1。此时TCP连接还没有释放掉，必须经过时间等待计时器设置的时间2MSL后，A才进入连接关闭状态。</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>终止位FIN：用来释放一个连接。FIN=1表明此报文段的发送方的数据已发送完毕，并要求释放传输连接。</li>
</ul>
<h3 id="为什么是三次握手和四次挥手"><a href="#为什么是三次握手和四次挥手" class="headerlink" title="为什么是三次握手和四次挥手"></a>为什么是三次握手和四次挥手</h3><p><strong>为什么是三次握手</strong>：<br>首先，TCP是面向连接的。正常来说建立连接需要四步：<br>第一步：客户机向服务器发送连接请求。[SYN=1，ACK=0，seq=x]<br>第二步：服务器接收到客户机的连接请求，发回响应。[SYN=1，ACK=1，ack=x+1]<br>第三步：服务器向客户端发送连接请求。[SYN=1，ACK=0，seq=y]<br>第四步：客户机接收到服务器的连接请求，发回响应。[SYN=1，ACK=1，ack=y+1]</p>
<p>显然，第二步和第三步其实是可以合并的。服务器接收到客户机的连接请求，发回响应的同时可以向客户机请求连接。<br>同时，第四步中SYN=1在第三次握手中省去了。原因在于第四步客户机接收的服务器的连接请求后，此时客户机和服务器都已经准备好了。所以客户机可以在这个响应中开始传输数据，也可以不传输数据。因为同步SYN=1表示这是一个连接请求或连接接收报文，所以第三次握手SYN=0。综上三次握手总结如下：<br>第一次握手：客户机向服务器发送连接请求。[SYN=1，ACK=0，seq=x]<br>第二次握手：服务器接收到客户机的连接请求，发回响应并发送连接请求。[SYN=1，ACK=1，ack=x+1，seq=y]<br>第三次握手：客户机接收到服务器的连接请求，发回响应(可以携带数据也可以不携带数据)。[SYN=0，ACK=1，ack=y+1，seq=x+1]</p>
<p><strong>为什么是四次挥手</strong>：</p>
<ul>
<li>第一次挥手：客户机打算关闭连接。[FIN=1，seq=u]</li>
<li>第二次挥手：服务器收到连接释放报文段后即发出确认。[ACK=1，seq=v，ack=u+1]</li>
<li>第三次挥手：服务器打算关闭连接。[FIN=1，ACK=1，seq=w，ack=u+1]</li>
<li>第四次挥手：客户机收到连接释放报文段后，必须发出确认。[ACK=1，seq=u+1，ack=w+1]</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li><p>为什么要进行四次挥手？<br>客户机关闭服务器连接和服务器关闭客户机连接之间可能还有数据传输。</p>
</li>
<li><p>如何保证每次发送的报文段都被对方成功处理了呢？<br>超时重传机制。即发送报文段后，如果没有接收到对方的响应，就会重新发送报文段。从另一个角度讲，这个资源也会保留一段时间。</p>
</li>
<li><p>如何保证第四次挥手服务器成功接收到了呢？<br>服务器打算关闭连接的必要条件是：客户机回应可以关闭连接并成功被服务器接受到。<br>第三次挥手服务器发送的报文段可能出现三种情况：客户端成功接收释放连接请求，第四次挥手的响应报文段被服务器成功接收。此时关闭连接；客户端成功接收释放连接请求，第四次挥手的响应报文段因网络问题没有被服务器接收。此时服务器超时重传；客户端没有接收到释放连接请求。此时服务器超时重传。为了处理这种情况，第四次挥手之后，客户端不会向服务器发送报文段。此时如果服务器没有接收到客户端的报文段，就会超时重传。所以客户端需要等待一段时间，也就是报文最大生存时间的2倍(2MSL，Maximum Segment Lifetime)。如果在这段时间中没有再次接收到服务器的关闭连接请求，就说明服务器接收到了客户机的响应报文。</p>
</li>
<li><p>为什么一般都是客户端先挥手？<br>如果是服务器先第一次挥手，则客户端进行第三次挥手。第四次服务器响应，为了保证客户端收到这个响应，服务器需要等待一段时间。在这段时间服务器的资源就不会释放，同时服务器由于绑定了端口，则这段时间该端口就不能被使用了。此时，如果重新运行服务端程序，服务器程序就会出现套接字占用的问题。<br>而客户端是不绑定具体端口的，如果是客户端先挥手，这次连接的端口即使因为2MSL的资源保留时间不能使用。客户端也可以用其他的端口与服务器进行连接。</p>
</li>
</ul>
<h2 id="linux网络套接字"><a href="#linux网络套接字" class="headerlink" title="linux网络套接字"></a>linux网络套接字</h2><p><img src="/images/32-linux-网络编程/4.linux网络通信.png" alt="&quot;4.linux网络通信&quot;"></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.jianshu.com/p/6e9e4156ece3" target="_blank" rel="noopener">一篇文章带你详解 HTTP 协议（网络协议篇一）</a><br><a href="https://www.jianshu.com/p/9f3e879a4c9c" target="_blank" rel="noopener">一篇文章带你熟悉 TCP/IP 协议（网络协议篇二）</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>35-linux-线程</title>
    <url>/2020/04/02/35-linux-%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>Linux下的线程本质上是轻量级的进程(Light-Weight Process, LWP)。线程号和线程ID是有区别的。线程号(LWP)给内核看的，线程ID给用户看的。<br>找到程序对应的进程ID，<code>ps -Lf pid</code>查看线程的LWP号。CPU根据线程的LWP号调用线程。</p>
<ul>
<li>进程和线程的区别</li>
</ul>
<ol>
<li>Linux的进程有独立的地址空间，拥有PCB;Linux的线程之间共享地址空间，每个线程都有PCB。从内核看进程和线程是一样的。</li>
<li>Linux的进程是最小资源分配单元;Linux线程是最小执行单元。</li>
</ol>
<p>线程共享资源：文件描述符表、每种信号的处理方式、当前工作目录、用户ID和组ID、内存地址空间(.text/.data/.bss/heap/动态库加载区/环境变量/命令行参数)<br>线程非共享资源：线程id、处理器现场和栈指针(内核栈)、独立的栈空间(用户栈)、.errno变量、信号屏蔽字、调度优先级</p>
<p>父子进程之间共享资源：全局变量、.data、.text、栈、堆、环境变量、用户ID、宿主目录、进程工作目录、信号处理方式<br>父子进程之间不共享资源：进程ID、fork返回值、进程运行时间、闹钟(定时器)、未决信号集</p>
<h2 id="线程创建、退出和回收"><a href="#线程创建、退出和回收" class="headerlink" title="线程创建、退出和回收"></a>线程创建、退出和回收</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取线程ID</span><br><span class="line">pthread_t pthread_self(void);	</span><br><span class="line">返回值：线程ID：pthread_t类型，本质：在Linux下为无符号整数(%lu)。线程ID是一个进程内部的识别不同线程的标志。(两个进程间，线程ID允许相同)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 线程创建</span><br><span class="line">int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</span><br><span class="line">参数：	</span><br><span class="line">  thread: 传出参数，表示新创建的子线程id(pthread_t是无符号长整型) </span><br><span class="line">	attr: 通常传NULL，表示使用线程默认属性(线程不分离，子线程要父线程回收)。设置该参数可以实现线程分离。</span><br><span class="line">	start_routine: 函数指针，指向线程主函数(线程体)，该函数运行结束，则线程结束。</span><br><span class="line">	arg: 线程主函数执行期间所使用的参数。</span><br><span class="line">返回值：</span><br><span class="line">  成功：0；	失败：错误号	-----&gt;Linux环境下，所有线程特点，失败均直接返回错误号。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 线程退出</span><br><span class="line">void pthread_exit(void *retval);	</span><br><span class="line">参数：</span><br><span class="line">  retval: 表示线程退出状态，通常传NULL</span><br><span class="line">注意：</span><br><span class="line">  线程中不可以使用exit函数退出线程,exit函数时退出进程的。使用exit函数会导致所有线程都退出。</span><br><span class="line">  return：返回到调用函数(在主线程中执行return和exit的效果一样)</span><br><span class="line">	pthread_exit()：将调用该函数的线程退出(不管是在线程中的哪个函数，一旦调用这个函数就会退出线程)			</span><br><span class="line">	exit: 将进程退出</span><br><span class="line"></span><br><span class="line">int pthread_join(pthread_t thread, void **retval); 成功：0；失败：错误号</span><br><span class="line">参数：</span><br><span class="line">  thread：要回收的子进程的线程ID(注意：不是指针)</span><br><span class="line">  retval：存储线程结束状态</span><br></pre></td></tr></table></figure>
<p>在一个线程中调用pthread_create()创建新的线程后，当前线程从pthread_create()返回继续往下执行，而新的线程所执行的代码由我们传给pthread_create的函数指针start_routine决定。start_routine函数接收一个参数，是通过pthread_create的arg参数传递给它的，该参数的类型为void <em>，这个指针按什么类型解释由调用者自己定义。start_routine的返回值类型也是void </em>，这个指针的含义同样由调用者自己定义。start_routine返回时，这个线程就退出了，其它线程可以调用pthread_join得到start_routine的返回值。</p>
<p>pthread_create成功返回后，新创建的线程的id被填写到thread参数所指向的内存单元。我们知道进程id的类型是pid_t，每个进程的id在整个系统中是唯一的，调用getpid()可以获得当前进程的id。线程id的类型是thread_t，它只在当前进程中保证是唯一的，调用pthread_self()可以获得当前线程的id。</p>
<ul>
<li><p>return/exit/pthread_exit</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void *tfn(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	i &#x3D; (int)arg; &#x2F;&#x2F; 强转</span><br><span class="line">	if (i &#x3D;&#x3D; 2)</span><br><span class="line">		pthread_exit(NULL); &#x2F;&#x2F; 退出线程</span><br><span class="line"></span><br><span class="line">	sleep(i);	 &#x2F;&#x2F; 通过i来区别每个线程</span><br><span class="line">	printf(&quot;I&#39;m %dth thread, Thread_ID &#x3D; %lu\n&quot;, i+1, pthread_self());</span><br><span class="line"></span><br><span class="line">	return NULL;  &#x2F;&#x2F; 返回到调用函数,和pthread_exit作用一样,返回值可以用pthread_join接收</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int n &#x3D; 5, i;</span><br><span class="line">	pthread_t tid;</span><br><span class="line"></span><br><span class="line">	if (argc &#x3D;&#x3D; 2)</span><br><span class="line">		n &#x3D; atoi(argv[1]);</span><br><span class="line"></span><br><span class="line">	for (i&#x3D;0; i&lt;n; i++) &#123;</span><br><span class="line">		pthread_create(&amp;tid, NULL, tfn, (void *)i);	&#x2F;&#x2F; 不能用指针,这样指向主线程的栈空间</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  pthread_exit(NULL); &#x2F;&#x2F; 主线程退出对子线程没有影响</span><br><span class="line">&#x2F;&#x2F;	sleep(n);</span><br><span class="line">	printf(&quot;I am main, I&#39;m a thread!\n&quot; </span><br><span class="line">			&quot;main_thread_ID &#x3D; %lu\n&quot;, pthread_self());</span><br><span class="line"></span><br><span class="line">	return 0; &#x2F;&#x2F; 主线程中return和exit的作用一样，都会使所有线程退出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程回收</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">	int a;</span><br><span class="line">	int b;</span><br><span class="line">&#125; exit_t;</span><br><span class="line"></span><br><span class="line">void *tfn(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	exit_t *ret;</span><br><span class="line">	ret &#x3D; malloc(sizeof(exit_t)); </span><br><span class="line"></span><br><span class="line">	ret-&gt;a &#x3D; 100;</span><br><span class="line">	ret-&gt;b &#x3D; 300;</span><br><span class="line">	pthread_exit((void *)ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	pthread_t tid;</span><br><span class="line">	exit_t *retval;</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">	&#x2F;&#x2F; 调用pthread_join可以获取线程的退出状态</span><br><span class="line">	pthread_join(tid, (void **)&amp;retval);</span><br><span class="line">	printf(&quot;a &#x3D; %d, b &#x3D; %d \n&quot;, retval-&gt;a, retval-&gt;b);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h2><p>线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。线程分离有两种方法：调用pthread_detach函数<br>或者通过pthread_create的线程属性参数attr来设置线程分离。</p>
<p>一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join获取它的状态为止。但是线程被置为detach状态时，线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL。如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 杀死(取消线程) 线程可以调用该函数可以终止自己也可以终止统一进程中的另一个线程</span><br><span class="line">int pthread_cancel(pthread_t thread);	成功：0；失败：错误号 </span><br><span class="line"></span><br><span class="line">线程的取消并不是实时的，有一定的延时。需要等待线程到达某个取消点(检查点)。</span><br><span class="line">取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用：creat，open，pause，close，read，write等	</span><br><span class="line"></span><br><span class="line">pthread_testcancel(); &#x2F;&#x2F; 这个函数可以设置一个取消点</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void *tfn1(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;thread 1 returning\n&quot;);</span><br><span class="line">	return (void *)1; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *tfn2(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;thread 2 exiting\n&quot;);</span><br><span class="line">	pthread_exit((void *)2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *tfn3(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		pthread_testcancel();	&#x2F;&#x2F; 自己添加取消点</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	pthread_t tid;</span><br><span class="line">	void *tret &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;tid, NULL, tfn1, NULL);</span><br><span class="line">	pthread_join(tid, &amp;tret);</span><br><span class="line">	printf(&quot;thread 1 exit code &#x3D; %d\n\n&quot;, (int)tret); &#x2F;&#x2F; tret&#x3D;1</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;tid, NULL, tfn2, NULL);</span><br><span class="line">	pthread_join(tid, &amp;tret);</span><br><span class="line">	printf(&quot;thread 2 exit code &#x3D; %d\n\n&quot;, (int)tret); &#x2F;&#x2F; tret&#x3D;2</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;tid, NULL, tfn3, NULL);</span><br><span class="line">	sleep(3);</span><br><span class="line">	pthread_cancel(tid);        &#x2F;&#x2F; 有取消点才能取消</span><br><span class="line">	pthread_join(tid, &amp;tret);   &#x2F;&#x2F; 回收失败 tret&#x3D;-1</span><br><span class="line">	printf(&quot;thread 3 exit code &#x3D; %d\n&quot;, (int)tret);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程的分离状态决定一个线程以什么样的方式来终止自己。<br><strong>非分离状态</strong>：线程的默认属性是非分离状态。这种情况下，原有的线程等待创建的线程结束。<br>  只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。<br><strong>分离状态</strong>：分离线程没有被其他的线程所等待，运行结束线程就终止了，马上释放系统资源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 线程分离</span><br><span class="line">int pthread_detach(pthread_t thread);	成功：0；失败：错误号</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 线程属性</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  int etachstate; 	  &#x2F;&#x2F; 线程的分离状态</span><br><span class="line">  int schedpolicy; 	  &#x2F;&#x2F; 线程调度策略</span><br><span class="line">  struct sched_param	schedparam; 	&#x2F;&#x2F; 线程的调度参数</span><br><span class="line">  int inheritsched; 	&#x2F;&#x2F; 线程的继承性</span><br><span class="line">  int scope; 		      &#x2F;&#x2F; 线程的作用域</span><br><span class="line">  size_t guardsize; 	&#x2F;&#x2F; 线程栈末尾的警戒缓冲区大小</span><br><span class="line">  int stackaddr_set;  &#x2F;&#x2F; 线程的栈设置</span><br><span class="line">  void* stackaddr; 	  &#x2F;&#x2F; 线程栈的位置</span><br><span class="line">  size_t stacksize; 	&#x2F;&#x2F; 线程栈的大小</span><br><span class="line">&#125; pthread_attr_t; </span><br><span class="line"></span><br><span class="line">属性值不能直接设置，须使用相关函数进行操作。</span><br><span class="line">初始化的函数为pthread_attr_init，这个函数必须在pthread_create函数之前调用。</span><br><span class="line">之后须用pthread_attr_destroy函数来释放资源。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化线程属性</span><br><span class="line">int pthread_attr_init(pthread_attr_t *attr); 成功：0；失败：错误号</span><br><span class="line">&#x2F;&#x2F; 销毁线程属性所占用的资源</span><br><span class="line">int pthread_attr_destroy(pthread_attr_t *attr); 成功：0；失败：错误号</span><br><span class="line">&#x2F;&#x2F; 设置线程属性，分离or非分离</span><br><span class="line">int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate); </span><br><span class="line">&#x2F;&#x2F; 获取线程属性，分离or非分离</span><br><span class="line">pthread_attr_getdetachstate(pthread_attr_t *attr, int *detachstate); </span><br><span class="line">参数：</span><br><span class="line">  attr：已初始化的线程属性</span><br><span class="line">  detachstate：	PTHREAD_CREATE_DETACHED(分离线程)&#x2F;PTHREAD _CREATE_JOINABLE(非分离线程)</span><br><span class="line">注意：</span><br><span class="line">  如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了。</span><br><span class="line">  它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用pthread_create的线程就得到了错误的线程号。</span><br><span class="line">  要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timedwait函数，让这个线程等待一会儿，留出足够的时间让函数pthread_create返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait()之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void *tfn(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;thread: pid &#x3D; %d, tid &#x3D; %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	pthread_t tid;</span><br><span class="line">	void *tret;</span><br><span class="line"></span><br><span class="line">	int ret &#x3D; pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">	if(ret !&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(stderr, &quot;pthread_create error: %s\n&quot;, strerror(ret));</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ret &#x3D; pthread_detach(tid);   </span><br><span class="line">	if(ret !&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(stderr, &quot;pthread_detach error: %s\n&quot;, strerror(ret));</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	sleep(1);</span><br><span class="line"></span><br><span class="line">	ret &#x3D; pthread_join(tid, &amp;tret);</span><br><span class="line">	if (ret !&#x3D; 0)</span><br><span class="line">		fprintf(stderr, &quot;pthread_join %s\n&quot;, strerror(ret));</span><br><span class="line">	else</span><br><span class="line">		fprintf(stderr, &quot;thread exit code %d\n&quot;, (int)tret);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void *tfn(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;thread: pid &#x3D; %d, tid &#x3D; %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	pthread_t tid;</span><br><span class="line">	pthread_attr_t attr;			&#x2F;&#x2F; 通过线程属性来设置游离态</span><br><span class="line">	void *tret;</span><br><span class="line">		</span><br><span class="line">	int ret &#x3D; pthread_attr_init(&amp;attr);</span><br><span class="line">	if(ret !&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(stderr, &quot;attr_init error %s\n&quot;, strerror(ret));</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ret &#x3D; pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">	if(ret !&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(stderr, &quot;attr_setdetachstate error %s\n&quot;, strerror(ret));</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">	ret &#x3D; pthread_create(&amp;tid, &amp;attr, tfn, NULL);</span><br><span class="line">	if(ret !&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(stderr, &quot;pthread_create error %s\n&quot;, strerror(ret));</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	sleep(1);</span><br><span class="line"></span><br><span class="line">	ret &#x3D; pthread_join(tid, &amp;tret);</span><br><span class="line">	if (ret !&#x3D; 0)</span><br><span class="line">		fprintf(stderr, &quot;pthread_join %s\n&quot;, strerror(ret));</span><br><span class="line">	else</span><br><span class="line">		fprintf(stderr, &quot;thread exit code %d\n&quot;, (int)tret);	</span><br><span class="line"></span><br><span class="line">	ret &#x3D; pthread_attr_destroy(&amp;attr);</span><br><span class="line">	if(ret !&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(stderr, &quot;pthread_create error %s\n&quot;, strerror(ret));</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：</li>
</ul>
<ol>
<li>如何避免僵尸线程？<br>pthread_join回收；pthread_detach设置线程分离；pthread_create指定分离属性</li>
<li>应避免在多线程模型中调用fork，避免引入信号机制。</li>
<li>malloc和mmap申请的内存可以被其他线程释放</li>
</ol>
<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>两个线程对同一个全局变量进行访问，会导致资源不同步的情况，最后对全局变量的操作混乱。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAX 10000</span><br><span class="line">int number;</span><br><span class="line"></span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line"></span><br><span class="line">void err_thread(int ret, char *str)</span><br><span class="line">&#123;</span><br><span class="line">    if (ret !&#x3D; 0) &#123;</span><br><span class="line">        fprintf(stderr, &quot;%s:%s\n&quot;, str, strerror(ret));</span><br><span class="line">        pthread_exit(NULL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* funcA_num(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i&#x3D;0; i&lt;MAX; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int cur &#x3D; number;</span><br><span class="line">		cur++;</span><br><span class="line">		number &#x3D; cur;</span><br><span class="line">		printf(&quot;Thread A, id &#x3D; %lu, number &#x3D; %d\n&quot;, pthread_self(), number);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* funcB_num(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i&#x3D;0; i&lt;MAX; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int cur &#x3D; number;</span><br><span class="line">		cur++;</span><br><span class="line">		number &#x3D; cur;</span><br><span class="line">		printf(&quot;Thread B, id &#x3D; %lu, number &#x3D; %d\n&quot;, pthread_self(), number);	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 由于没有锁,导致++操作不是有序的,最终结果到不了20000</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t p1, p2;</span><br><span class="line">	</span><br><span class="line">	pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line"></span><br><span class="line">    int ret &#x3D; pthread_create(&amp;p1, NULL, funcA_num, NULL);</span><br><span class="line">    err_thread(ret, &quot;pthread_create error&quot;);</span><br><span class="line"></span><br><span class="line">    ret &#x3D; pthread_create(&amp;p2, NULL, funcB_num, NULL);</span><br><span class="line">    err_thread(ret, &quot;pthread_create error&quot;);</span><br><span class="line">    </span><br><span class="line">    pthread_join(p1, NULL);</span><br><span class="line">	pthread_join(p2, NULL);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>Linux中提供一把互斥锁mutex(也称之为互斥量)。每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。<br>资源还是共享的，线程间也还是竞争的，但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</span><br><span class="line">参数：</span><br><span class="line">	mutex: 传出参数，调用时应传&amp;mutex </span><br><span class="line">		restrict关键字：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改</span><br><span class="line">	attr: 互斥量属性。是一个传入参数，通常传NULL，选用默认属性(线程间共享)</span><br><span class="line"></span><br><span class="line">1. 静态初始化：如果互斥锁 mutex 是静态分配的(定义在全局，或加了static关键字修饰)，可以直接使用宏进行初始化。</span><br><span class="line">	比如： pthead_mutex_t muetx &#x3D; PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">2. 动态初始化：局部变量应采用动态初始化。比如：pthread_mutex_init(&amp;mutex, NULL)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 线程加锁</span><br><span class="line">int pthread_mutex_lock(pthread_mutex_t *mutex);	&#x2F;&#x2F; lock尝试加锁，如果加锁不成功，线程阻塞直到持有该互斥量的其他线程解锁为止。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 线程解锁</span><br><span class="line">int pthread_mutex_unlock(pthread_mutex_t *mutex);	&#x2F;&#x2F; unlock解锁，同时将阻塞在该锁上的所有线程全部唤醒。</span><br><span class="line">													&#x2F;&#x2F; 至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 尝试加锁</span><br><span class="line">int pthread_mutex_trylock(pthread_mutex_t *mutex);	&#x2F;&#x2F; trylock加锁失败直接返回错误号EBUSY，不阻塞。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 销毁一个互斥锁</span><br><span class="line">int pthread_mutex_destroy(pthread_mutex_t *mutex);</span><br></pre></td></tr></table></figure>
<p>注意：<br>    在访问共享资源前加锁，访问结束后立即解锁。锁的“粒度”应越小越好。<br>    线程加锁要避免死锁的情况：</p>
<pre><code>    1. 线程1拥有A锁，请求获得B锁；线程2拥有B锁，请求获得A锁
    2. 线程试图对同一个互斥量加锁两次
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAX 10000</span><br><span class="line">int number;</span><br><span class="line"></span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line"></span><br><span class="line">void err_thread(int ret, char *str)</span><br><span class="line">&#123;</span><br><span class="line">    if (ret !&#x3D; 0) &#123;</span><br><span class="line">        fprintf(stderr, &quot;%s:%s\n&quot;, str, strerror(ret));</span><br><span class="line">        pthread_exit(NULL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* funcA_num(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i&#x3D;0; i&lt;MAX; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_mutex_lock(&amp;mutex);</span><br><span class="line">		int cur &#x3D; number;</span><br><span class="line">		cur++;</span><br><span class="line">		number &#x3D; cur;</span><br><span class="line">		printf(&quot;Thread A, id &#x3D; %lu, number &#x3D; %d\n&quot;, pthread_self(), number);</span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">		usleep(10);		&#x2F;&#x2F; 保证其它线程有拿到锁的可能性</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* funcB_num(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i&#x3D;0; i&lt;MAX; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_mutex_lock(&amp;mutex);	&#x2F;&#x2F; 两个线程都要加锁，一个线程加锁另一个线程不加锁等于没加锁</span><br><span class="line">		int cur &#x3D; number;</span><br><span class="line">		cur++;</span><br><span class="line">		number &#x3D; cur;</span><br><span class="line">		printf(&quot;Thread B, id &#x3D; %lu, number &#x3D; %d\n&quot;, pthread_self(), number);</span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);		</span><br><span class="line">		usleep(10);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t p1, p2;</span><br><span class="line">	</span><br><span class="line">	pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line"></span><br><span class="line">    int ret &#x3D; pthread_create(&amp;p1, NULL, funcA_num, NULL);</span><br><span class="line">    err_thread(ret, &quot;pthread_create error&quot;);</span><br><span class="line"></span><br><span class="line">    ret &#x3D; pthread_create(&amp;p2, NULL, funcB_num, NULL);</span><br><span class="line">    err_thread(ret, &quot;pthread_create error&quot;);</span><br><span class="line">    </span><br><span class="line">    pthread_join(p1, NULL);</span><br><span class="line">	pthread_join(p2, NULL);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>一把读写锁具备三种状态：读模式下加锁状态 (读锁)；写模式下加锁状态 (写锁)；不加锁状态。</p>
<p>读写锁是“写模式加锁”时， 解锁前，所有对该锁加锁的线程都会被阻塞。<br>读写锁是“读模式加锁”时， 如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。<br>读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求，优先满足写模式锁。即读锁、写锁并行阻塞，<strong>写锁优先级高</strong>。</p>
<p>读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。写独占、读共享。读写锁非常适合于对数据结构读的次数远大于写的情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化一把读写锁</span><br><span class="line">int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</span><br><span class="line">参数：</span><br><span class="line">	attr表读写锁属性，通常使用默认属性，传NULL即可。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 销毁一把读写锁</span><br><span class="line">int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以读方式请求读写锁（请求读锁）</span><br><span class="line">int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以写方式请求读写锁（请求写锁）</span><br><span class="line">int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解锁</span><br><span class="line">int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 非阻塞以读方式请求读写锁（非阻塞请求读锁）</span><br><span class="line">int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 非阻塞以写方式请求读写锁（非阻塞请求写锁）</span><br><span class="line">int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">int counter;</span><br><span class="line">pthread_rwlock_t rwlock;</span><br><span class="line"></span><br><span class="line">&#x2F;* 3个线程不定时写同一全局资源，5个线程不定时读同一全局资源 *&#x2F;</span><br><span class="line">void *write_func(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    int i &#x3D; (int)arg;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        t &#x3D; counter;   </span><br><span class="line">        usleep(1000);</span><br><span class="line">        printf(&quot;write_func %d: %lu: counter&#x3D;%d ++counter&#x3D;%d\n&quot;, i, pthread_self(), t, ++counter);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(10000);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line">void *read_func(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; (int)arg;</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        printf(&quot;read_func %d: %lu: %d\n&quot;, i, pthread_self(), counter);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    pthread_t tid[8];</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, NULL);</span><br><span class="line"></span><br><span class="line">    for (i&#x3D;0; i&lt;3; i++)</span><br><span class="line">        pthread_create(&amp;tid[i], NULL, write_func, (void *)i);</span><br><span class="line"></span><br><span class="line">    for (i&#x3D;0; i&lt;5; i++)</span><br><span class="line">        pthread_create(&amp;tid[i+3], NULL, read_func, (void *)i);</span><br><span class="line"></span><br><span class="line">    for (i&#x3D;0; i&lt;8; i++)</span><br><span class="line">        pthread_join(tid[i], NULL);</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>条件变量本身不是锁，可以造成线程阻塞，通常和互斥锁配合使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化一个条件变量</span><br><span class="line">int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);		</span><br><span class="line">参数：</span><br><span class="line">	attr：条件变量属性，通常为默认值，传NULL即可</span><br><span class="line"></span><br><span class="line">也可以使用静态初始化的方法，初始化条件变量：pthread_cond_t cond &#x3D; PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 阻塞等待一个条件变量</span><br><span class="line">int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</span><br><span class="line">函数作用：</span><br><span class="line">1. 阻塞等待条件变量cond满足	</span><br><span class="line">2. 释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(&amp;mutex); 第1步和第2步是原子操作。</span><br><span class="line">3. 当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 限时等待一个条件变量</span><br><span class="line">int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 唤醒至少一个阻塞在条件变量上的线程</span><br><span class="line">int pthread_cond_signal(pthread_cond_t *cond);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 唤醒全部阻塞在条件变量上的线程</span><br><span class="line">int pthread_cond_broadcast(pthread_cond_t *cond);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 销毁一个条件变量</span><br><span class="line">int pthread_cond_destroy(pthread_cond_t *cond);</span><br></pre></td></tr></table></figure>
<ul>
<li>生产者消费者模型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 借助条件变量模拟 生产者-消费者 问题</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 链表作为公享数据,需被互斥量保护</span><br><span class="line">struct msg &#123;</span><br><span class="line">    struct msg *next;</span><br><span class="line">    int num;</span><br><span class="line">&#125;;</span><br><span class="line">struct msg *head;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 静态初始化 一个条件变量 和 一个互斥量</span><br><span class="line">pthread_cond_t has_product &#x3D; PTHREAD_COND_INITIALIZER;</span><br><span class="line">pthread_mutex_t lock &#x3D; PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">void *consumer(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    struct msg *mp;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        while (head &#x3D;&#x3D; NULL) &#123;           	&#x2F;&#x2F; 头指针为空,说明没有节点 多个消费者不可以为if</span><br><span class="line">            pthread_cond_wait(&amp;has_product, &amp;lock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mp &#x3D; head;      </span><br><span class="line">        head &#x3D; mp-&gt;next;                	&#x2F;&#x2F; 模拟消费掉一个产品</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line">        printf(&quot;Consume %lu-------------%d\n&quot;, pthread_self(), mp-&gt;num);</span><br><span class="line">        free(mp);</span><br><span class="line">        sleep(rand() % 8 + 4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *producer(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    struct msg *mp;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        mp &#x3D; malloc(sizeof(struct msg));</span><br><span class="line">        mp-&gt;num &#x3D; rand() % 1000 + 1;        &#x2F;&#x2F; 模拟生产一个产品</span><br><span class="line">        printf(&quot;Produce -------------%d\n&quot;, mp-&gt;num);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        mp-&gt;next &#x3D; head;</span><br><span class="line">        head &#x3D; mp;</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line">        pthread_cond_signal(&amp;has_product);  &#x2F;&#x2F; 将等待在该条件变量上的一个线程唤醒</span><br><span class="line"></span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t pid, cid[4];</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">	int i &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;pid, NULL, producer, NULL);</span><br><span class="line"></span><br><span class="line">    for (i&#x3D;0; i&lt;4; i++)</span><br><span class="line">        pthread_create(&amp;cid[i], NULL, consumer, NULL);</span><br><span class="line"></span><br><span class="line">	pthread_join(pid, NULL);</span><br><span class="line">    for (i&#x3D;0; i&lt;4; i++)</span><br><span class="line">        pthread_join(cid[i], NULL);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相较于mutex而言，条件变量可以减少竞争。如直接使用mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量。但如果仓库中没有数据，消费者之间竞争互斥锁是无意义的。有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争，提高了程序效率。</p>
<h2 id="信号量-线程-进程同步"><a href="#信号量-线程-进程同步" class="headerlink" title="信号量(线程/进程同步)"></a>信号量(线程/进程同步)</h2><p>相当于初始化值为N的互斥量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化一个信号量semaphore</span><br><span class="line">int sem_init(sem_t *sem, int pshared, unsigned int value);</span><br><span class="line">参数：</span><br><span class="line">	sem：信号量	</span><br><span class="line">	pshared：pshared取0用于线程间；1用于进程间同步</span><br><span class="line">	value：指定信号量初值，决定了占用信号量的线程的个数。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 给信号量加锁 --操作</span><br><span class="line">int sem_wait(sem_t *sem);</span><br><span class="line">信号量大于0，则信号量--；信号量等于0，造成线程阻塞</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 给信号量解锁 ++操作 同时唤醒阻塞在信号量上的线程</span><br><span class="line">int sem_post(sem_t *sem);	</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 尝试对信号量加锁 --操作</span><br><span class="line">int sem_trywait(sem_t *sem);	</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 限时尝试对信号量加锁 --操作</span><br><span class="line">int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 销毁一个信号量</span><br><span class="line">int sem_destroy(sem_t *sem);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*信号量实现 生产者 消费者问题*&#x2F;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line"></span><br><span class="line">#define NUM 5       </span><br><span class="line"></span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">	int data;</span><br><span class="line">	struct node* next;</span><br><span class="line">&#125;Node;        	&#x2F;&#x2F; 链表的长度受信号量控制</span><br><span class="line"></span><br><span class="line">Node* head &#x3D; NULL;                              </span><br><span class="line">sem_t blank_number, product_number;                 &#x2F;&#x2F; 空格子信号量, 产品信号量</span><br><span class="line"></span><br><span class="line">void *producer(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        sem_wait(&amp;blank_number);                    &#x2F;&#x2F; 生产者将空格子数--,为0则阻塞等待</span><br><span class="line">		</span><br><span class="line">        Node* node &#x3D; (Node*)malloc(sizeof(Node));</span><br><span class="line">        node-&gt;data &#x3D; rand() % 100 + 1;</span><br><span class="line">		node-&gt;next &#x3D; head;</span><br><span class="line">		head &#x3D; node;</span><br><span class="line">		printf(&quot;producer: %lu, %d\n&quot;, pthread_self(), node-&gt;data);</span><br><span class="line">		</span><br><span class="line">        sem_post(&amp;product_number);                 </span><br><span class="line">        sleep(rand()%1);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *consumer(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	int j &#x3D; (int)arg;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">	</span><br><span class="line">    while (1) </span><br><span class="line">	&#123;</span><br><span class="line">        sem_wait(&amp;product_number);                  &#x2F;&#x2F; 消费者将产品数--,为0则阻塞等待</span><br><span class="line">		</span><br><span class="line">		Node* del &#x3D; head;</span><br><span class="line">		head &#x3D; head-&gt;next;</span><br><span class="line">		</span><br><span class="line">        printf(&quot;Consumer %d: -----------%lu, %d\n&quot;, j, pthread_self(), del-&gt;data);</span><br><span class="line">		free(del);</span><br><span class="line"></span><br><span class="line">        sem_post(&amp;blank_number);                    &#x2F;&#x2F; 消费掉以后,将空格子数++</span><br><span class="line">        sleep(rand()%3); </span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t pid, cid[4];</span><br><span class="line">	int i &#x3D; 0;</span><br><span class="line">	</span><br><span class="line">    sem_init(&amp;blank_number, 0, NUM);                &#x2F;&#x2F; 初始化空格子信号量为5</span><br><span class="line">    sem_init(&amp;product_number, 0, 0);                &#x2F;&#x2F; 产品数为0</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;pid, NULL, producer, NULL);</span><br><span class="line">    </span><br><span class="line">    for (i&#x3D;0; i&lt;4; i++)</span><br><span class="line">        pthread_create(&amp;cid[i], NULL, consumer, (void*)i);</span><br><span class="line"></span><br><span class="line">	pthread_join(pid, NULL);</span><br><span class="line">    for (i&#x3D;0; i&lt;4; i++)</span><br><span class="line">        pthread_join(cid[i], NULL);</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;blank_number);</span><br><span class="line">    sem_destroy(&amp;product_number);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>进程间也可以使用互斥锁，来达到同步的目的。但应在pthread_mutex_init初始化之前，修改其属性为进程间共享。</p>
<h3 id="互斥量-1"><a href="#互斥量-1" class="headerlink" title="互斥量"></a>互斥量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化一个mutex属性对象</span><br><span class="line">int pthread_mutexattr_init(pthread_mutexattr_t *attr);</span><br><span class="line">参数：</span><br><span class="line">	pthread_mutexattr_t mattr 类型用于定义mutex锁的属性</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 销毁mutex属性对象 (而非销毁锁)</span><br><span class="line">int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改mutex属性。</span><br><span class="line">int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, int pshared);</span><br><span class="line">参数：</span><br><span class="line">	pshared取值：线程锁：PTHREAD_PROCESS_PRIVATE (mutex的默认属性即为线程锁，进程间私有)</span><br><span class="line">				进程锁：PTHREAD_PROCESS_SHARED</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;mman.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line"></span><br><span class="line">struct mt &#123;</span><br><span class="line">    int num;</span><br><span class="line">    pthread_mutex_t mutex;</span><br><span class="line">    pthread_mutexattr_t mutexattr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int fd, i;</span><br><span class="line">    struct mt *mm;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    fd &#x3D; open(&quot;mt_test&quot;, O_CREAT|O_RDWR, 0777);</span><br><span class="line">    ftruncate(fd, sizeof(*mm));</span><br><span class="line">	</span><br><span class="line">    mm &#x3D; mmap(NULL, sizeof(*mm), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</span><br><span class="line">    close(fd);</span><br><span class="line">    unlink(&quot;mt_test&quot;);</span><br><span class="line">    &#x2F;&#x2F;mm &#x3D; mmap(NULL, sizeof(*mm), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON, -1, 0);</span><br><span class="line"></span><br><span class="line">    memset(mm, 0, sizeof(*mm));</span><br><span class="line"></span><br><span class="line">    pthread_mutexattr_init(&amp;mm-&gt;mutexattr);                                  &#x2F;&#x2F; 初始化mutex属性对象</span><br><span class="line">    pthread_mutexattr_setpshared(&amp;mm-&gt;mutexattr, PTHREAD_PROCESS_SHARED);    &#x2F;&#x2F; 修改属性为进程间共享</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mm-&gt;mutex, &amp;mm-&gt;mutexattr);                          &#x2F;&#x2F; 初始化一把mutex琐</span><br><span class="line"></span><br><span class="line">    pid &#x3D; fork();</span><br><span class="line">    if (pid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        for (i&#x3D;0; i&lt;10; i++) &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;mm-&gt;mutex);</span><br><span class="line">            (mm-&gt;num)++;</span><br><span class="line">            printf(&quot;child------num++	%d\n&quot;, mm-&gt;num);</span><br><span class="line">            pthread_mutex_unlock(&amp;mm-&gt;mutex);</span><br><span class="line">            sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (pid &gt; 0) &#123;</span><br><span class="line">        for (i&#x3D;0; i&lt;10; i++) &#123;</span><br><span class="line">            sleep(1);</span><br><span class="line">            pthread_mutex_lock(&amp;mm-&gt;mutex);</span><br><span class="line">            mm-&gt;num +&#x3D; 2;</span><br><span class="line">            printf(&quot;parent------num+&#x3D;2  %d\n&quot;, mm-&gt;num);</span><br><span class="line">            pthread_mutex_unlock(&amp;mm-&gt;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutexattr_destroy(&amp;mm-&gt;mutexattr);          &#x2F;&#x2F; 销毁mutex属性对象</span><br><span class="line">    pthread_mutex_destroy(&amp;mm-&gt;mutex);                  &#x2F;&#x2F; 销毁mutex</span><br><span class="line">    munmap(mm,sizeof(*mm));                             &#x2F;&#x2F; 释放映射区</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h3><p><a href="https://www.cnblogs.com/wanghuaijun/p/7738788.html" target="_blank" rel="noopener"> Linux的进程间通信-文件和文件锁</a><br>文件锁不能用于线程间。</p>
<h3 id="条件变量-1"><a href="#条件变量-1" class="headerlink" title="条件变量"></a>条件变量</h3><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>线程同步有四种方式：互斥锁、读写锁(适合多线程中读锁多，写锁少的情况。写锁优先级高于读锁)、条件变量(阻塞线程)、信号量。</p>
]]></content>
  </entry>
</search>
